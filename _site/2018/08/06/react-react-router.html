
<!DOCTYPE>
<html lang="zh-cn" data-scribe-reduced-action-queue="true">
<head>
    <meta content='React & React Router - Tate & Snow' name='title' />
    <meta content='React & React Router - Tate & Snow' name='og:title' />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <title>React & React Router - Tate & Snow</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>React & React Router - Tate & Snow</title>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React & React Router - Tate & Snow">
<meta name="twitter:keywords" content="React & React Router - Tate & Snow" property='og:description' />
<meta property="og:type" content="article">
<meta property="og:title" content="React & React Router - Tate & Snow">
<meta name="og:keywords" content="React & React Router - Tate & Snow|React &amp; React RouterReact 是一个 View 层的框架，用来渲染视图，它主要做几件事情:  组件化  利用 props 形成单向的数据流  根据 state 的变化来更新 view  利用虚拟 DOM ..."
  property='og:description' />
<link rel="icon" type="image/png" href="http://localhost:2333/style/favicons/favicon.ico" />
<link href="http://localhost:2333/style/favicons/favicon.ico" rel="shortcut icon" type="image/png">
<link rel="canonical" href="http://localhost:2333/">
<link rel="alternate" type="application/rss+xml" title="Liberxue" href="http://localhost:2333/feed.xml">
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="http://localhost:2333/style/favicons/favicon.ico" type="image/x-icon">
<meta name="keywords" content="React &amp; React RouterReact 是一个 View 层的框架，用来渲染视图，它主要做几件事情:  组件化  利用 props 形成单向的数据流  根据 state 的变化来更新 view  利用虚拟 DOM ..." property='og:description'
/>
<meta name="description" content="Tate & Snow's Github blog" />
<link href="https://cdn.bootcss.com/highlight.js/9.10.0/styles/xcode.min.css" rel="stylesheet">
<link href="http://localhost:2333/style/theme.css" rel="stylesheet"> 
<meta content='http://localhost:2333/2018/08/06/react-react-router.html' property='og:url' />
<meta content="http://localhost:2333/2018/08/06/react-react-router.html|React &amp; React RouterReact 是一个 View 层的框架，用来渲染视图，它主要做几件事情:  组件化  利用 props 形成单向的数据流  根据 state 的变化来更新 view  利用虚拟 DOM ..." property='og:description'
/>
<meta content="article" property="og:type" /> 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136311746-1"></script>
<!-- <script async src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script>
  window.dataLayer = window.dataLayer || [];
  window.GA_TRACKING_ID = 'UA-136311746-1'
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('set', {
    'country': 'US',
    'currency': 'USD',
    'description': 'fuck',
  });
  gtag('config', GA_TRACKING_ID, {
    'custom_map': {
      'dimension1': 'post_title',
    },
    'post_title': 'test',
  });
</script>
<meta content="" property="fb:app_id" />
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>React &amp; React Router | Tate &amp; Snow</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="React &amp; React Router" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="React &amp; React Router" />
<meta property="og:description" content="React &amp; React Router" />
<link rel="canonical" href="http://localhost:2333/2018/08/06/react-react-router.html" />
<meta property="og:url" content="http://localhost:2333/2018/08/06/react-react-router.html" />
<meta property="og:site_name" content="Tate &amp; Snow" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-06T20:47:00+08:00" />
<script type="application/ld+json">
{"description":"React &amp; React Router","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:2333/2018/08/06/react-react-router.html"},"@type":"BlogPosting","url":"http://localhost:2333/2018/08/06/react-react-router.html","headline":"React &amp; React Router","dateModified":"2018-08-06T20:47:00+08:00","datePublished":"2018-08-06T20:47:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<script>
  (function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s);
    js.id = id;
    js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

</head>

<body class="dark-theme" gtools_scp_screen_capture_injected="true">
    <header id="header" class="header bg-white">
        <div class="navbar-container">
            <a href="Javascript:;" onclick="onClickLogo()" title="访问 Tate & Snow" class="navbar-logo menu-logo">
                <img src="http://localhost:2333/style/images/tate.png" alt="Tate & Snow"> </a>
            <!-- <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">Tate & Snow</a>   -->
            <div class="navbar-menu">
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('首页', '/')" title="访问 首页" data-hover="首页">首页</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('前端', '/front')" title="访问 前端" data-hover="前端">前端</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('历史', '/history')" title="访问 历史" data-hover="历史">历史</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('其他', '/other')" title="访问 其他" data-hover="其他">其他</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('标签', '/tags')" title="访问 标签" data-hover="标签">标签</a>
                
                  <a class=" menu-item-about " href="Javascript:;" onclick="onClickMenu('关于', '/README')" title="访问 关于" data-hover="关于">关于</a>
                
            </div>
            <!-- <div class="navbar-menu">
                
                <a href="http://localhost:2333/">首页</a>
                
                <a href="http://localhost:2333/front">前端</a>
                
                <a href="http://localhost:2333/history">历史</a>
                
                <a href="http://localhost:2333/other">其他</a>
                
                <a href="http://localhost:2333/tags">标签</a>
                
                <a href="http://localhost:2333/README">关于</a>
                
            </div> -->
            <div class="navbar-search menu-item-search" onclick="onClickSearch()">
                <span class="icon-search"></span>
                <form id="cb-search-btn" role="search">
                    <span class="search-box">
                        <input type="text" class="input" id="cb-search-content" required="true" placeholder="标题 标签..." maxlength="30" autocomplete="off">
                    </span>
                </form>
            </div>
            <div class="navbar-mobile-menu" onclick="">
                <span class="icon-menu cross">
                    <span class="middle"></span>
                </span>
                <ul>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('首页', 'http://localhost:2333/')">首页</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('前端', 'http://localhost:2333/front')">前端</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('历史', 'http://localhost:2333/history')">历史</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('其他', 'http://localhost:2333/other')">其他</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('标签', 'http://localhost:2333/tags')">标签</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('关于', 'http://localhost:2333/README')">关于</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </header>
    <a href="#header" class="back-to-top" onclick="onClickTop('React & React Router')">⤴Top⤴</a>
    <div class="post-header-thumb bg-white}">
        <div class="post-header-thumb-op"></div>
        <div class="post-header-thumb">
            <div class="post-header-thumb-container">
                <h1 class="post-title" itemprop="name headline">
                    React & React Router</h1>
                <div class="post-data">
                    <time datetime="2018-08-06 20:47:00" itemprop="datePublished">
                      发布时间：2018-08-06 20:47:00
                      &nbsp;&nbsp;&nbsp;
                      
                        修改时间：2020-11-05 17:41:00
                      
                    </time>
                    <a onclick="onClickCategory('前端')" href="Javascript:;" title="访问 前端" data-hover="博客分类: 前端">博客分类: 前端</a>
                    <!-- <a href="#read"> 阅读次数: comments</a>  -->
                </div>
                
                <div class="post-tags">
                       
                    <a class="menu-item-tags" href="Javascript:;" onclick="onClickTag('React')" title="访问React" data-hover="React">
                        React
                        <span>(11)</span>
                        
                    </a>
                       
                </div>
            </div>
        </div>
    </div>
    <article class="main-content post-page" itemscope itemtype="http://schema.org/Article">
        <div class="post-header">
            <h1 class="post-title" itemprop="name headline">
                React & React Router</h1>
            <div class="post-data">
                <time datetime="2018-08-06 20:47:00" itemprop="datePublished">2018-08-06 20:47:00</time>
            </div>
        </div>
        <div id="post-content" class="post-content" itemprop="articleBody">
            <p class="post-tags">
                   
                <a href="Javascript:;" onclick="onClickTag('React')" title="访问React" data-hover="React">
                    React
                    <span>(11)</span>
                    </a>
                   
            </p>
            <h1 id="react--react-router">React &amp; React Router</h1>

<p>React 是一个 View 层的框架，用来渲染视图，它主要做几件事情:</p>

<ul>
  <li>组件化</li>
  <li>利用 props 形成单向的数据流</li>
  <li>根据 state 的变化来更新 view</li>
  <li>利用虚拟 DOM 来提升渲染性能</li>
</ul>

<blockquote>
  <p>React 将 DOM 抽象为 <strong>虚拟 DOM</strong>, 然后通过新旧虚拟 DOM 这两个对象的差异(<strong>Diff</strong> 算法)，将变化的部分重新渲染，具体可以<a href="http://localhost:2333/2019/10/24/react-virtual-dom.html">查看我的这篇博客</a> 👈</p>
</blockquote>

<h2 id="安装">安装</h2>

<p>可以使用 npm 快速构建 React 开发环境，5.20+ 也可以使用包启动器 <a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b">npx</a>。<strong>create-react-app</strong> 自动创建的项目基于 Webpack + ES6。</p>

<pre><code class="language-SHELL"># npm
npm install -g create-react-app
create-react-app my-app

# npx
npx create-react-app my-app
</code></pre>

<h2 id="jsx">JSX</h2>

<p><strong>JSX</strong> 是一种 JavaScript 的语法扩展，在 JSX 当中的表达式要包含在大括号里，之后通过 <strong>ReactDOM.render()</strong> 渲染到页面。为了将组件是和模板紧密关联，可以把 HTML 模板直接嵌入到 JS 代码里面，但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用。</p>

<pre><code class="language-JSX">// 如果 JSX 标签是闭合式的，那么你需要在结尾处用 /&gt;, 就好像 XML/HTML 一样：
const myDivElement = &lt;div className="foo" /&gt;;
const element = &lt;img src={user.avatarUrl} /&gt;;
</code></pre>

<blockquote>
  <p>HTML 里的 class 在 JSX 里要写成 <strong>className</strong>，因为 class 在 JS 里是保留关键字。同理某些属性比如 for 要写成 <strong>htmlFor</strong>。</p>
</blockquote>

<p>与 JS 的混合写法:</p>

<pre><code class="language-JSX">function Item(props) {
  return &lt;li&gt;{props.message}&lt;/li&gt;;
}

function TodoList() {
  const todos = ['finish doc', 'submit pr', 'nag dan to review'];
  return (
    &lt;ul&gt; // 数组元素中使用的 key 在其兄弟之间应该是独一无二的，如 id
      {todos.map((message) =&gt; &lt;Item key={message} message={message} /&gt;)}
    &lt;/ul&gt;
    {!isFetching &amp;&amp; // isFetching 为 false 时才显示 button
      &lt;button onClick={this.handleRefreshClick}&gt;
        Refresh
      &lt;/button&gt;
    }
  );
}
</code></pre>

<p>本质上来讲，JSX 只是为 <strong>React.createElement(component, props, …children)</strong> 方法提供的语法糖，可<a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D">查看 babel 在线转换示例</a>:</p>

<pre><code class="language-JSX">&lt;MyButton color="blue" shadowSize={2}&gt;
  Click Me
&lt;/MyButton&gt;

// 编译为
React.createElement(
  MyButton,
  {color: 'blue', shadowSize: 2},
  'Click Me'
)
</code></pre>

<p>如果你已经有了个 props 对象，并且想在 JSX 中传递它，你可以使用 … 作为扩展操作符来传递整个属性对象。下面两个组件是等效的:</p>

<pre><code class="language-JSX">function App1() {
  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;
}

// 等价于
function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return &lt;Greeting {...props} /&gt;;
}
</code></pre>

<p>再看个完整的栗子 🌰:</p>

<pre><code class="language-JSX">function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

// 在一个组件的子元素位置使用注释要用 { } 包起来
const element = (
  {/* formatName */}
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);

// React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。
ReactDOM.render(
  element,
  document.getElementById('root')
);
</code></pre>

<h2 id="组件">组件</h2>

<h3 id="props-输入属性">props 输入属性</h3>

<p>组件从概念上看就像是函数，它可以接收任意的输入值(称之为 “props”)，并返回一个需要在页面上展示的 React 元素。</p>

<pre><code class="language-JSX">// 组件名采用大驼峰写法
function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

// 等价于
class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}

// React 元素也可以是用户自定义的组件
const element = &lt;Welcome name="Sara" /&gt;;
</code></pre>

<h3 id="prop-types">prop-types</h3>

<p>更多关于类型检查<a href="https://doc.react-china.org/docs/typechecking-with-proptypes.html">可以看 <strong>prop-types</strong></a>:</p>

<pre><code class="language-JSX">import PropTypes from 'prop-types';

class Greeting extends React.Component {
  // 如果 babel 使用了 transform-class-properties，也可以写静态属性
  static propTypes = {
    name: PropTypes.string.isRequired
  }
  static defaultProps = {
    name: 'stranger'
  }

  render() {
    return (
      &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
    );
  }
}

// 常规写法
Greeting.propTypes = {
  name: PropTypes.string,
  optionalBool: PropTypes.bool,
  // 链式写法
  requiredFunc: PropTypes.func.isRequired,
  // 一个指定元素类型的数组
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),
  // 限制它为列举类型之一的对象
  optionalUnion: PropTypes.oneOfType([
    PropTypes.array,
    PropTypes.object,
    PropTypes.instanceOf(Message)
  ]),
  // 一个指定属性及其类型的对象
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),
  // 自定义 validator
  customProp: function(props, propName, componentName) {
  if (!/matchme/.test(props[propName])) {
    return new Error(
      'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.'
    );
  }
},
};

// 可以通过配置 defaultProps 为 props 定义默认值，类型检查发生在 defaultProps 赋值之后，所以类型检查也会应用在 defaultProps 上面
Greeting.defaultProps = {
  name: 'Tate'
};
</code></pre>

<blockquote>
  <p>无论是使用函数或是类来声明一个组件，它决不能修改它自己的 <strong>props</strong>。若应用的界面是随时间动态变化的，此时需要用到另一个属性 <strong>state</strong>。</p>
</blockquote>

<h3 id="state-状态">State 状态</h3>

<p><a href="https://juejin.im/entry/59522bdb6fb9a06b9a516113">本节内容参考这里</a> 👈</p>

<p>State 必须能代表一个组件 UI 呈现的完整且最小状态集，即组件的任何 UI 改变，都可以从 State 的变化中反映出来。与 Props 的区别主要是 State 是可变的，而后者对于使用它的组件来说，是只读的，要想修改 Props，只能通过该组件的父组件修改。</p>

<pre><code class="language-JSX">this.setState({name: 'Tate'})

// 错误的写法
this.state.title = 'Tate'
</code></pre>

<p>State 的更新是异步的，调用 setState，组件的 state 并不会立即改变，setState 只是把要修改的状态放入一个队列中，React 会优化真正的执行时机，并且 React 会出于性能原因，可能会将多次 setState 的状态修改合并成一次状态修改，因此可能出现一些问题。</p>

<p>举个例子，对于一个电商类应用，在我们的购物车中，当我们点击一次购买数量按钮，购买的数量就会加1，如果我们连续点击了两次按钮，就会连续调用两次 <code class="highlighter-rouge">this.setState({quantity: this.state.quantity + 1})</code>，在 React 合并多次修改为一次的情况下，相当于等价执行了如下代码:</p>

<pre><code class="language-JSX">// 后面的操作覆盖掉了前面的操作，最终购买的数量只增加了 1 个
Object.assign(
  previousState,
  {quantity: this.state.quantity + 1},
  {quantity: this.state.quantity + 1},
)
</code></pre>

<p>因此需要额外参数的帮助:</p>

<pre><code class="language-JSX">this.setState((preState, props) =&gt; {
  counter: preState.quantity + 1
})
</code></pre>

<p>State 的更新是一个<strong>浅合并(Shallow Merge)</strong>的过程。修改组件状态时，只需要传入发生改变的 State，而不是组件完整的 State:</p>

<pre><code class="language-JSX">this.state = {
  title : 'React',
  content : 'React is an wonderful JS library!'
}

// 修改，React 会合并新的 title 到原来的组件状态中，同时保留原有的状态 content
this.setState({title: 'Reactjs'});
</code></pre>

<p>React 官方建议把 State 当作是 immutable 不可变对象，一方面是如果直接修改 this.state，组件并不会重新 render；另一方面 State 中包含的所有状态都应该是不可变对象。当 State 中的某个状态发生变化，我们应该重新创建这个状态对象，而不是直接修改原来的状态。对于状态类型是数组或者对象，可以采取下面这些方法:</p>

<pre><code class="language-JSX">var books = this.state.books
this.setState({
  books: books.concat(['React Guide']);
})

// 或者
this.setState(preState =&gt; ({
  books: [...preState.books, 'React Guide'];
}))
</code></pre>

<h3 id="children">children</h3>

<p>在包含开始和结束标签的 JSX 表达式中，标记之间的内容作为特殊的参数传递：<code class="highlighter-rouge">props.children</code>:</p>

<pre><code class="language-JSX">// Calls the children callback numTimes to produce a repeated component
function Repeat(props) {
  let items = [];
  for (let i = 0; i &lt; props.numTimes; i++) {
    items.push(props.children(i));
  }
  return &lt;div&gt;{items}&lt;/div&gt;;
}

function ListOfTenThings() {
  return (
    &lt;Repeat numTimes={10}&gt;
      {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}
    &lt;/Repeat&gt;
  );
}
</code></pre>

<h3 id="事件处理">事件处理</h3>

<pre><code class="language-JSX">// 类的方法默认是不会绑定 this 的。如果你忘记绑定 this.sayName 并把它传入 onClick，当你调用这个函数的时候 this 的值会是 undefined
class Header extends Component {
  constructor(props) {
    super(props);
    // This binding is necessary to make `this` work in the callback
    this.sayName = this.sayName.bind(this)
  }
  sayName() {
    alert('tate')
  }
  render() {
    return (
      &lt;header className="App-header"&gt;
        &lt;img src={this.props.avatar} className="App-logo" alt="logo" onClick={this.sayName}/&gt;&gt;
        &lt;h1 className="App-title"&gt;Welcome to React&lt;/h1&gt;
      &lt;/header&gt;
    )
  }
}
</code></pre>

<p>或者采用以下方式(推荐):</p>

<pre><code class="language-JSX">class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () =&gt; {
    console.log('this is:', this);
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre>

<p>上面这个语法在 Create React App 中默认开启，如果没有使用属性初始化器语法，则写法为:</p>

<pre><code class="language-JSX">// 每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。
// 然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre>

<p>向事件处理程序传递参数:</p>

<pre><code class="language-JSX">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
// 通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
</code></pre>

<h3 id="生命周期">生命周期</h3>

<p>生命周期的方法有，可<a href="http://www.runoob.com/try/try.php?filename=try_react_life_cycle2">查看此处示例</a>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">生命周期方法</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">componentWillMount</td>
      <td style="text-align: left">(Deprecated)在渲染前调用,在客户端也在服务端</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>componentDidMount</strong></td>
      <td style="text-align: left">在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode() 来进行访问</td>
    </tr>
    <tr>
      <td style="text-align: left">componentWillReceiveProps</td>
      <td style="text-align: left">(Deprecated)在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>static getDerivedStateFromProps</strong></td>
      <td style="text-align: left">替代 componentWillReceiveProps。组件实例化后和接受新属性时将会调用。它应该返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>getSnapshotBeforeUpdate</strong></td>
      <td style="text-align: left">在最新的渲染输出提交给 DOM 前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>shouldComponentUpdate</strong></td>
      <td style="text-align: left">返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。可以在你确认不需要更新组件时使用。</td>
    </tr>
    <tr>
      <td style="text-align: left">componentWillUpdate</td>
      <td style="text-align: left">(Deprecated)在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>componentDidUpdate</strong></td>
      <td style="text-align: left">在组件完成更新后立即调用。在初始化时不会被调用</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>componentWillUnmount</strong></td>
      <td style="text-align: left">在组件从 DOM 中移除的时候立刻被调用</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-JSX">class Example extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    // 这一生命周期方法是静态的，它在组件实例化或接收到新的 props 时被触发
    // 若它的返回值是对象，则将被用于更新 state ；若是 null ，则不触发 state 的更新

    // 配合 `componentDidUpdate` 使用，这一方法可以取代 `componentWillReceiveProps`
    if (nextProps.currentRow !== prevState.lastRow) {
      return {
        isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,
        lastRow: nextProps.currentRow,
      };
    }
    // 默认不改动 state
    return null;
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 该方法在实际改动（比如 DOM 更新）发生前的“瞬间”被调用，返回值将作为 `componentDidUpdate` 的第三个参数

    // 配合 `componentDidUpdate` 使用，这一方法可以取代 `componentWillUpdate`
  }

  componentDidUpdate(props, state, snaptshot) {
    // 新增的参数 snapshot 即是之前调用 getSnapshotBeforeUpdate 的返回值
  }
}
</code></pre>

<h3 id="注意点">注意点</h3>

<p>1、JavaScript 中的一些 “falsy” 值(比如数字0)，它们依然会被渲染。例如，下面的代码不会像你预期的那样运行，因为当 props.message 为空数组时，它会打印 0:</p>

<pre><code class="language-JSX">&lt;div&gt;
  {props.messages.length &amp;&amp;
    &lt;MessageList messages={props.messages} /&gt;
  }
&lt;/div&gt;

// 必须确保 &amp;&amp; 前面的表达式始终为布尔值或强制转为 bool 类型也可以，!!props.messages.length
&lt;div&gt;
  {props.messages.length &gt; 0 &amp;&amp;
    &lt;MessageList messages={props.messages} /&gt;
  }
&lt;/div&gt;
</code></pre>

<h2 id="fragments">Fragments</h2>

<p>React 中的一个常见模式是一个组件返回多个元素。<a href="https://react.docschina.org/blog/2017/11/28/react-v16.2.0-fragment-support.html#support-for-fragment-syntax"><strong>Fragments</strong></a> 允许你将子列表分组，而无需向 DOM 添加额外节点:</p>

<pre><code class="language-JSX">render() {
  return (
    &lt;React.Fragment&gt;
      &lt;ChildA /&gt;
      &lt;ChildB /&gt;
      &lt;ChildC /&gt;
    &lt;/React.Fragment&gt;
  );
}
</code></pre>

<blockquote>
  <p>Fragments 还支持短语法 <code class="highlighter-rouge">&lt;&gt;</code>，但是它需要工具编译支持，且不支持 key 或属性。</p>
</blockquote>

<h2 id="refs">Refs</h2>

<p>在典型的 React 数据流中, 属性(props)是父组件与子组件交互的唯一方式。要修改子组件，你需要使用新的 props 重新渲染它。但是，某些情况下你需要在典型数据流外强制修改子组件。要修改的子组件可以是 React 组件的实例，也可以是 DOM 元素。对于这两种情况，React 提供了 <strong>Refs</strong>。</p>

<p>1、创建 Refs</p>

<p>使用的时候需要通过 <code class="highlighter-rouge">React.createRef()</code> 创建 refs，然后通过 ref 属性来获得 React 元素:</p>

<pre><code class="language-JSX">class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return &lt;div ref={this.myRef} /&gt;
  }
}
</code></pre>

<blockquote>
  <p>注意不能在函数式组件上使用 ref 属性，因为他们没有实例，除非将其转换为 class 组件。</p>
</blockquote>

<p>2、访问 Refs</p>

<p>当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 <strong>current</strong> 属性对节点的引用进行访问:</p>

<pre><code class="language-JSX">const node = this.myRef.current
</code></pre>

<p>查看完整示例:</p>

<pre><code class="language-JSX">class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建 ref 存储 textInput DOM 元素
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // 直接使用原生 API 使 text 输入框获得焦点。注意：通过 "current" 取得 DOM 节点
    this.textInput.current.focus();
  }

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;input
          type="text"
          ref={this.textInput}} /&gt;
        &lt;input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<h2 id="reactforwardref">React.forwardRef</h2>

<p><strong>React.forwardRef</strong> 会创建一个 React 组件，能够实现 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html"><strong>Refs 转发</strong></a>，即这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中:</p>

<pre><code class="language-JSX">// 当 React 附加了 ref 属性之后，ref.current 将直接指向 &lt;button&gt; DOM 元素实例。
const FancyButton = React.forwardRef((props, ref) =&gt; (
  &lt;button ref={ref} className="FancyButton"&gt;
    {props.children}
  &lt;/button&gt;
));

// You can now get a ref directly to the DOM button:
const ref = React.createRef();
&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;
</code></pre>

<h2 id="reactlazy--reactsuspense">React.lazy / React.Suspense</h2>

<p><a href="https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy"><strong>React.lazy</strong></a> 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件【:</p>

<pre><code class="language-JSX">// 注意 - 使用 React.lazy 的动态引入特性需要 JS 环境支持 Promise
const SomeComponent = React.lazy(() =&gt; import('./SomeComponent'));
</code></pre>

<p><strong>React.Suspense</strong> 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <code class="highlighter-rouge">&lt;React.Suspense&gt;</code> 支持的唯一用例:</p>

<pre><code class="language-JSX">// 该组件是动态加载的
const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));

function MyComponent() {
  return (
    // 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成
    &lt;React.Suspense fallback={&lt;Spinner /&gt;}&gt;
      &lt;div&gt;
        &lt;OtherComponent /&gt;
      &lt;/div&gt;
    &lt;/React.Suspense&gt;
  );
}
</code></pre>

<h2 id="react-refresh-热更新">react-refresh 热更新</h2>

<p>之前一直用的是<a href="https://gaearon.github.io/react-hot-loader/"><strong>React-hot-loader</strong></a> 可以在不刷新浏览器的情况下进行热更新，但是有个问题就是不能监听样式修改，而且有其它一些小毛病。现在推荐使用 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin"><strong>react-refresh</strong></a>，配置很简单:</p>

<pre><code class="language-JS">// webpack.config.js
const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');
const webpack = require('webpack');
// ... your other imports

const isDevelopment = process.env.NODE_ENV !== 'production';

module.exports = {
  // It is suggested to run both `react-refresh/babel` and the plugin in the `development` mode only,
  // even though both of them have optimisations in place to do nothing in the `production` mode.
  // If you would like to override Webpack's defaults for modes, you can also use the `none` mode -
  // you then will need to set `forceEnable: true` in the plugin's options.
  mode: isDevelopment ? 'development' : 'production',
  module: {
    rules: [
      // ... other rules
      {
        test: /\.[jt]sx?$/,
        exclude: /node_modules/,
        use: [
          // ... other loaders
          {
            loader: require.resolve('babel-loader'),
            options: {
              // ... other options
              plugins: [
                // ... other plugins
                isDevelopment &amp;&amp; require.resolve('react-refresh/babel'),
              ].filter(Boolean),
            },
          },
        ],
      },
    ],
  },
  plugins: [
    // ... other plugins
    isDevelopment &amp;&amp; new webpack.HotModuleReplacementPlugin(),
    isDevelopment &amp;&amp; new ReactRefreshWebpackPlugin(),
  ].filter(Boolean),
  // ... other configuration options
};
</code></pre>

<h2 id="react-loadable">React-loadable</h2>

<p>A higher order component for loading components with dynamic imports，能实现懒加载的功能:</p>

<pre><code class="language-JSX">import Loadable from 'react-loadable'
import Loading from './Loading'

const components = {
  ListComponent: Loadable({
    loader: () =&gt; import('../list/ListComponent'),
    loading: Loading,
  }),
  LayoutComponent: Loadable({
    loader: () =&gt; import('../layout/LayoutComponent'),
    loading: Loading,
  }),
}

export default components
</code></pre>

<h2 id="react-router-4x">React Router 4.x</h2>

<h3 id="router-组件">Router 组件</h3>

<p>React Router 中有三种类型的组件，包括 <strong>Routers</strong>、<strong>Router Matching</strong>、和 <strong>Navigtaion</strong>:</p>

<pre><code class="language-JS">import { BrowserRouter as Router, Route, Link } from 'react-router-dom'
</code></pre>

<h4 id="routers">Routers</h4>

<p>包含 <strong>&lt;BrowserRouter&gt;</strong> 和 <strong>&lt;HashRouter&gt;</strong>，这两种 router 会为你创建专门的 history 对象。一般来说，如果数据是通过动态请求获取的，则使用 BrowserRouter。</p>

<h4 id="router-matching">Router Matching</h4>

<p>匹配路由的组件有两种: <strong>&lt;Route&gt;</strong> 和 <strong>&lt;Switch&gt;</strong>。匹配路由的原理是比较 &lt;Route&gt; 中的 <strong>path</strong> 属性和当前地址的 <strong>pathname</strong>。若匹配，则 &lt;Route&gt; 中 <strong>components</strong> 属性所指定的组件就会被渲染出来。当 &lt;Route&gt; 不指定 path 属性的话则始终被渲染。</p>

<pre><code class="language-JSX">import { Route, Switch } from "react-router-dom";
// when location = { pathname: '/about' }
&lt;Route path='/about' component={About}/&gt; // renders &lt;About/&gt;
&lt;Route path='/contact' component={Contact}/&gt; // renders null
&lt;Route component={Always}/&gt; // renders &lt;Always/&gt;
</code></pre>

<p>&lt;Route&gt; 的 <strong>exact</strong> 表示为 true 时则严格匹配:</p>

<table>
  <thead>
    <tr>
      <th>path</th>
      <th>location.pathname</th>
      <th>exact</th>
      <th>matches?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/one</td>
      <td>/one/two</td>
      <td>true</td>
      <td>no</td>
    </tr>
    <tr>
      <td>/one</td>
      <td>/one/two</td>
      <td>false</td>
      <td>yes</td>
    </tr>
  </tbody>
</table>

<p>&lt;Switch&gt; 可以把这些 &lt;Route&gt; 整合到一起，遍历然后渲染第一个匹配当前地址的 &lt;Route&gt;:</p>

<pre><code class="language-JSX">&lt;Switch&gt;
  &lt;Route exact path="/" component={Home} /&gt;
  &lt;Route path="/about" component={About} /&gt;
  &lt;Route path="/contact" component={Contact} /&gt;
  {/* when none of the above match, &lt;NoMatch&gt; will be rendered */}
  &lt;Route component={NoMatch} /&gt;
&lt;/Switch&gt;
</code></pre>

<h4 id="route-render-props">Route Render Props</h4>

<p>&lt;Route&gt; 有三种组件渲染的参数:</p>

<ul>
  <li><strong>component</strong> - 用来渲染一个已存在的组件</li>
  <li><strong>render</strong> - 传递一个函数。传递局部变量到需要渲染的组件</li>
  <li><strong>children</strong></li>
</ul>

<pre><code class="language-JSX">const Home = () =&gt; &lt;div&gt;Home&lt;/div&gt;;

const App = () =&gt; {
  const someVariable = true;

  return (
    &lt;Switch&gt;
      {/* these are good */}
      &lt;Route exact path="/" component={Home} /&gt;
      &lt;Route
        path="/about"
        render={props =&gt; &lt;About {...props} extra={someVariable} /&gt;}
      /&gt;
    &lt;/Switch&gt;
  );
};
</code></pre>

<h4 id="navigation">Navigation</h4>

<p>React Router 提供了以下三种组件用于在应用中创建链接:</p>

<ul>
  <li><strong>&lt;Link&gt;</strong> - 会渲染成 HTML 中的 a 标签</li>
  <li><strong>&lt;NavLink&gt;</strong> - 是一种特殊类型的 &lt;Link&gt; 组件。当其 to 属性中指定的位置与当前位置匹配时，组件样式将会设置成 “active” 样式</li>
  <li><strong>&lt;Redirect&gt;</strong> - 强制跳转到 to 属性上指定的位置</li>
</ul>

<pre><code class="language-JSX">&lt;Link to='/'&gt;Home&lt;/Link&gt;
// &lt;a href='/'&gt;Home&lt;/a&gt;

// location = { pathname: '/react' }
&lt;NavLink to='/react' activeClassName='hurray'&gt;React&lt;/NavLink&gt;
// &lt;a href='/react' className='hurray'&gt;React&lt;/a&gt;

&lt;Redirect to="/login" /&gt;
</code></pre>

<h3 id="withrouters-deprecated">WithRouters (Deprecated)</h3>

<blockquote>
  <p>不如用钩子 😊</p>
</blockquote>

<p>可通过 <strong>withRouter</strong> 高阶组件来获取 history 对象的属性和 &lt;Route&gt; 中的 match， withRouter 会将已更新的 <strong>match</strong>, <strong>location</strong>, 和 <strong>history</strong> 属性传递到被包裹的组件当中，无论它在哪儿渲染:</p>

<pre><code class="language-JSX">import { withRouter } from "react-router";
...
&lt;Route
  path="/order/:direction(asc|desc)"
  component={ComponentWithRegex}
/&gt;

function ComponentWithRegex({ match }) {
  const { params: { direction } } = match
  return (
    &lt;div&gt;
      &lt;h3&gt;Only asc/desc are allowed: {direction}&lt;/h3&gt;
    &lt;/div&gt;
  );
}

...
const ShowTheLocationWithRouter = withRouter(ShowTheLocation);
</code></pre>

<h3 id="hooks">Hooks</h3>

<p>喜大普奔，React Router 也更新提供了钩子，目前有这四个，我们可以愉快地扔掉高阶函数 withRouter 了:</p>

<ul>
  <li>useHistory - 获取 history 事例，<code class="highlighter-rouge">history.push("/home")</code></li>
  <li>useLocation - 获取 location 对象，<code class="highlighter-rouge">ga.send(["pageview", location.pathname])</code></li>
  <li>useParams - 获取 <code class="highlighter-rouge">match.params</code> 路由参数</li>
  <li>useRouteMatch - It’s mostly useful for getting access to the match data without actually rendering a <code class="highlighter-rouge">&lt;Route&gt;</code>.</li>
</ul>

<pre><code class="language-JS">import { useParams } from 'react-router-dom'

const { client = '' } = useParams&lt;IRouterParams&gt;()
</code></pre>

<h2 id="参考链接">参考链接</h2>

<ol>
  <li><a href="https://doc.react-china.org/docs/hello-world.html">React 官网</a></li>
  <li><a href="http://www.runoob.com/react/react-tutorial.html">React - 菜鸟教程</a></li>
  <li><a href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b">Introducing npx: an npm package runner</a> By Kat Marchán</li>
  <li><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">Controlled and uncontrolled form inputs in React don’t have to be complicated</a> By Gosha Arinich</li>
  <li><a href="https://toddmotto.com/react-create-class-versus-component/">React.createClass versus extends React.Component</a> By Todd Motto</li>
  <li><a href="https://daveceddia.com/convert-createclass-to-es6-class/">Convert React.createClass to ES6 Class</a> By Dave Ceddia</li>
  <li><a href="http://react-guide.github.io/react-router-cn/docs/Introduction.html">gitbook - react-router</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html">React Router 使用教程</a> By 阮一峰</li>
  <li><a href="https://reacttraining.com/react-router/web/guides/quick-start">React Router 官方文档</a></li>
  <li><a href="https://medium.com/@giang.nguyen.dev/hot-loader-with-react-loadable-c8f70c8ce1a6">Hot loader with react-loadable</a> By Go to the profile of Giang Nguyen</li>
  <li><a href="https://juejin.im/post/5abf4a09f265da237719899d">讲讲今后 React 异步渲染带来的生命周期变化</a> By Enix</li>
  <li><a href="https://juejin.im/entry/59522bdb6fb9a06b9a516113">深入理解 React 组件状态(State)</a></li>
  <li><a href="https://juejin.im/post/5a3200fe51882554bd5111a0">React 虚拟 Dom 和 diff 算法</a> By Y__</li>
  <li><a href="http://jdc.jd.com/archives/212552">React Router 4.x 开发，这些雷区我们都帮你踩过了</a> By sunyinfeng</li>
  <li><a href="https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130">Virtual DOM in ReactJS</a> By Rupesh Mishra</li>
</ol>
 
<div id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
      enable: true,
      clientID: '020f142489f80c92b097',
      clientSecret: '1fa083372b44031cf1b8249251515c4e3d54c69d',
      repo: 'tate-young.github.io',
      owner: 'Tate-Young',
      admin: ['Tate-Young'],
      id: location.pathname,      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
<!-- disqus -->
<!-- <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        this.page.url = 'https://tate-young.github.io/2018/08/06/react-react-router.html';
        this.page.identifier = '/2018/08/06/react-react-router';
        this.page.title = 'React & React Router';
    };

    (function () { // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document,
            s = d.createElement('script');

        s.src = '//tate.disqus.com/embed.js'; // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> -->


            <!-- <p class="post-info">
			本文由 <a href="/">liberxue</a> 创作，采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>本站文章除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间为:2018-08-06 20:47:00</p> -->
        </div>
    </article>

    <!-- <div class="related-post-lists">
	<div class="post-lists">
		<div class="post-lists-body">
					<div class="post-list-item">
				<div class="post-list-item-container">
					<div class="item-label">
						<div class="item-title"><a href="induction.html">归纳的随想</a></div>
						<div class="item-meta clearfix">
														<div class="item-meta-ico bg-ico-image" style="background: url('../usr/themes/pinghsu/images/bg-ico.png') no-repeat;background-size: 40px auto;"></div>
	                        							<div class="item-meta-cat"><a href="../category/thoughts/index.html">Thoughts</a></div>
						</div>
					</div>
				</div>
			</div>
				</div>
	</div>
</div> -->

    <!-- <footer class="footer bg-white">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
	 <a class="social segmentfault" target="blank" href="https://segmentfault.com/u/liberxue" title="访问 LiberXue_Twitter" data-hover="Segmentfault">Segmentfault</a>
    <a class="social github" target="blank" href="https://github.com/liberxue" title="访问 LiberXue_Twitter" data-hover="GitHub">GitHub</a>
    <a class="social twitter" target="blank" href="http://twitter.com/liberxue" title="访问 LiberXue_Twitter" data-hover="Twitter">Twitter</a>
     <a class="social stackoverflow" target="blank" href="https://stackoverflow.com/users/6902190/liberxue" title="访问 LiberXue_stackoverflow" data-hover="StackOverflow">StackOverflow</a>
          <a class="social oschina" target="blank" href="https://my.oschina.net/bolanzw" title="访问 LiberXue_Oschina" data-hover="Oschina">Oschina</a>
     <a class="social rss" target="blank" href="/feed.xml"title="访问 LiberXue_RSS" data-hover="RSS">RSS</a>
	</div>
		</div>
	</div>
	<div class="footer-meta">
        <div class="footer-container">
            <div class="meta-item meta-copyright">
                <div class="meta-copyright-info">
                    <a href="/" class="info-logo">
                         <img src="http://localhost:2333/style/images/logo-liberxue.png"   title="访问 LiberXue_blog" data-hover="LiberXue_blog" alt="LiberXue_blog" /> </a>
                    <div class="info-text">
                        <p>Theme is <a href="http://www.liberxue.com/2017/08/03/Jekyllthemes.html" title="访问 Jekyll liberxue主题"  data-hover="Jekyll liberxue"target="_blank">Jekyll liberxue</a> by <a href="http://www.liberxue.com/about" target="_blank">liberxue</a></p>
                        <p>Powered by <a href="http://localhost:2333/tags/#Jekyll" title="Jekyll" data-hover="Jekyll" target="_blank" rel="nofollow">Jekyll</a></p>
                        <p>&copy; 2017 <a href="/feed.xml"  title="访问 liberxue blog RSS" data-hover="liberxue blog RSS">liberxue blog RSS</a></p>
                        <p>总计文章：篇</p>
                      <p>本blog已开源点击Fork</p><iframe src="http://ghbtns.com/github-btn.html?user=liberxue&repo=liberxue.github.io&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="95" height="20"></iframe>
                    </div>
                </div>
            </div>
            <div class="meta-item meta-posts">
                <h3 class="meta-title">置顶文章</h3>
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
            </div>
            <div class="meta-item meta-comments">
                <h3 class="meta-title">最新文章</h3>
  
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
</div>
		</div>
    </div>
</footer> -->
<script src="//cdn.bootcss.com/jquery/2.2.2/jquery.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap-3-typeahead/4.0.2/bootstrap3-typeahead.js"></script>
<script async src="/search/js/520.js"></script>
<script async src="/search/js/gtag.js"></script>
<script async src="/search/live2d/autoload.js"></script>
<!-- <script src="/search/js/canvas.js"></script> -->

<script>
    $(function () {
        setTimeout(function () {
            $('code').removeClass('hljs');
            $('code').removeClass('language');
        }, 90);
    });
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <!--liberxueconnnet-menu-->
    <div id="directory-content" class="directory-content">
        <div id="directory"></div>
    </div>
    <!--liberxueconnnet-menu-->
    <script>
      const directoryContainer = document.getElementById('directory')
      const postTitle = document.getElementsByClassName('post-title')[0]
      var postDirectoryBuild = function () {
        var postChildren = function children(childNodes, reg) {
          var result = [],
              isReg = typeof reg === 'object',
              isStr = typeof reg === 'string',
              node, i, len;
          for (i = 0, len = childNodes.length; i < len; i++) {
            node = childNodes[i];
            if ((node.nodeType === 1 || node.nodeType === 9) &&
              (!reg ||
                  isReg && reg.test(node.tagName.toLowerCase()) ||
                  isStr && node.tagName.toLowerCase() === reg)) {
                result.push(node);
              }
            }
            return result;
          },
          createPostDirectory = function (article, directory, isDirNum) {
            var contentArr = [],
                titleId = [],
                levelArr, root, level,
                currentList, list, li, link, i, len;
            levelArr = (function (article, contentArr, titleId) {
                  var titleElem = postChildren(article.childNodes, /^h\d$/),
                      levelArr = [],
                      lastNum = 1,
                      lastRevNum = 1,
                      count = 0,
                      guid = 1,
                      id = 'directory' + (Math.random() + '').replace(/\D/, ''),
                      lastRevNum, num, elem;
                  while (titleElem.length) {
                      elem = titleElem.shift();
                      contentArr.push(elem.innerHTML);
                      num = +elem.tagName.match(/\d/)[0];
                      if (num > lastNum) {
                          levelArr.push(1);
                          lastRevNum += 1;
                      } else if (num === lastRevNum ||
                          num > lastRevNum && num <= lastNum) {
                          levelArr.push(0);
                          lastRevNum = lastRevNum;
                      } else if (num < lastRevNum) {
                          levelArr.push(num - lastRevNum);
                          lastRevNum = num;
                      }
                      count += levelArr[levelArr.length - 1];
                      lastNum = num;
                      elem.id = elem.id || (id + guid++);
                      titleId.push(elem.id);
                  }
                  if (count !== 0 && levelArr[0] === 1) levelArr[0] = 0;

                  return levelArr;
              })(article, contentArr, titleId);
              currentList = root = document.createElement('ul');
              dirNum = [0];
              for (i = 0, len = levelArr.length; i < len; i++) {
                  level = levelArr[i];
                  if (level === 1) {
                      list = document.createElement('ul');
                      if (!currentList.lastElementChild) {
                          currentList.appendChild(document.createElement('li'));
                      }
                      currentList.lastElementChild.appendChild(list);
                      currentList = list;
                      dirNum.push(0);
                  } else if (level < 0) {
                      level *= 2;
                      while (level++) {
                          if (level % 2) dirNum.pop();
                          currentList = currentList.parentNode;
                      }
                  }
                  dirNum[dirNum.length - 1]++;
                  li = document.createElement('li');
                  link = document.createElement('a');
                  link.name = '#' + titleId[i];
                  link.href = 'Javascript:;'
                  link.className = "post-aside-anchor"
                  link.title = '访问' + titleId[i];
                  link.innerHTML = !isDirNum ? contentArr[i] :
                      dirNum.join('.') + ' ' + contentArr[i];
                  li.appendChild(link);
                  currentList.appendChild(li);
              }
            directory.appendChild(root);
          };
        createPostDirectory(document.getElementById('post-content'), directoryContainer, true);
      };
      postDirectoryBuild();
    </script>
    <script>
      // gtag('config', GA_TRACKING_ID, {
      //   'page_title' : 'Blog',
      //   'page_path': window.location.pathname,
      //   'post_title': 'watttsdfasdf',
      // });

    </script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        lang = hljs.initHighlightingOnLoad();
    </script>
</body>

</html>
