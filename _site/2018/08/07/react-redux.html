
<!DOCTYPE>
<html lang="zh-cn" data-scribe-reduced-action-queue="true">

<head>
    <meta content='Redux & Redux-Saga - Tate & Snow' name='title' />
    <meta content='Redux & Redux-Saga - Tate & Snow' name='og:title' />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <title>Redux & Redux-Saga - Tate & Snow</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Redux & Redux-Saga - Tate & Snow</title>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redux & Redux-Saga - Tate & Snow">
<meta name="twitter:keywords" content="Redux & Redux-Saga - Tate & Snow" property='og:description' />
<meta property="og:type" content="article">
<meta property="og:title" content="Redux & Redux-Saga - Tate & Snow">
<meta name="og:keywords" content="Redux & Redux-Saga - Tate & Snow|Redux &amp; Redux-SagaRedux &amp; FluxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。和 Flux 一样，Redux 规定，将模型的更新逻辑全部集中于一个特定的层(Flux..."
  property='og:description' />
<link rel="icon" type="image/png" href="http://localhost:4000/style/favicons/favicon.ico" />
<link href="http://localhost:4000/style/favicons/favicon.ico" rel="shortcut icon" type="image/png">
<link rel="canonical" href="http://localhost:4000/">
<link rel="alternate" type="application/rss+xml" title="Liberxue" href="http://localhost:4000/feed.xml">
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="http://localhost:4000/style/favicons/favicon.ico" type="image/x-icon">
<meta name="keywords" content="Redux &amp; Redux-SagaRedux &amp; FluxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。和 Flux 一样，Redux 规定，将模型的更新逻辑全部集中于一个特定的层(Flux..." property='og:description'
/>
<meta name="description" content="Tate & Snow's Github blog" />
<link href="https://cdn.bootcss.com/highlight.js/9.10.0/styles/xcode.min.css" rel="stylesheet">
<link href="http://localhost:4000/style/theme.css" rel="stylesheet"> 
<meta content='http://localhost:4000/2018/08/07/react-redux.html' property='og:url' />
<meta content="http://localhost:4000/2018/08/07/react-redux.html|Redux &amp; Redux-SagaRedux &amp; FluxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。和 Flux 一样，Redux 规定，将模型的更新逻辑全部集中于一个特定的层(Flux..." property='og:description'
/>
<meta content="article" property="og:type" />  
<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-101222464-1', 'auto');
  ga('send', 'pageview');
</script>
 

</head>

<body class="" gtools_scp_screen_capture_injected="true">
    <header id="header" class="header bg-white">
        <div class="navbar-container">
            <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">
                <img src="https://i.loli.net/2018/03/13/5aa74f5b4c2c7.png" alt="Tate & Snow"> </a>
            <!-- <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">Tate & Snow</a>   -->
            <div class="navbar-menu">
                
                <a href="/?tate" title="访问 首页" data-hover="首页">首页</a>
                
                <a href="/front?tate" title="访问 前端" data-hover="前端">前端</a>
                
                <a href="/tool?tate" title="访问 框架" data-hover="框架">框架</a>
                
                <a href="/back?tate" title="访问 后端" data-hover="后端">后端</a>
                
                <a href="/tags?tate" title="访问 标签" data-hover="标签">标签</a>
                
                <a href="/README?tate" title="访问 关于" data-hover="关于">关于</a>
                
            </div>
            <!-- <div class="navbar-menu">
                
                <a href="http://localhost:4000/">首页</a>
                
                <a href="http://localhost:4000/front">前端</a>
                
                <a href="http://localhost:4000/tool">框架</a>
                
                <a href="http://localhost:4000/back">后端</a>
                
                <a href="http://localhost:4000/tags">标签</a>
                
                <a href="http://localhost:4000/README">关于</a>
                
            </div> -->
            <div class="navbar-search" onclick="">
                <span class="icon-search"></span>
                <form id="cb-search-btn" role="search">
                    <span class="search-box">
                        <input type="text" class="input" id="cb-search-content" required="true" placeholder="标题 标签..." maxlength="30" autocomplete="off">
                    </span>
                </form>
            </div>
            <div class="navbar-mobile-menu" onclick="">
                <span class="icon-menu cross">
                    <span class="middle"></span>
                </span>
                <ul>
                    
                    <li>
                        <a href="http://localhost:4000/">首页</a>
                    </li>
                    
                    <li>
                        <a href="http://localhost:4000/front">前端</a>
                    </li>
                    
                    <li>
                        <a href="http://localhost:4000/tool">框架</a>
                    </li>
                    
                    <li>
                        <a href="http://localhost:4000/back">后端</a>
                    </li>
                    
                    <li>
                        <a href="http://localhost:4000/tags">标签</a>
                    </li>
                    
                    <li>
                        <a href="http://localhost:4000/README">关于</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </header>
    <a href="#header" class="back-to-top">⤴Top⤴</a>
    <div class="post-header-thumb bg-white}">
        <div class="post-header-thumb-op"></div>
        <div class="post-header-thumb">
            <div class="post-header-thumb-container">
                <h1 class="post-title" itemprop="name headline">
                    Redux & Redux-Saga</h1>
                <div class="post-data">
                    <time datetime="2018-08-07 18:15:00" itemprop="datePublished">发布时间：2018-08-07 18:15:00</time>
                    <a href="/tags#前端" title="访问 前端" data-hover="博客分类: 前端">博客分类: 前端</a>
                    <!-- <a href="#read"> 阅读次数: comments</a>  -->
                </div>
                <div class="post-tags">
                       
                    <a href="/tags#React" title="访问React" data-hover="React">
                        React
                        <span>(2)</span>
                        
                    </a>
                    
                    <a href="/tags#Redux" title="访问Redux" data-hover="Redux">
                        Redux
                        <span>(1)</span>
                        
                    </a>
                       
                </div>
            </div>
        </div>
    </div>
    <article class="main-content post-page" itemscope itemtype="http://schema.org/Article">
        <div class="post-header">
            <h1 class="post-title" itemprop="name headline">
                Redux & Redux-Saga</h1>
            <div class="post-data">
                <time datetime="2018-08-07 18:15:00" itemprop="datePublished">2018-08-07 18:15:00</time>
            </div>
        </div>
        <div id="post-content" class="post-content" itemprop="articleBody">
            <p class="post-tags">
                   
                <a href="/tags#React" title="访问React" data-hover="React">
                    React
                    <span>(2)</span>
                    </a>
                
                <a href="/tags#Redux" title="访问Redux" data-hover="Redux">
                    Redux
                    <span>(1)</span>
                    </a>
                   
            </p>
            <h1 id="redux--redux-saga">Redux &amp; Redux-Saga</h1>

<h2 id="redux--flux">Redux &amp; Flux</h2>

<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。和 Flux 一样，Redux 规定，将模型的更新逻辑全部集中于一个特定的层(Flux 里的 <strong>store</strong>，Redux 里的 <strong>reducer</strong>)。两者都不允许程序直接修改数据，而是用一个叫作 “<strong>action</strong>” 的普通对象来对更改进行描述。而不同于 Flux ，Redux 并没有 <strong>dispatcher</strong> 的概念。原因是它依赖纯函数来替代事件处理器。纯函数构建简单，也不需额外的实体来管理它们。Flux 常常被表述为 <code>(state, action) =&gt; state</code>。从这个意义上说，Redux 无疑是 Flux 架构的实现，且得益于纯函数而更为简单。</p>

<blockquote>
  <p>Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。尽管如此，Redux 还是和 React 和 Deku 这类库搭配起来用最好，因为这类库允许你以 state 函数的形式来描述界面，Redux 通过 action 的形式来发起 state 变化。</p>
</blockquote>

<h2 id="概念">概念</h2>

<p><img src="https://i.loli.net/2018/08/08/5b6a46915b789.png" alt="redux-pattern-diagram.png" /></p>

<h3 id="action">Action</h3>

<p><strong>Action</strong> 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般通过 <code>store.dispatch()</code> 将 action 传到 store。一般约定 action 是一个拥有 <strong>type</strong> 属性的对象。然后按 type 决定如何处理 action。当然，action 依旧可以拥有其他属性，你可以任意存放想要的数据:</p>

<pre><code class="language-JS">// action 示例
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
</code></pre>

<p>action 可以通过 <strong>action creator</strong> 创建:</p>

<pre><code class="language-JS">// action creator 就是函数而已...
function addTodo (text) {
  return {
    type: 'ADD_TODO',
    text
  }
}
</code></pre>

<h3 id="reducer">Reducer</h3>

<p><strong>Reducers</strong> 函数是 action 的订阅者，指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 <strong>state</strong>。在 Redux 应用中，所有的 state 都被保存在一个单一对象中，一个 state 对应一个 view，如下:</p>

<pre><code class="language-JS">// state
{
  visibilityFilter: 'SHOW_ALL',
  todos: [
    {
      text: 'Consider using Redux',
      completed: true,
    },
    {
      text: 'Keep all state in a single tree',
      completed: false
    }
  ]
}
</code></pre>

<p>现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state : <code>(previousState, action) =&gt; newState</code>。需要谨记 reducer 是<a href="https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0">纯函数</a>，不要执行有副作用的操作，如 API 请求和路由跳转。</p>

<pre><code class="language-JS">export default (state = 0, action) =&gt; { // 首次执行时，state 为 undefined，需要定义初始值
  switch (action.type) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    default:
      return state // 默认返回传入的旧 state
  }
}
</code></pre>

<p><strong>切记不能修改 state</strong>，否则会报错。此时应当采用拷贝或者直接使用 immutable 库:</p>

<pre><code class="language-JSX">// 不能修改 state
function reducer (state, action) {
  return Object.assign({}, state, { thingToChange });
  // 或者
  return { ...state, ...newState };
  // 或者 immutable
  return state.set('thingToChange', action.counter)
}
</code></pre>

<p>一个 reducer 可以处理很多的 action，但维护将变得艰难。多个 reducer 的合并可以使用 <strong>combineReducers()</strong>:</p>

<pre><code class="language-JS">// 在这种多个 reducer 的模式下，我们可以让每个 reducer 只处理整个应用的部分 state 。
var userReducer = function (state = {}, action) {
  console.log('userReducer was called with state', state, 'and action', action)

  switch (action.type) {
    case 'SET_NAME':
      return {
        ...state,
        name: action.name
      }
    // etc.
    default:
      return state;
  }
}
var itemsReducer = function (state = [], action) {
  console.log('itemsReducer was called with state', state, 'and action', action)

  switch (action.type) {
    case 'ADD_ITEM':
      return [
        ...state,
        action.item
      ]
    // etc.
    default:
      return state;
  }
}
</code></pre>

<pre><code class="language-JS">import { createStore, combineReducers } from 'redux'

var reducer = combineReducers({
    user: userReducer,
    items: itemsReducer
})
var store_0 = createStore(reducer)

// 创建并发送一个 action
var setNameActionCreator = function (name) {
  return {
    type: 'SET_NAME',
    name: name
  }
}

store_0.dispatch(setNameActionCreator('bob'))
// 输出：
// userReducer was called with state {} and action { type: 'SET_NAME', name: 'bob' }
// itemsReducer was called with state [] and action { type: 'SET_NAME', name: 'bob' }
console.log('store_0 state after action SET_NAME:', store_0.getState())
// 输出：
// store_0 state after action SET_NAME: { user: { name: 'bob' }, items: [] }
</code></pre>

<h3 id="store">Store</h3>

<p>store 由 <code class="highlighter-rouge">createStore(reducer， defaultState)</code> 这个方法生成，在整个应用中是唯一的，功能如下:</p>

<ul>
  <li>维持应用的 state；</li>
  <li>提供 getState() 方法获取 state；</li>
  <li>提供 dispatch(action) 方法更新 state；</li>
  <li>通过 subscribe(listener) 注册监听器，一旦 state 发生变化，就自动执行这个函数;</li>
  <li>通过 subscribe(listener) 返回的函数注销监听器</li>
</ul>

<p><img src="https://i.loli.net/2019/03/11/5c85ca3492c67.png" alt="react-redux-store.png" /></p>

<pre><code class="language-JS">// 整个流程可总结为: 用户发出 Action，Reducer 函数算出新的 State，View 重新渲染
import React from 'react'
import ReactDOM from 'react-dom'
import { createStore } from 'redux'
import Counter from './components/Counter'
import counter from './reducers'

const store = createStore(counter) // counter 属于 reducer
const rootEl = document.getElementById('root')

const render = () =&gt; ReactDOM.render(
  &lt;Counter
    value={store.getState()}
    onIncrement={() =&gt; store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() =&gt; store.dispatch({ type: 'DECREMENT' })}
  /&gt;,
  rootEl
)

render()
store.subscribe(render) // 监听并修改视图
</code></pre>

<p>当需要把多个 store 增强器依次执行的时候，可以使用 <a href="https://www.kancloud.cn/allanyu/redux-in-chinese/82435"><strong>compose</strong></a> 方法，从右到左把接收到的函数合成后的最终函数。compose 做的只是让你不使用深度右括号的情况下来写深度嵌套的函数:</p>

<pre><code class="language-JS">const store = compose()(createStore)(counter)
</code></pre>

<p>对上述 action、reducer 和 store 三者关系的一个整理:</p>

<p><img src="https://i.loli.net/2019/03/11/5c85ca3485b3a.png" alt="react-redux-action.png" /></p>

<h3 id="异步-action--中间件">异步 Action &amp; 中间件</h3>

<h4 id="applymiddlewares">applyMiddlewares()</h4>

<p><strong>applyMiddlewares</strong> 方法将所有中间件组成一个数组，依次执行。比如执行日志中间件:</p>

<pre><code class="language-JS">import { applyMiddleware, createStore } from 'redux';
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  applyMiddleware(logger)
);
</code></pre>

<h4 id="异步-redux-thunk">异步 Redux-Thunk</h4>

<p>同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p>

<ul>
  <li>一种通知 reducer 请求开始的 Action</li>
  <li>一种通知 reducer 请求成功的 Action</li>
  <li>一种通知 reducer 请求失败的 Action</li>
</ul>

<p>Action 的设置无非两种情况:</p>

<pre><code class="language-JS">// 同一种 type，但不同 status
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 或者不同 type
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
</code></pre>

<p>异步操作的 state 也要进行改造，反映不同的操作状态:</p>

<pre><code class="language-JS">let state = {
  // ...
  isFetching: true, // 表示是否在抓取数据
  didInvalidate: true, // 表示数据是否过时
  lastUpdated: 'xxxxxxx' // 表示上一次更新时间
};
</code></pre>

<p>整个流程思路即:</p>

<p>1、操作开始时，送出一个 action，触发 state 更新为”正在操作”状态，view 重新渲染
2、操作结束后，再送出一个 action，触发 state 更新为”操作结束”状态，view 再一次重新渲染</p>

<p>接下来通过中间件 <strong>redux-thunk</strong> 进行异步 action 的创建，具体可查看下节异步示例:</p>

<pre><code class="language-JS">// 虽然内部操作不同，你可以像其它 action 创建函数 一样使用它：store.dispatch(fetchPosts('reactjs'))
// store.dispatch 方法正常情况下，参数只能是对象，不能是函数，就要使用中间件 redux-thunk
export function fetchPosts(subreddit) {

  // Thunk middleware 知道如何处理函数。
  // 这里把 dispatch 方法通过参数的形式传给函数，以此来让它自己也能 dispatch action。

  return function (dispatch) {

    // 首次 dispatch：更新应用的 state 来通知 API 请求发起了。

    dispatch(requestPosts(subreddit))

    // thunk middleware 调用的函数可以有返回值，它会被当作 dispatch 方法的返回值传递。
    // 这个案例中，我们返回一个等待处理的 promise。这并不是 redux middleware 所必须的，但这对于我们而言很方便。

    return fetch(`http://www.subreddit.com/r/${subreddit}.json`)
      .then(
        response =&gt; response.json(),
        // 不要使用 catch，因为会捕获在 dispatch 和渲染中出现的任何错误，导致 'Unexpected batch number' 错误。
         error =&gt; console.log('An error occurred.', error)
      )
      .then(json =&gt;
        // 可以多次 dispatch！这里，使用 API 请求结果来更新应用的 state。

        dispatch(receivePosts(subreddit, json))
      )
  }
}
</code></pre>

<blockquote>
  <p>异步建议使用 <strong>redux-saga</strong> 来处理数据的读取。不同于 redux-thunk，你不会再遇到回调地狱了，你可以很容易地测试异步流程并保持你的 action 是干净的。</p>
</blockquote>

<h2 id="react-redux">React-Redux</h2>

<p>我们当然可以直接在 React 中使用 Redux：在最外层容器组件中初始化 store，然后将 state 上的属性作为 props 层层传递下去，最佳的方式是使用 <strong>React-Redux</strong> 提供的 <strong>Provider</strong> 和 <strong>connect</strong> 方法。React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p>

<p><img src="https://i.loli.net/2019/03/06/5c7f46749d223.png" alt="react-redux.png" /></p>

<h3 id="provider">Provider</h3>

<p>connect 方法生成容器组件以后，需要让容器组件拿到 state 对象，才能生成 UI 组件的参数。最关键的作用就是在 context 中放入 Redux 的 store，方便子组件获取:</p>

<pre><code class="language-JSX">import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  // 使用的时候容器组件会被包裹在 Provider 组件下面，这样这些组件就可以获得 Provider 挂在 context 上的 state 了
  // Provider 内的任何一个组件（比如这里的 App），如果需要使用 state 中的数据，就必须是「被 connect 过的」组件——使用 connect 方法对「你编写的组件（MyApp）」进行包装后的产物
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>

<p><strong>context</strong> 属于 React 的一个重要属性。被隐式地传递给后代组件(类似于全局变量的作用，所有组件都可以访问):</p>

<ul>
  <li>React.withContext ：会执行一个指定的上下文信息的回调函数，任何在这个回调函数里面渲染的组件都有这个 context 的访问权限。</li>
  <li>getChildContext ：和 React.withContext 一样的作用，指定的传递给子组件的属性。不过与 React.withContext 写法不同，且要先通过 childContextTypes 来指定类型，不然会产生错误。</li>
  <li>childContextTypes ：声明传递给子组件的属性的数据类型。</li>
  <li>contextTypes ：任何想访问 context 里面的属性的组件都必须显式地指定一个 contextTypes 的属性。如果没有指定该属性，那么组件通过 this.context 访问属性将会出错。</li>
</ul>

<p>Provider 就是使用了 getChildContext 将 store 绑到 context 上使子元素都可以访问到。通过 context 传递属性的方式要优于通过 props 逐层传递属性的方式。这样可以减少组件之间的直接依赖关系。</p>

<h3 id="connect">connect</h3>

<p><strong>connect</strong> 负责与 React 的展示组件进行交互，更新。容器组件在使用的时候会被包裹在 Provider 组件下面，这样这些组件就可以获得 Provider 挂在 context 上的 state。connect 作为高阶函数包裹这些容器组件就可以接收到 state，并且可以:</p>

<p>1、将指定 state 和 action 作为 props 绑定到组件上方便调用</p>

<p>2、帮助组件订阅监听 state 的变化</p>

<pre><code class="language-JSX">import { connect } from 'react-redux'

class MyComp extends Component {
  // ...
}
const Comp = connect(...args)(MyComp);
</code></pre>

<pre><code class="language-JSX">// 可以接收四个参数，后两个参数一般省略，不做分析
connect([mapStateToProps], [mapDispatchToProps], [mergeProps],[options])
</code></pre>

<h4 id="mapstatetoprops">mapStateToProps()</h4>

<p><strong>mapStateToProps</strong> 将 store 中的数据作为 props 绑定到组件上。接收的第一个参数是我们需要从 Redux 中提取的状态，第二个可选参数是组件本身的 props。不必将 Redux 中所有的 state 数据都传进组件，可以结合 ownProps 进行筛选，传入需要的最少属性。</p>

<pre><code class="language-JSX">const mapStateToProps = (state, ownProps) =&gt; {
  // state 是 {userList: [{id: 0, name: '王二'}]}
  return {
    user: _.find(state.userList, {id: ownProps.userId})
  }
}

class MyComp extends Component {
  static PropTypes = {
    userId: PropTypes.string.isRequired,
    user: PropTypes.object
  };
  
  render(){
    return &lt;div&gt;用户名：{this.props.user.name}&lt;/div&gt;
  }
}

const Comp = connect(mapStateToProps)(MyComp);
</code></pre>

<p>当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps。</p>

<h4 id="mapdispatchtoprops">mapDispatchToProps()</h4>

<p><strong>mapDispatchToProps</strong> 将 action 作为 props 绑定到组件上:</p>

<pre><code class="language-JSX">//将 state.counter 绑定到 props 的 count
const mapStateToProps = state =&gt; ({
  count: state.counter
});

const mapDispatchToProps = (dispatch, ownProps) =&gt; ({
  // 由于 mapDispatchToProps 方法返回了具有 increase 属性和 decrease 属性的对象，这两个属性也会成为 MyComp 的 props
  increase: (...args) =&gt; dispatch(actions.increase(...args)),
  decrease: (...args) =&gt; dispatch(actions.decrease(...args))
})

class MyComp extends Component {
  render(){
    // //从组件的 props 属性中导入两个方法和一个变量 count
    const {count, increase, decrease} = this.props;

    return (&lt;div&gt;
      &lt;div&gt;计数：{count}次&lt;/div&gt;
      &lt;button onClick={increase}&gt;增加&lt;/button&gt;
      &lt;button onClick={decrease}&gt;减少&lt;/button&gt;
    &lt;/div&gt;)
  }
}

const Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);
</code></pre>

<p>上面的 state 对象的 key 为 counter，取决于这里的设置:</p>

<pre><code class="language-JSX">import counter from './crement'
import { combineReducers } from 'redux';
export default combineReducers({
  counter, // 通过 state.counter 访问
})
</code></pre>

<h2 id="redux-saga">Redux-Saga</h2>

<p><strong>redux-saga</strong> 是一个用于管理应用程序 <strong>Side Effect</strong>(副作用，例如异步获取数据，访问浏览器缓存等)的库，它的目标是让副作用管理更容易，执行更高效，测试更简单，在处理故障时更容易。redux-saga 使用了 ES6 的 <strong>Generator</strong> 功能，让异步的流程更易于读取，写入和测试。可以想像为，一个 saga 就像是应用程序中一个单独的线程，它独自负责处理副作用。 redux-saga 是一个 redux 中间件，意味着这个线程可以通过正常的 redux action 从主应用程序启动，暂停和取消，它能访问完整的 redux state，也可以 dispatch redux action。</p>

<h3 id="createsagamiddleware">createSagaMiddleware()</h3>

<pre><code class="language-JS">// 创建一个 saga 中间件并连接至 Redux Store
import { createStore, applyMiddleware } from 'redux'
import createSagaMiddleware from 'redux-saga'
import { helloSaga } from './sagas'

const sagaMiddleware = createSagaMiddleware()
const store = createStore(
  reducer,
  applyMiddleware(sagaMiddleware)
)

// 启动 Generators，参数必须是 Generator function
sagaMiddleware.run(helloSaga)
</code></pre>

<h3 id="saga-辅助函数">Saga 辅助函数</h3>

<p>redux-saga 提供了一些辅助函数，包装了一些内部方法，用来在一些特定的 action 被发起到 Store 时派生任务，常用的两个辅助函数为:</p>

<ul>
  <li><strong>takeEvery</strong> - 是一个使用 take 和 fork 构建的高级 API。每次指定 action 被发起时，来启动一个新的 saga 任务</li>
  <li><strong>takeLatest</strong> - 同上，但会自动取消之前所有已经启动但仍在执行中的 saga 任务。</li>
</ul>

<pre><code class="language-JS">import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'
import Api from '...'

// 创建异步任务，将在 USER_FETCH_REQUESTED action 被 dispatch 时调用
function* fetchUser(action) {
  try {
    const user = yield call(Api.fetchUser, action.payload.userId); // call 属于声明式调用，创建一个纯文本对象描述函数调用
    yield put({type: "USER_FETCH_SUCCEEDED", user: user}); // put 用于创建 dispatch Effect
  } catch (e) {
    yield put({type: "USER_FETCH_FAILED", message: e.message});
  }
}

function* watchFetchData() {
  yield* takeEvery("FETCH_REQUESTED", fetchData)
}

// 上面 generator 函数等价于
function* watchFetchData() {
  while (true) {
    yield take('FETCH_REQUESTED');
    yield fork(fetchData);
  }
}

function* mySaga() {
  yield takeLatest("USER_FETCH_REQUESTED", fetchUser);
}
</code></pre>

<h3 id="effect-创建器">Effect 创建器</h3>

<p>redux-saga 库提供了很多创建 effect 的函数，常用的有以下这些，更多<a href="https://redux-saga-in-chinese.js.org/docs/api/">参考这里</a>:</p>

<ul>
  <li><strong>put</strong>(action)</li>
  <li><strong>call</strong>(fn, …args)</li>
  <li><strong>fork</strong>(fn, …args)</li>
  <li><strong>cancel</strong>(…tasks)</li>
  <li><strong>take</strong>(pattern) - 监听未来的 action</li>
  <li><strong>select</strong>(selector, …args)</li>
</ul>

<p>1、<strong>put</strong></p>

<p>创建一个 Effect 描述信息，用来命令 middleware 向 Store 发起一个 action。 这个 effect 是非阻塞型的，并且所有向下游抛出的错误（例如在 reducer 中），都不会冒泡回到 saga 当中:</p>

<pre><code class="language-JS">yield put({type: "USER_FETCH_SUCCEEDED", user: user});
</code></pre>

<p>2、<strong>call</strong></p>

<p>创建一个 Effect 描述信息，用来命令 middleware 以参数 args 调用函数 fn，fn 即可以是一个 普通 函数，也可以是一个 Generator 函数。call 函数也是<strong>阻塞</strong> effect:</p>

<pre><code class="language-JS">const user = yield call(Api.fetchUser, action.payload.userId);
</code></pre>

<p>类似于 <code>Promise.all</code> 同时执行多个任务:</p>

<pre><code class="language-JS">import { call } from 'redux-saga/effects'

// effects 将会同步执行。generator 会被阻塞直到所有的 effects 都执行完毕，或者当一个 effect 被拒绝
const [users, repos] = yield [
  call(fetch, '/users'),
  call(fetch, '/repos')
]
</code></pre>

<p>3、<strong>fork</strong></p>

<p>fork 类似于 call，可以用来调用普通函数和 Generator 函数。不过，fork 的调用是<strong>非阻塞</strong>的，Generator 不会在等待 fn 返回结果的时候被 middleware 暂停；相反，它在 fn 被调用时便会立即恢复执行:</p>

<pre><code class="language-JS">export default function* rootSaga() {
  // 下面的四个 Generator 函数会一次执行，不会阻塞执行
  yield fork(addItemFlow)
  yield fork(removeItemFlow)
  yield fork(toggleItemFlow)
  yield fork(modifyItemFLOW)
}
</code></pre>

<p>4、<strong>cancel</strong></p>

<p>创建一个 Effect 描述信息，一旦任务被 fork，可以用来中止任务执行:</p>

<pre><code class="language-JS">function* main() {
  while ( yield take(START_BACKGROUND_SYNC) ) {
    // 启动后台任务
    const bgSyncTask = yield fork(bgSync)

    // 等待用户的停止操作
    yield take(STOP_BACKGROUND_SYNC)
    // 用户点击了停止，取消后台任务，这会导致被 fork 的 bgSync 任务跳进它的 finally 区块
    yield cancel(bgSyncTask)
  }
}
</code></pre>

<p>在上面的示例中，取消 bgSyncTask 将会导致 Generator 跳进 finally 区块。可使用 <code>yield cancelled()</code> 来检查 Generator 是否已经被取消:</p>

<pre><code class="language-JS">function* saga() {
  try {
    // ...
  } finally {
    if (yield cancelled()) {
      // 只应在取消时执行的逻辑
    }
    // 应在所有情况下都执行的逻辑（例如关闭一个 channel）
  }
}
</code></pre>

<p>5、<strong>take</strong></p>

<p>它创建了一个命令对象，告诉 middleware 等待一个特定的 action， Generator 会暂停，直到一个与 pattern 匹配的 action 被发起，才会继续执行下面的语句，也就是说，take 是一个阻塞的 effect。</p>

<pre><code class="language-JS">function* loginFlow() {
  while (true) {
    yield take('LOGIN')
    // ... perform the login logic
    yield take('LOGOUT')
    // ... perform the logout logic
  }
}
</code></pre>

<p>6、<strong>select</strong></p>

<p>创建一个 Effect，用来命令 middleware 在当前 Store 的 state 上调用指定的选择器，如果调用 select 的参数为空(即 yield select())，那么 effect 会取得完整的 state(与调用 <code>store.getState()</code> 的结果相同):</p>

<pre><code class="language-JS">export function* toggleItemFlow() {
  // 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list
  let tempList = yield select(state =&gt; state.getTodoList.list)
}
</code></pre>

<h3 id="effect-组合器">Effect 组合器</h3>

<p>Effect 组合器包含两种方法:</p>

<ul>
  <li><strong>race</strong> - 传入的是 effect 的数组，进行”竞赛”</li>
  <li><strong>all</strong> - 并行地运行多个 Effect，并等待它们全部完成</li>
</ul>

<p>1、<strong>race</strong></p>

<pre><code class="language-JS">import { take, call, race } from `redux-saga/effects`
import fetchUsers from './path/to/fetchUsers'

// 如果 call(fetchUsers) 先 resolve（或 reject），那么 response 将是 fetchUsers 的结果，并且 cancel 将是 undefined，反之同理
function* fetchUsersSaga {
  const [response, cancel] = yield race([
    call(fetchUsers),
    take(CANCEL_FETCH)
  ])
}
</code></pre>

<p>2、<strong>all</strong></p>

<p>举个多个 Generator 的栗子，此时可以采用 all 组合器方法一起启动:</p>

<pre><code class="language-JS">import { delay } from 'redux-saga'
import { put, takeEvery, all } from 'redux-saga/effects'

function* incrementAsync() {
  yield delay(1000) // 延迟 1s
  yield put({ type: 'INCREMENT' }) // 触发 action
}

function* watchIncrementAsync() { // 在每个 INCREMENT_ASYNC action spawn 一个新的 incrementAsync 任务
  yield takeEvery('INCREMENT_ASYNC', incrementAsync)
}

// notice how we now only export the rootSaga single entry point to start all Sagas at once
export default function* rootSaga() {
  yield all([
    helloSaga(),
    watchIncrementAsync()
  ])
}
</code></pre>

<h2 id="reduxsauce">reduxsauce</h2>

<p><a href="https://github.com/infinitered/reduxsauce"><strong>reduxsauce</strong></a> 就是一个 “调味剂”，虽然不是必需品。但有它可以让代码更 “美味”。大家已经看到上面的 reducer 常规写法就是包含篇幅巨大的 switch 语法，看起来比较混乱。先看看它提供的几个 API:</p>

<ul>
  <li><strong>createReducer</strong> - 让 reducers 更易于阅读和测试</li>
  <li><strong>createTypes</strong> - 从字符串中定义你的类型对象</li>
  <li><strong>createActions</strong> - 同时创建 Action Types 和 Action Creators</li>
  <li><strong>resettableReducer</strong> - 允许重置 reducers</li>
</ul>

<p>1、初始化:</p>

<pre><code class="language-JSX">const INITIAL_STATE = { name: null, age: null }

// 如果使用 immutable
import { fromJS } from 'immutable'
const INITIAL_STATE = fromJS({ name: null, age: null })
</code></pre>

<p>2、运行</p>

<pre><code class="language-JSX">const sayHello = (state = INITIAL_STATE, action) =&gt; {
  const { age, name } = action
  return { ...state, age, name }
}
</code></pre>

<p>3、触发</p>

<p>在 redux 中，reducers 会被 action 触发，通过 <code>action.type</code> 上的 switch 所驱动。现在只需要一个简单的对象，将所有 actions 映射到 reducer 函数上:</p>

<pre><code class="language-JSX">import Types from './actionTypes'
import { Types as ReduxSauceTypes } from 'reduxsauce'

const HANDLERS = {
  [Types.SAY_HELLO]: sayHello,
  [Types.SAY_GOODBYE]: sayGoodbye,
  [ReduxSauceTypes.DEFAULT]: defaultHandler, // default handler
}
</code></pre>

<p>4、注入</p>

<pre><code class="language-JSX">// Injecting Into The Global State Tree
export default createReducer(INITIAL_STATE, HANDLERS)
</code></pre>

<p>完整的示例如下:</p>

<pre><code class="language-JSX">// sampleReducer.js
import { createReducer, Types as ReduxSauceTypes } from 'reduxsauce'
import Types from './actionTypes'

// the initial state of this reducer
export const INITIAL_STATE = { error: false, goodies: null }

// the eagle has landed
export const success = (state = INITIAL_STATE, action) =&gt; {
  return { ...state, error: false, goodies: action.goodies }
}

// uh oh
export const failure = (state = INITIAL_STATE, action) =&gt; {
  return { ...state, error: true, goodies: null }
}

// map our action types to our reducer functions
export const HANDLERS = {
  [Types.GOODS_SUCCESS]: success,
  [Types.GOODS_FAILURE]: failure,
  [ReduxSauceTypes.DEFAULT]: (state = INITIAL_STATE) =&gt; state,
}

export default createReducer(INITIAL_STATE, HANDLERS)
</code></pre>

<h2 id="redux-logger">redux-logger</h2>

<p><a href="https://github.com/evgenyrodionov/redux-logger"><strong>redux-logger</strong></a> 可以用来打印日志，可配置的属性有:</p>

<pre><code class="language-JS">{
  predicate, // if specified this function will be called before each action is processed with this middleware.
  collapsed, // takes a Boolean or optionally a Function that receives `getState` function for accessing current store state and `action` object as parameters. Returns `true` if the log group should be collapsed, `false` otherwise.
  duration = false: Boolean, // print the duration of each action?
  timestamp = true: Boolean, // print the timestamp with each action?

  level = 'log': 'log' | 'console' | 'warn' | 'error' | 'info', // console's level
  colors: ColorsObject, // colors for title, prev state, action and next state: https://github.com/evgenyrodionov/redux-logger/blob/master/src/defaults.js#L12-L18
  titleFormatter, // Format the title used when logging actions.

  stateTransformer, // Transform state before print. Eg. convert Immutable object to plain JSON.
  actionTransformer, // Transform action before print. Eg. convert Immutable object to plain JSON.
  errorTransformer, // Transform error before print. Eg. convert Immutable object to plain JSON.

  logger = console: LoggerObject, // implementation of the `console` API.
  logErrors = true: Boolean, // should the logger catch, log, and re-throw errors?

  diff = false: Boolean, // (alpha) show diff between states?
  diffPredicate // (alpha) filter function for showing states diff, similar to `predicate`
}
</code></pre>

<pre><code class="language-JSX">// store.js
import { compose, createStore, applyMiddleware } from 'redux'
import rootReducer from './reducers'

const middlewares = []

if (process.env.NODE_ENV === 'development') {
  const { createLogger } = require('redux-logger')
  middlewares.push(createLogger({
    stateTransformer: (state) =&gt; {
      if (state.toJS) return state.toJS()
      const entries = Object.entries(state)
      return entries.reduce((obj, entry) =&gt; {
        entry[1].toJS ? (obj[entry[0]] = entry[1].toJS()) : (obj[entry[0]] = entry[1]) // eslint-disable-line
        return obj
      }, {})
    },
  }))
}

const store = compose(
  applyMiddleware(...middlewares),
)(createStore)(rootReducer)

export default store
</code></pre>

<p><img src="https://camo.githubusercontent.com/73b5dc54ec615f18746e8472e02d130f79a3cf9f/687474703a2f2f692e696d6775722e636f6d2f43674175486c452e706e67" alt="redux-logger" /></p>

<h2 id="redux-devtools-extension">Redux DevTools Extension</h2>

<p><a href="https://github.com/zalmoxisus/redux-devtools-extension"><strong>Redux DevTools Extension</strong></a> 是用来调试 redux 应用的插件，可以监测到 state 的变化并提供可视化的功能，以谷歌为例<a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">安装插件</a>:</p>

<p><img src="https://user-images.githubusercontent.com/7957859/48663602-3aac4900-ea9b-11e8-921f-97059cbb599c.png" alt="Redux DevTools Extension" /></p>

<p>在项目中针对最基本的 store:</p>

<pre><code class="language-JSX">/* eslint-disable no-underscore-dangle */
const store = createStore(
  reducer, /* preloadedState, */
  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
)
/* eslint-enable */
</code></pre>

<p>如果有用到中间件的话，修改如下:</p>

<pre><code class="language-JSX"> import { createStore, applyMiddleware, compose } from 'redux'

+ const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose
+ const store = createStore(reducer, /* preloadedState, */ composeEnhancers(
- const store = createStore(reducer, /* preloadedState, */ compose(
    applyMiddleware(...middleware)
  ))
</code></pre>

<p>上述方法在项目中无需安装第三方库，当然也可以通过安装 <code class="highlighter-rouge">redux-devtools-extension</code> 来实现:</p>

<pre><code class="language-JSX">// yarn add -D redux-devtools-extension

import { createStore, applyMiddleware } from 'redux';
import { composeWithDevTools } from 'redux-devtools-extension'

const store = createStore(reducer, composeWithDevTools(
  applyMiddleware(...middleware),
  // other store enhancers if any
))
</code></pre>

<h2 id="示例">示例</h2>

<p>Redux 运行 Counter 示例，在实际的项目中，推荐使用 React 和更高效的 React-Redux 绑定，<a href="https://github.com/lipeishang/react-redux-connect-demo">参考 demo</a>:</p>

<iframe src="https://codesandbox.io/embed/github/reactjs/redux/tree/master/examples/counter" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<p>React-Redux 运行 TodoList 示例:</p>

<iframe src="https://codesandbox.io/embed/github/reactjs/redux/tree/master/examples/todos-with-undo" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<p>Redux-thunk 运行 异步请求 示例:</p>

<iframe src="https://codesandbox.io/embed/github/reactjs/redux/tree/master/examples/async" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<p>更多示例<a href="http://cn.redux.js.org/docs/introduction/Examples.html">请参考这里</a>。</p>

<h2 id="ducks-文件结构">Ducks 文件结构</h2>

<p>依照<a href="https://redux.js.org/faq/codestructure">官方组织代码的文章</a>，大致可分为三种文件结构:</p>

<ul>
  <li><strong>Rails 风格</strong></li>
  <li><strong>应用领域风格(Domain)</strong></li>
  <li><strong>鸭子(Ducks)</strong></li>
</ul>

<p>1、 <strong>Rails风格</strong></p>

<p>又可以称为”依照类型(by type)”的集中组织方式。用 actions、constants、reducers、containers、components 等目录区分，文档名可以依功能或应用命名区分，这大概是最常见的一种:</p>

<pre><code class="language-TEXT">actions/
    CommandActions.js
    UserActions.js
components/
    Header.js
    Sidebar.js
    Command.js
    User.js
    UserProfile.js
    UserAvatar.js
containers/
    App.js
    Command.js
    User.js
reducers/
    index.js
    command.js
    user.js
routes.js
index.js
rootReducer.js
</code></pre>

<p>2、<strong>应用领域风格(Domain)</strong></p>

<p>又可以称为”依照功能(by feature)”的集中组织方式。先以功能或应用领域不同的目录区分，目录里有各自的 reducer、action 等等文档，可以用文档命名再作类型区分:</p>

<pre><code class="language-TEXT">app/
    Header.js
    Sidebar.js
    App.js
    rootReducer.js
    routes.js
product/
    Product.js
    ProductContainer.js
    ProductActions.js
    ProductList.js
    ProductItem.js
    ProductImage.js
    productReducer.js
user/
    User.js
    UserContainer.js
    UserActions.js
    UserProfile.js
    UserAvatar.js
    userReducer.js
</code></pre>

<p>3、<strong>鸭子(Ducks)</strong></p>

<p>鸭子是一种模组化 Redux 的代码组识方法，它是把 reducers、constants、action types 与 actions 打包成模组来用。鸭子可以减少很多目录与文档结构:</p>

<pre><code class="language-TEXT">|_ containers
|_ constants
|_ reducers
|_ actions
</code></pre>

<p>改用鸭子后就会变成只有两个目录，也就是说把constants, reducers, actions都合并为模组就是:</p>

<pre><code class="language-TEXT">|_ containers
|_ modules
</code></pre>

<p>鸭子有一些优点，也有一些明显的缺点。它在小型应用中是很理想的作法，你不用为了要加一个功能，至少需要开三、四个代码文档。它仍然有自订的空间，<a href="https://hackernoon.com/my-journey-toward-a-maintainable-project-structure-for-react-redux-b05dfd999b5">详细请参考这篇文章</a>。</p>

<h2 id="参考链接">参考链接</h2>

<ol>
  <li><a href="http://cn.redux.js.org/">Redux 中文文档</a></li>
  <li><a href="https://github.com/react-guide/redux-tutorial-cn#redux-tutorial">react-guide/redux-tutorial-cn</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">Redux 入门教程</a> By 阮一峰</li>
  <li><a href="https://cisy.me/react-redux/">react-redux 详解</a> By Cisy</li>
  <li><a href="http://taobaofed.org/blog/2016/08/18/react-redux-connect/">React 实践心得：react-redux 之 connect 方法详解</a> By 叶斋</li>
  <li><a href="http://www.alloyteam.com/2016/03/10532/">探索 react-redux 的小秘密</a></li>
  <li><a href="https://redux-saga-in-chinese.js.org/">Redux-Saga 中文文档</a></li>
  <li><a href="https://www.jianshu.com/p/7cac18e8d870">redux-saga 框架使用详解及 Demo 教程</a> By 光强_上海</li>
  <li><a href="https://github.com/infinitered/reduxsauce">Github - reduxsauce</a></li>
  <li><a href="https://segmentfault.com/q/1010000008187210">关于 redux 项目结构问题</a> By eyesofkids</li>
  <li><a href="https://hackernoon.com/my-journey-toward-a-maintainable-project-structure-for-react-redux-b05dfd999b5">My journey toward a maintainable project structure for React/Redux</a> By Matteo Mazzarolo</li>
  <li><a href="https://segmentfault.com/a/1190000011473973">Redux 关系图解</a> By Yawenina</li>
  <li><a href="https://juejin.im/post/5b2e3b9451882574934c3c8d">对 React、Redux、React-Redux 详细剖析</a> By 段亦心</li>
</ol>
 
<div id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
      enable: true,
      clientID: '020f142489f80c92b097',
      clientSecret: '1fa083372b44031cf1b8249251515c4e3d54c69d',
      repo: 'tate-young.github.io',
      owner: 'Tate-Young',
      admin: ['Tate-Young'],
      id: location.pathname,      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
<!-- disqus -->
<!-- <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        this.page.url = 'https://tate-young.github.io/2018/08/07/react-redux.html';
        this.page.identifier = '/2018/08/07/react-redux';
        this.page.title = 'Redux & Redux-Saga';
    };

    (function () { // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document,
            s = d.createElement('script');

        s.src = '//tate.disqus.com/embed.js'; // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> -->


            <!-- <p class="post-info">
			本文由 <a href="/">liberxue</a> 创作，采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>本站文章除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间为:2018-08-07 18:15:00</p> -->
        </div>
    </article>

    <!-- <div class="related-post-lists">
	<div class="post-lists">
		<div class="post-lists-body">
					<div class="post-list-item">
				<div class="post-list-item-container">
					<div class="item-label">
						<div class="item-title"><a href="induction.html">归纳的随想</a></div>
						<div class="item-meta clearfix">
														<div class="item-meta-ico bg-ico-image" style="background: url('../usr/themes/pinghsu/images/bg-ico.png') no-repeat;background-size: 40px auto;"></div>
	                        							<div class="item-meta-cat"><a href="../category/thoughts/index.html">Thoughts</a></div>
						</div>
					</div>
				</div>
			</div>
				</div>
	</div>
</div> -->

    <!-- <footer class="footer bg-white">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
	 <a class="social segmentfault" target="blank" href="https://segmentfault.com/u/liberxue" title="访问 LiberXue_Twitter" data-hover="Segmentfault">Segmentfault</a>
    <a class="social github" target="blank" href="https://github.com/liberxue" title="访问 LiberXue_Twitter" data-hover="GitHub">GitHub</a>
    <a class="social twitter" target="blank" href="http://twitter.com/liberxue" title="访问 LiberXue_Twitter" data-hover="Twitter">Twitter</a>
     <a class="social stackoverflow" target="blank" href="https://stackoverflow.com/users/6902190/liberxue" title="访问 LiberXue_stackoverflow" data-hover="StackOverflow">StackOverflow</a>
          <a class="social oschina" target="blank" href="https://my.oschina.net/bolanzw" title="访问 LiberXue_Oschina" data-hover="Oschina">Oschina</a>
     <a class="social rss" target="blank" href="/feed.xml"title="访问 LiberXue_RSS" data-hover="RSS">RSS</a>
	</div>
		</div>
	</div>
	<div class="footer-meta">
        <div class="footer-container">
            <div class="meta-item meta-copyright">
                <div class="meta-copyright-info">
                    <a href="/" class="info-logo">
                         <img src="http://localhost:4000/style/images/logo-liberxue.png"   title="访问 LiberXue_blog" data-hover="LiberXue_blog" alt="LiberXue_blog" /> </a>
                    <div class="info-text">
                        <p>Theme is <a href="http://www.liberxue.com/2017/08/03/Jekyllthemes.html" title="访问 Jekyll liberxue主题"  data-hover="Jekyll liberxue"target="_blank">Jekyll liberxue</a> by <a href="http://www.liberxue.com/about" target="_blank">liberxue</a></p>
                        <p>Powered by <a href="http://localhost:4000/tags/#Jekyll" title="Jekyll" data-hover="Jekyll" target="_blank" rel="nofollow">Jekyll</a></p>
                        <p>&copy; 2017 <a href="/feed.xml"  title="访问 liberxue blog RSS" data-hover="liberxue blog RSS">liberxue blog RSS</a></p>
                        <p>总计文章：篇</p>
                      <p>本blog已开源点击Fork</p><iframe src="http://ghbtns.com/github-btn.html?user=liberxue&repo=liberxue.github.io&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="95" height="20"></iframe>
                    </div>
                </div>
            </div>
            <div class="meta-item meta-posts">
                <h3 class="meta-title">置顶文章</h3>
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
            </div>
            <div class="meta-item meta-comments">
                <h3 class="meta-title">最新文章</h3>
          
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
    
</div>
		</div>
    </div>
</footer> -->
<script src="//cdn.bootcss.com/jquery/2.2.2/jquery.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap-3-typeahead/4.0.2/bootstrap3-typeahead.js"></script>
<script src="/search/js/cb-search.js"></script>
<!-- <script src="/search/js/canvas.js"></script> -->

<script>
    $(function () {
        setTimeout(function () {
            $('code').removeClass('hljs');
            $('code').removeClass('language');
        }, 90);
    });
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
    <!--liberxueconnnet-menu-->
    <div id="directory-content" class="directory-content">
        <div id="directory"></div>
    </div>
    <!--liberxueconnnet-menu-->
    <script>
        var postDirectoryBuild = function () {
            var postChildren = function children(childNodes, reg) {
                    var result = [],
                        isReg = typeof reg === 'object',
                        isStr = typeof reg === 'string',
                        node, i, len;
                    for (i = 0, len = childNodes.length; i < len; i++) {
                        node = childNodes[i];
                        if ((node.nodeType === 1 || node.nodeType === 9) &&
                            (!reg ||
                                isReg && reg.test(node.tagName.toLowerCase()) ||
                                isStr && node.tagName.toLowerCase() === reg)) {
                            result.push(node);
                        }
                    }
                    return result;
                },
                createPostDirectory = function (article, directory, isDirNum) {
                    var contentArr = [],
                        titleId = [],
                        levelArr, root, level,
                        currentList, list, li, link, i, len;
                    levelArr = (function (article, contentArr, titleId) {
                        var titleElem = postChildren(article.childNodes, /^h\d$/),
                            levelArr = [],
                            lastNum = 1,
                            lastRevNum = 1,
                            count = 0,
                            guid = 1,
                            id = 'directory' + (Math.random() + '').replace(/\D/, ''),
                            lastRevNum, num, elem;
                        while (titleElem.length) {
                            elem = titleElem.shift();
                            contentArr.push(elem.innerHTML);
                            num = +elem.tagName.match(/\d/)[0];
                            if (num > lastNum) {
                                levelArr.push(1);
                                lastRevNum += 1;
                            } else if (num === lastRevNum ||
                                num > lastRevNum && num <= lastNum) {
                                levelArr.push(0);
                                lastRevNum = lastRevNum;
                            } else if (num < lastRevNum) {
                                levelArr.push(num - lastRevNum);
                                lastRevNum = num;
                            }
                            count += levelArr[levelArr.length - 1];
                            lastNum = num;
                            elem.id = elem.id || (id + guid++);
                            titleId.push(elem.id);
                        }
                        if (count !== 0 && levelArr[0] === 1) levelArr[0] = 0;

                        return levelArr;
                    })(article, contentArr, titleId);
                    currentList = root = document.createElement('ul');
                    dirNum = [0];
                    for (i = 0, len = levelArr.length; i < len; i++) {
                        level = levelArr[i];
                        if (level === 1) {
                            list = document.createElement('ul');
                            if (!currentList.lastElementChild) {
                                currentList.appendChild(document.createElement('li'));
                            }
                            currentList.lastElementChild.appendChild(list);
                            currentList = list;
                            dirNum.push(0);
                        } else if (level < 0) {
                            level *= 2;
                            while (level++) {
                                if (level % 2) dirNum.pop();
                                currentList = currentList.parentNode;
                            }
                        }
                        dirNum[dirNum.length - 1]++;
                        li = document.createElement('li');
                        link = document.createElement('a');
                        link.href = '#' + titleId[i];
                        link.title = '访问' + titleId[i];
                        link.title = '访问' + titleId[i];
                        link.innerHTML = !isDirNum ? contentArr[i] :
                            dirNum.join('.') + ' ' + contentArr[i];
                        li.appendChild(link);
                        currentList.appendChild(li);
                    }
                    directory.appendChild(root);
                };
            createPostDirectory(document.getElementById('post-content'), document.getElementById('directory'), true);
        };
        postDirectoryBuild();
    </script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        lang = hljs.initHighlightingOnLoad();
    </script>
</body>

</html>
