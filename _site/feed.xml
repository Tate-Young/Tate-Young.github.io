<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:2333/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:2333/" rel="alternate" type="text/html" /><updated>2020-02-13T15:09:32+08:00</updated><id>http://localhost:2333/feed.xml</id><title type="html">Tate &amp;amp; Snow</title><subtitle>Lovely Home</subtitle><entry><title type="html">JS 垃圾处理机制</title><link href="http://localhost:2333/2020/02/13/js-garbage-collection.html" rel="alternate" type="text/html" title="JS 垃圾处理机制" /><published>2020-02-13T15:09:00+08:00</published><updated>2020-02-13T15:09:00+08:00</updated><id>http://localhost:2333/2020/02/13/js-garbage-collection</id><content type="html" xml:base="http://localhost:2333/2020/02/13/js-garbage-collection.html">&lt;h1 id=&quot;js-垃圾处理机制&quot;&gt;JS 垃圾处理机制&lt;/h1&gt;

&lt;h2 id=&quot;js-垃圾回收&quot;&gt;JS 垃圾回收&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收(Garbage Collection)&lt;/strong&gt; 是一种自动的内存管理机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，从而不会出现内存泄漏问题。对于 JavaScript 也一样，我们知道不管是创建基础类型还是对象、函数等，都要用到内存，那么一旦我们不需要它了，JS 引擎如何去判断和清除呢？一般来讲有两种通用的方式来管理内存，即&lt;strong&gt;标记清除&lt;/strong&gt;和&lt;strong&gt;引用计数&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;标记清除&quot;&gt;标记清除&lt;/h2&gt;

&lt;h3 id=&quot;可达性&quot;&gt;可达性&lt;/h3&gt;

&lt;p&gt;这里引用 JAVASCRIPT.INFO 里的&lt;a href=&quot;https://javascript.info/garbage-collection#reachability&quot;&gt;这篇文章&lt;/a&gt;来讲述。同时这里会引入到一个概念，即&lt;strong&gt;可达性(Reachability)&lt;/strong&gt;。它指的就是在某些条件下能够访问或使用的值，而这些值是确保存储于内存当中的，也称之为&lt;strong&gt;根(roots)&lt;/strong&gt;。比如全局变量、函数中的局部变量和参数等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// user has a reference to the object
let user = {
  name: &quot;Tate&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述栗子我们可以看到，全局变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 引用了对象 &lt;code class=&quot;highlighter-rouge&quot;&gt;{name: &quot;Tate&quot;}&lt;/code&gt;，不妨简称为对象 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tate&lt;/code&gt;，如果我们覆盖 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 的值会怎样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;user = null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tate&lt;/code&gt; 是不可达的，因为它没有被引用，因此该数据会被清理而释放内存。假设我们定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; 两个引用呢:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;let admin = user
user = null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可想而知，&lt;code class=&quot;highlighter-rouge&quot;&gt;Tate&lt;/code&gt; 仍然被引用，我们可以通过全局变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; 去访问，因此它并不会被清理，除非我们再次覆盖 &lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; 的值。&lt;/p&gt;

&lt;h3 id=&quot;算法机制&quot;&gt;算法机制&lt;/h3&gt;

&lt;p&gt;上述只是一个简单的栗子，现实环境中肯定比这复杂很多，那么我们就需要一个算法来支撑，即&lt;strong&gt;标记清除(mark-and-sweep)&lt;/strong&gt;，它定期会执行一次，步骤如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;垃圾回收器首先标记所有根(roots)&lt;/li&gt;
  &lt;li&gt;访问和标记所有来自根的引用&lt;/li&gt;
  &lt;li&gt;访问所标记的对象并继续标记他们的引用。注意所有访问过的对象会被标记，从而防止重复访问&lt;/li&gt;
  &lt;li&gt;依次反复至所有可达引用被访问和标记&lt;/li&gt;
  &lt;li&gt;所有未被标记的对象将被回收清除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/13/t1eMIpi24mHQ5gF.png&quot; alt=&quot;js-garbage-collection.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然 JS 引擎也做了一些优化，使其运行得更快，不至于影响正常代码的执行:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;分代回收(Generational collection)&lt;/strong&gt; - 将对象分为“新对象”和“旧对象”。对于新对象而言，他们经常会被检测，从而被清除。那些幸存下来活得足够久的对象，会变“老”，接受检查的次数也会相应减少&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;增量回收(Incremental collection)&lt;/strong&gt; - 一次性访问和标记整个对象集显然很笨拙。因此，引擎会试图将垃圾回收分解为多个部分，然后各个击破。当然这需要额外的标记来跟踪变化，但是延迟会更小&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;空闲时间回收(Idle-time collection)&lt;/strong&gt; - 只在 CPU 空闲时运行，最大限度减少对正常执行的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，我们可以得出以下一些结论:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;垃圾回收是自动进行的，我们没办法去干涉&lt;/li&gt;
  &lt;li&gt;当对象是可达的，那么它必然是存储在内存当中的&lt;/li&gt;
  &lt;li&gt;被引用和可达不是一回事，就像上面栗子一样，即使有相互引用，但我们无法访问，依然会被回收清除&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;引用计数&quot;&gt;引用计数&lt;/h2&gt;

&lt;p&gt;之前有段时间学过 OC，emmm…，记得当时它内存管理的方式就是&lt;strong&gt;引用计数(reference counting)&lt;/strong&gt;，即跟踪记录每个值被引用的次数。简而言之，就是当一个值被引用时，则该值的引用次数加 1，反之则减 1，为 0 时就会被回收。目前应该只存在于低版本的 IE。&lt;/p&gt;

&lt;p&gt;但是该方式会引起内存泄漏，原因是它不能解决循环引用的问题，让我们来看下面这个栗子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function test() {
  var a = {}
  var b = {}
  a.prop = b
  b.prop = a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到每次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt; 函数，a 和 b 相互引用，引用计数都为 2，会使这部分内存永远不会被释放，即造成内存泄漏。这种时候就需要手动去间接触发内存的释放，比如之前博客谈到的&lt;a href=&quot;http://localhost:2333/2018/02/09/js-closure.html&quot;&gt;闭包栗子里对 DOM 对象的引用&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function assignHandler() {
  var element = document.getElementById('someElement');
  element.onclick = function() {
    alert(element.id);
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// better
function assignHandler() {
  var element = document.getElementById('someElement');
  var id = element.id;
  element.onclick = function() {
    alert(id);
  };

  element = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内存泄漏&quot;&gt;内存泄漏&lt;/h2&gt;

&lt;p&gt;虽然有垃圾回收机制，但是我们仍然要关注以下这些可能带来的内存泄漏问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量 - 由于全局变量运行时不会被回收，因此需要及时手动去清理，比如运用规范校验或者严格模式&lt;/li&gt;
  &lt;li&gt;闭包 - 闭包可以维持函数内局部变量，使其得不到释放，不宜滥用&lt;/li&gt;
  &lt;li&gt;DOM 对象引用 - 如上栗。如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定&lt;/li&gt;
  &lt;li&gt;遗忘的定时器和回调 - 没有及时清除定时器，尤其是持有该页面某些内容，如 setTimeout 和 setInterval&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://javascript.info/garbage-collection#reachability&quot;&gt;Garbage collection&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection&quot;&gt;A tour of V8: Garbage Collection&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/dasusu/p/12200176.html&quot;&gt;js 的内存泄漏场景、监控以及分析&lt;/a&gt; By dasu&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="JavaScript" /><summary type="html">JS 垃圾处理机制</summary></entry><entry><title type="html">【科普】细菌与病毒</title><link href="http://localhost:2333/2020/02/10/bacteria-viruses.html" rel="alternate" type="text/html" title="【科普】细菌与病毒" /><published>2020-02-10T20:09:00+08:00</published><updated>2020-02-10T20:09:00+08:00</updated><id>http://localhost:2333/2020/02/10/bacteria-viruses</id><content type="html" xml:base="http://localhost:2333/2020/02/10/bacteria-viruses.html">&lt;h1 id=&quot;科普细菌与病毒&quot;&gt;【科普】细菌与病毒&lt;/h1&gt;

&lt;p&gt;记录科普知识笔记很大程度上是受&lt;a href=&quot;https://space.bilibili.com/9458053/video&quot;&gt;李永乐老师&lt;/a&gt;影响，因为他的授课太有趣啦，这里只是整理一下，方便自己以后来温习下。这次新冠状病毒引发了众多的关注，刚好也梳理一下细菌和病毒的一些知识，更加理性地加强防护 😷&lt;/p&gt;

&lt;h2 id=&quot;细菌&quot;&gt;细菌&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;细菌(Bacteria)&lt;/strong&gt;是指生物的主要类群之一，也是所有生物中数量最多的一类。细菌最早是被荷兰人列文虎克（Antonie van Leeuwemhoek，1632-1723）在一位从未刷过牙的老人牙垢上发现的，但那时的人们认为细菌是自然产生的。直到后来，巴斯德用&lt;a href=&quot;https://baike.baidu.com/item/鹅颈烧瓶实验/1534271&quot;&gt;&lt;strong&gt;鹅颈瓶实验&lt;/strong&gt;&lt;/a&gt;指出，细菌是由空气中已有细菌产生的，而不是自行产生，并发明了“&lt;strong&gt;巴氏消毒法&lt;/strong&gt;”，被后人誉为“微生物之父”。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;巴氏消毒法是一种利用较低的温度既可杀死病菌又能保持物品中营养物质风味不变的消毒法，常常被广义地用于定义需要杀死各种病原菌的热处理方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;细菌形态&quot;&gt;细菌形态&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;形态&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;栗子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;球菌&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;球状，直径 0.5～1 微米。有单球菌、双球菌、链球菌、葡萄球菌等等&lt;/td&gt;
      &lt;td&gt;肺炎双球菌、金黄色葡萄球菌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;杆菌&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;杆状，按杆菌细胞的排列方式不同则有成对的双杆菌、呈链状的链杆菌&lt;/td&gt;
      &lt;td&gt;大肠杆菌、炭疽芽孢杆菌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;螺旋菌&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;螺旋状。根据菌体的弯曲可分为弧菌、螺菌和螺旋体&lt;/td&gt;
      &lt;td&gt;霍乱弧菌、梅毒螺旋体&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;细菌结构&quot;&gt;细菌结构&lt;/h3&gt;

&lt;p&gt;细菌主要由细胞壁、细胞膜、细胞质、核质体等部分构成，有的细菌还有荚膜、鞭毛、菌毛、纤毛等特殊结构。绝大多数细菌的直径大小在 0.5~5μm 之间。细菌结构没有叶绿体，也没有线粒体，大部分不能进行光合作用。但部分细菌（如蓝藻）细胞膜上拥有叶绿素，可进行光合作用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=b889205adb43ad4bb2234e92e36b31ca/6159252dd42a28345521ebf451b5c9ea14cebf4e.jpg&quot; alt=&quot;细菌结构&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;细胞壁 - 细胞壁为细菌最外部的一层坚韧、厚实的外被，主要由肽聚糖组成。可以保持细胞外形；抑制机械和渗透损伤；介导细胞间相互作用（侵入宿主）；防止大分子入侵；协助细胞运动和分裂&lt;/li&gt;
  &lt;li&gt;细胞膜 - 控制细胞与外界物质的交换；在细胞维持胞内正常渗透压的机制中起屏障的作用&lt;/li&gt;
  &lt;li&gt;细胞质 - 细菌的细胞质基质是一种透明的胶状固体，细菌和其它&lt;strong&gt;原核生物&lt;/strong&gt;一样，没有核膜(核与细胞质交界处的双层结构膜)，DNA 集中在细胞质中的低电子密度区，即核区(核质体)。由于没有核膜，因此 DNA 的复制、RNA 的转录与蛋白的质合成可同时进行，而不像&lt;strong&gt;真核细胞&lt;/strong&gt;那样这些生化反应在时间和空间上是严格分隔开来的&lt;/li&gt;
  &lt;li&gt;荚膜 - 许多细菌的最外表还覆盖着一层多糖类物质即荚膜。不仅可利用荚膜抵御不良环境；保护自身不受白细胞吞噬；而且能有选择地粘附到特定细胞的表面上，表现出对靶细胞的专一攻击能力&lt;/li&gt;
  &lt;li&gt;鞭毛 - 是某些细菌的运动器官，来改变运动状态&lt;/li&gt;
  &lt;li&gt;菌毛 - 系生在在细菌表面的一种纤细、中空、短直的蛋白质附属物，结构比鞭毛要简单，能让细菌较牢固地附着在物体上&lt;/li&gt;
  &lt;li&gt;芽孢 - 某些细菌处于不利的环境，或耗尽营养时，细胞壁增厚，本体减小而形成芽孢，是对不良环境有强抵抗力的休眠体，由于芽孢在细菌细胞内形成，故常称为内生孢子，生命力极强。小而轻的芽孢还可以随风四处飘散，落在适当环境中，又能萌发成为细菌&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;DNA 就像是厂长、RNA 是车间主任，厂长下达命令给车间主任，车间主任则指派任务给工人。有些不含 DNA 的，也可以直接由 RNA 来分配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;真核细胞指含有真核（被核膜包围的核）的细胞，所有的动植物细胞都属于真核细胞，由真核细胞构成的生物称为真核生物&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;细菌繁殖&quot;&gt;细菌繁殖&lt;/h3&gt;

&lt;p&gt;细菌按照生存方式可以分为自养型和毅养型:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自养型 - 比如蓝细菌含有叶绿素 a 可以进行光合作用，还有硫化菌&lt;/li&gt;
  &lt;li&gt;异养型 - 分别有寄生、腐生和共生。比如大肠杆菌和人中间属于共生，可以为我们分解出维生素，控制代谢活动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;细菌主要以无性&lt;strong&gt;二分裂&lt;/strong&gt;方式繁殖，即细菌生长到一定时期，在细胞中间逐渐形成横隔，由一个母细胞分裂为两个大小相等的子细胞，以此类推。细菌繁殖速度快，一般细菌约 20～30min 便分裂一次，即为一代&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.med66.com/upload/news/2008/11/25/qiansh2178200811251723299027.jpg&quot; alt=&quot;二分裂&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在适宜的培养条件下。细菌便迅速生长繁殖。由于细菌细胞受固体培养基表面或深层的限制，故不能像在液体培养基中那样自由扩散，因此繁殖的菌体常聚集在一起，形成了肉眼可见的细菌集落，通常称之为&lt;strong&gt;菌落&lt;/strong&gt;。菌落特征决定于组成菌落的细胞结构与生长行为，如细菌的荚膜，它的存在与否和菌落形态等有直接关系。比如肺炎链球菌因具有荚膜就形成光滑型菌落，其表面光滑黏稠，不具荚膜的菌株形成的菌落为粗糙型，菌落表面干燥、有皱折。&lt;/p&gt;

&lt;h3 id=&quot;抗生素&quot;&gt;抗生素&lt;/h3&gt;

&lt;p&gt;平常生活中，我们可以采取一些措施来减少细菌，比如勤洗手，戴口罩等。也可以通过疫苗来防护，比如被生锈钉子扎伤后，破伤风菌进入人体后会导致破伤风，因此需要打破伤风疫苗。还有一种方法就是采用&lt;strong&gt;抗生素&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;抗生素是指由微生物（包括细菌、真菌、放线菌属）或高等动植物在生活过程中所产生的具有抗病原体或其他活性的一类次级代谢产物，能干扰其他生物细胞发育功能的化学物质。临床常用的抗生素有微生物培养液中的提取物以及用化学方法合成或半合成的化合物。抗生素产生杀菌作用主要有四种机制，即：抑制细菌细胞壁的合成、与细胞膜相互作用、干扰蛋白质的合成以及抑制核酸的复制和转录。&lt;/p&gt;

&lt;p&gt;需要注意的是，抗生素的作用具有选择性，不同抗生素对不同病原菌的作用不一样。在使用抗生素可能会引起诸多不良反应，因为有时候会无差别攻击，导致正常细胞被消灭而代谢紊乱。滥用抗生素还会导致细菌耐药性更强，各种“超级病菌”相继诞生。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;抗生素对病毒无效 🦠&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;病毒&quot;&gt;病毒&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;病毒(Virus)&lt;/strong&gt; 是一种个体微小，结构简单，只含一种核酸（DNA 或 RNA），必须在活细胞内寄生并以复制方式增殖的非细胞型生物。病毒没有自己的代谢机构，没有酶系统。因此病毒离开了宿主细胞，就成了没有任何生命活动、也不能独立自我繁殖的化学物质。它的复制、转录、和转译的能力都是在宿主细胞中进行，当它进入宿主细胞后，它就可以利用细胞中的物质和能量完成生命活动，按照它自己的核酸所包含的遗传信息产生和它一样的新一代病毒。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;病毒个体极其微小，绝大多数要在电子显微镜下才能看到，而细菌一般在光学显微镜下就可以看到&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;病毒既不属于原核生物，也不属于真核生物&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;病毒分类&quot;&gt;病毒分类&lt;/h3&gt;

&lt;p&gt;病毒不仅分为植物病毒，动物病毒和细菌病毒。从结构上还分为：单链 RNA 病毒，双链 RNA 病毒，单链 DNA 病毒和双链 DNA 病毒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img0.imgtn.bdimg.com/it/u=492479578,2033285378&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;病毒结构&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这次备受瞩目的武汉新冠状病毒即为单链 RNA 病毒 🦠&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;病毒感染与潜伏&quot;&gt;病毒感染与潜伏&lt;/h3&gt;

&lt;p&gt;病毒的生命过程大致分为下面五个步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;吸附&lt;/li&gt;
  &lt;li&gt;注入（遗传物质）&lt;/li&gt;
  &lt;li&gt;合成（逆转录/整合入宿主细胞 DNA）&lt;/li&gt;
  &lt;li&gt;装配（利用宿主细胞转录 RNA，翻译蛋白质再组装）&lt;/li&gt;
  &lt;li&gt;释放&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1581333028760&amp;amp;di=dbc897f40d833a446b582c03bd1db00b&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fwww.kedo.gov.cn%2Fupload%2Fresources%2Fimage%2F2018%2F11%2F23%2F249366.png&quot; alt=&quot;病毒侵入&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有些病毒还会有潜伏期，随着宿主细胞的分裂来增加病毒数量，比如新冠状病毒潜伏期有十几天，而 HIV 病毒则有十年之久，期间你不会有任何反应，但是一到爆发的时候就可能会有生命危险。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;免疫系统与细胞因子风暴&quot;&gt;免疫系统与细胞因子风暴&lt;/h3&gt;

&lt;p&gt;我们再看看一些病理，比如肺炎。在我们病毒感染了细胞之后，&lt;strong&gt;免疫细胞&lt;/strong&gt;会进行防护来对抗这些病毒，一般情况下微弱的免疫反应不会有任何影响，强一点的会导致&lt;strong&gt;发炎&lt;/strong&gt;等症状。为了运输更多白细胞到”战场”，血液流速会变快，血管膨胀，体液增加，体征为局部红肿。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;免疫细胞是指参与免疫应答或与之相关的细胞。包括淋巴细胞、树突状细胞、单核/巨噬细胞、粒细胞、肥大细胞等。俗称&lt;a href=&quot;https://baike.baidu.com/item/白细胞/244737&quot;&gt;白细胞&lt;/a&gt;)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而过度的免疫反应会导致&lt;strong&gt;细胞因子风暴&lt;/strong&gt;，即引起体液中多种细胞因子，迅速大量产生的现象，是引起急性呼吸窘迫综合症和多器官衰竭的重要原因，从而伤害宿主。还没等病毒把你干死，免疫系统已经把你干死了。因此免疫的平衡至关重要，过强会导致超敏反应；过弱则产生免疫缺陷。&lt;/p&gt;

&lt;h3 id=&quot;激素&quot;&gt;激素&lt;/h3&gt;

&lt;p&gt;上面说过要平衡免疫，那么&lt;strong&gt;激素&lt;/strong&gt;就是一个很好的选择，它是一种免疫抑制剂，因此有抗炎、抗休克和抗过敏等功能，但同样过度使用会对身体有副作用。还有就是通过药物，但是由于病毒的变异性，研发一种药物后，病毒变异就会使其功能失效，因此效果上不是很好。比如达菲，只是在针对某一些流感病毒在某一个时间段内有效。&lt;/p&gt;

&lt;h2 id=&quot;立克次体&quot;&gt;立克次体&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;立克次氏体(Rickettsia)&lt;/strong&gt;为&lt;a href=&quot;https://baike.baidu.com/item/革兰氏阴性菌&quot;&gt;&lt;strong&gt;革兰氏阴性菌&lt;/strong&gt;&lt;/a&gt;，是一类专性寄生于真核细胞内的 G-原核生物。是介于细菌与病毒之间，而接近于细菌的一类原核生物，没有核仁及核膜。一般呈球状或杆状，是专性细胞内寄生物，主要寄生于节肢动物，有的会通过蚤、虱、蜱、螨传入人体、如斑疹伤寒、战壕热等。&lt;/p&gt;

&lt;p&gt;立克次氏体在虱等节肢动物的胃肠道上皮细胞中增殖并大量存在其粪中。人受到虱等叮咬时，立克次氏体便随粪从抓破的伤口或直接从昆虫口器进入人的血液并在其中繁殖，从而使人感染得病。当节肢动物再叮咬人吸血时，人血中的立克次氏体又进入其体内增殖，如此不断循环。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;革兰氏阴性菌泛指革兰氏染色反应呈红色的细菌(如大肠杆菌、霍乱弧菌)，通过这种测试我们可以区分两种细胞壁结构不同的细菌。革兰氏阳性菌在反应后的除色溶液中将呈现龙胆紫的颜色。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;大规模传染病事例&quot;&gt;大规模传染病事例&lt;/h2&gt;

&lt;h3 id=&quot;鼠疫&quot;&gt;鼠疫&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;鼠疫(Plague)&lt;/strong&gt;是由鼠疫耶尔森菌感染引起的烈性传染病，为自然疫源性传染病，主要在啮齿类动物间流行，鼠、旱獭等为鼠疫耶尔森菌的自然宿主。根据临床表现和发病特点，主要分为以下几种类型:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;腺鼠疫 - 主要是鼠蚤叮咬处引流区淋巴结肿痛，导致其快速化脓、破溃&lt;/li&gt;
  &lt;li&gt;肺鼠疫 - 根据功能性分为原发性肺鼠疫和继发性肺鼠疫
    &lt;ul&gt;
      &lt;li&gt;原发性肺鼠疫 - 为人与人之间呼吸道直接感染所致&lt;/li&gt;
      &lt;li&gt;继发性肺鼠疫 - 在腺鼠疫和脓毒血症型鼠疫的基础上，继发肺部感染，临床表现与原发性肺鼠疫相同&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;脓毒血症型鼠疫 - 短时间内出现全身毒血症症状、出血、神志不清、谵妄或昏迷。病人因皮肤广泛出血、瘀斑、发绀，死亡后尸体呈紫黑色，俗称“&lt;strong&gt;黑死病&lt;/strong&gt;”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;历史上总共记录了三次大规模的鼠疫爆发感染，特别是第二次 14 世纪中期，一种被称为“黑死病”的鼠疫开始在西亚和欧洲大陆上扩散蔓延，仅在欧洲就造成了近三分之一人口的死亡。一般意义上认为此次鼠疫起源于中亚地区，更有很多学者认为是蒙古大军西征时带来的。去年有发布的一款游戏就叫瘟疫传说 《A Plague Tale: Innocence》，里面大量的老鼠和尸体直叫人胆寒发怵。&lt;/p&gt;

&lt;p&gt;同时在明末崇祯年间北京及其周边地区也爆发过大规模的鼠疫，此次鼠疫大流行一直到十八世纪末期才算是结束，如果将这几百年的因鼠疫而死亡人数全部算上，至少在一亿以上，危害之大简直无以复加。之后的三四百年，几乎每隔一段时间欧洲就会出一次鼠疫爆发，虽然因为免疫力的产生、医疗水平的提高等原因，死亡率大大降低，但还是造成了极其惨烈的后果。&lt;/p&gt;

&lt;p&gt;第三次大规模鼠疫爆发是在 1910 年中国东北，4 个月内，东北三省就有 6 万人死亡。疫情之下，沙俄、日本纷纷以保护侨民为由，欲意独揽东北全境防疫工作，甚至以派兵相威胁。内忧外患，疫情必除。情势危急之下，清府外务部施肇基举荐北洋陆军军医学堂帮办（副校长）&lt;strong&gt;伍连德&lt;/strong&gt;为钦差总医官，全权负责疫情调查研究处理工作。&lt;/p&gt;

&lt;p&gt;此前，日本南满铁路曾派医官来疫区除疫，他们捉了几百只老鼠，解剖研究，想从中发现病毒之源，但无果，而沙俄则提出灭鼠的方法。对此，伍连德经过解剖也断定了肺鼠疫的传播，从而对人群进行隔离、禁行和口罩防护，对尸体进行火葬，最终在短时间内成功抑制了此次大规模的鼠疫传播，后续也被诺贝尔提名。而这次疫情的源头就是旱獭，因为加工旱獭皮毛而被感染。&lt;/p&gt;

&lt;h3 id=&quot;埃博拉&quot;&gt;埃博拉&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;埃博拉(Ebola)&lt;/strong&gt;病毒是一种十分罕见的病毒，1976 年在苏丹南部和刚果金的埃博拉河地区发现它的存在后，引起医学界的广泛关注和重视。埃博拉病毒主要是通过病人的血液、唾液、汗水和分泌物等途径传播。被感染后，病毒在体内迅速扩散、大量繁殖，袭击多个器官，使之发生变形、坏死，并慢慢被分解。病人先是内出血，继而七窍流血不止，并不断将体内器官的坏死组织从口中呕出，最后因广泛内出血、脑部受损等原因而死亡。&lt;/p&gt;

&lt;p&gt;埃博拉是人畜共通病毒，果蝠可能是病毒的原宿主。目前有效的预防措施是使用疫苗，疫苗又分为&lt;strong&gt;灭活疫苗&lt;/strong&gt;和&lt;strong&gt;减毒疫苗&lt;/strong&gt;。相对来说，后者在疫苗的效果上要优于前者疫苗，但减毒疫苗也存在着环境污染、交叉感染的危险:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;灭活疫苗 - 将病原微生物（包括细菌、病毒和立克次体等）及其代谢产物用物理或化学的方法使其灭活，丧失毒力，但仍保留其免疫原性而制成的疫苗。一般注射一针后产生免疫力不高，需要注射 2～3 次或加强注射，才能产生较为满意的免疫力&lt;/li&gt;
  &lt;li&gt;减毒疫苗 - 将病原微生物在人工条件下使其丧失致病性，但仍保留其繁衍能力和免疫原性，以此制成减毒活疫苗。减毒活疫苗在体内的作用时间长，往往只需要接种一次，即可产生稳固的免疫力，这类疫苗有脊髓灰质炎疫苗、麻疹疫苗等。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;埃博拉病毒，生物安全等级为 4 级（艾滋病和 SARS 为 3 级，级数越大防护越严格）。我国大陆生物安全等级为 4 级的研究所有两个，一个是在武汉中科院病毒研究所；另一个在哈尔滨兽医研究所。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;天花&quot;&gt;天花&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;天花(small pox)&lt;/strong&gt;是由天花病毒感染人引起的一种十分古老的烈性传染病，主要表现为严重的病毒血症，染病后死亡率高，即使幸运的活了下来，康复后也会满脸麻子。天花病毒主要经呼吸道黏膜侵入人体，通过飞沫吸入或直接接触而传染。天花病毒有毒力不同的两型病毒株，毒力强的引起正型天花，即典型天花；弱者引起轻型天花，即类天花。&lt;/p&gt;

&lt;p&gt;18 世纪天花在欧洲肆虐，每十个人里就有一人死于天花，后来采用医生詹纳接种牛痘的方式，才最终抑制了感染的爆发。1979 年 10 月 26 日，世界卫生组织宣布天花作为一种疾病在全世界范围内已经被剿灭，成为目前被唯一消除的传染病。&lt;/p&gt;

&lt;h3 id=&quot;艾滋病&quot;&gt;艾滋病&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;艾滋病(AIDS)&lt;/strong&gt;是一种危害性极大的传染病，由感染艾滋病病毒（HIV 病毒）引起。HIV 是一种能攻击人体免疫系统的病毒。它把人体免疫系统中最重要的 CD4T 淋巴细胞作为主要攻击目标，大量破坏该细胞，使人体丧失免疫功能。因此，人体易于感染各种疾病，并可发生恶性肿瘤，病死率较高。HIV 在人体内的潜伏期平均为 8～9 年，此间无任何临床表现。&lt;/p&gt;

&lt;p&gt;2015 年 3 月 4 日多国科学家研究发现，艾滋病毒已知的 4 种病株，均来自喀麦隆的黑猩猩及大猩猩，是人类首次完全确定艾滋病毒毒株的所有源头。传染方式有性传播、血液传播和母婴传播等。目前在全世界范围内仍缺乏根治 HIV 感染的有效药物。现阶段的治疗目标是最大限度和持久地抑制患者体内的病毒复制，使患者获得免疫功能重建并维持免疫功能，同时降低 HIV 感染与非艾滋病相关疾病的发病率和死亡率。&lt;/p&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1651183311158460598&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;世界史上发生过哪三次鼠疫大爆发，造成了怎样的毁灭性后果&lt;/a&gt; By 历史大学堂&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="历史" /><category term="science" /><summary type="html">【科普】细菌与病毒</summary></entry><entry><title type="html">JAMstack</title><link href="http://localhost:2333/2020/01/30/jamstack.html" rel="alternate" type="text/html" title="JAMstack" /><published>2020-01-30T17:11:00+08:00</published><updated>2020-01-30T17:11:00+08:00</updated><id>http://localhost:2333/2020/01/30/jamstack</id><content type="html" xml:base="http://localhost:2333/2020/01/30/jamstack.html">&lt;h1 id=&quot;jamstack&quot;&gt;JAMstack&lt;/h1&gt;

&lt;h2 id=&quot;什么是-jamstack&quot;&gt;什么是 JAMstack&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://jamstack.wtf/#meaning&quot;&gt;&lt;strong&gt;JAMstack&lt;/strong&gt;&lt;/a&gt; 是一种现代制作网站方法，提供更好的性能，更高的安全性，更低的扩展成本以及更好的开发人员体验。其中的 JAM 代表了 &lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript, API &amp;amp; Markup&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; - 通过 JavaScript 处理动态功能，不限使用哪个框架或库&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;API&lt;/strong&gt; - 服务器端操作被抽象为可重用的 API，并使用 JavaScript 通过 HTTPS 访问，可以是第三方服务或自定义的功能&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Markup&lt;/strong&gt; - 网站是作为静态 HTML 文件提供的。可以使用&lt;strong&gt;静态站点生成器(static site generator)&lt;/strong&gt;从源文件(例如 Markdown)生成&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;A modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JAMstack 有很多好处:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;更快的性能 - 通过 CDN 提供预先构建的标记文件和资源文件(assets)&lt;/li&gt;
  &lt;li&gt;更安全 - 无需担心服务器或数据库的漏洞&lt;/li&gt;
  &lt;li&gt;更便宜 - 托管静态文件很便宜甚至免费&lt;/li&gt;
  &lt;li&gt;更好的开发体验 - 前端开发人员可以专注于前端，不必依赖于传统的一体化架构&lt;/li&gt;
  &lt;li&gt;可扩展性 - 如果产品在传播时突然拥有许多活跃用户，CDN 将无缝补齐所需资源&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JAMstack 的最佳做法:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 CDN - 提供了更好的性能和更轻松的可扩展性&lt;/li&gt;
  &lt;li&gt;原子部署 - 每个部署都是站点的完整快照，可保证全球网站版本的一致&lt;/li&gt;
  &lt;li&gt;缓存失效 - 上传新构建的版本后，CDN 使缓存无效，可使新版本即时生效&lt;/li&gt;
  &lt;li&gt;版本控制 - 把代码放到 Git，可记录每个文件的历史更改，方便协作和追溯&lt;/li&gt;
  &lt;li&gt;自动构建 - 当需要新构建时，&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/网络钩子&quot;&gt;&lt;strong&gt;webhooks&lt;/strong&gt;&lt;/a&gt; 会通知服务器，构建后实时更新 CDN 和站点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://1024.com/uploads/editor/11/jnal1ipd7z7q.jpeg&quot; alt=&quot;JAMstack 构建流程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何构建&quot;&gt;如何构建&lt;/h2&gt;

&lt;h3 id=&quot;静态站点生成器&quot;&gt;静态站点生成器&lt;/h3&gt;

&lt;p&gt;大部分 JAMstack 静态网站都需要静态站点生成器，我们可以根据我们的需求随便选一个。之前博客中介绍的 &lt;a href=&quot;http://localhost:2333/2019/10/10/github-pages.html#jekyll&quot;&gt;Jekyll&lt;/a&gt; 就是 SSG 之一，还有 Gatsby 之类的，更多静态站点生成器&lt;a href=&quot;https://www.staticgen.com&quot;&gt;可以查看这里&lt;/a&gt; 👈&lt;/p&gt;

&lt;h3 id=&quot;部署平台&quot;&gt;部署平台&lt;/h3&gt;

&lt;p&gt;选择可以部署的平台，比如 Github Pages 或者 Netlify(看清楚了，不是网飞 Netflix 😳) 等，更多平台&lt;a href=&quot;https://www.thenewdynamic.org/tools/hosting-deployment/&quot;&gt;可以参考这里&lt;/a&gt; 👈&lt;/p&gt;

&lt;h3 id=&quot;动态部分&quot;&gt;动态部分&lt;/h3&gt;

&lt;p&gt;静态网站不是真的就是静态的，你可以通过一些服务来进行动态数据的传输。下面举几个例子:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自定义函数 - 可以抽象函数为可复用的 API，如 &lt;a href=&quot;https://aws.amazon.com/lambda/features/&quot;&gt;AWS lambda functions&lt;/a&gt; or &lt;a href=&quot;https://functions.netlify.com/examples/&quot;&gt;Netlify Functions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;自定义数据 - 很多场景你需要存储一些数据，可以用到 &lt;a href=&quot;https://fauna.com&quot;&gt;FaunaDB Serverless GraphQL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;评论功能 - 提供评论功能，如 disqus 或者 gitalk 等&lt;/li&gt;
  &lt;li&gt;还有很多其他功能模块，比如搜索、支付、在线聊天等，更多&lt;a href=&quot;https://github.com/agarrharr/awesome-static-website-services#e-commerce&quot;&gt;可以参考这里&lt;/a&gt; 👈&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以在官方网站&lt;a href=&quot;https://jamstack.org/examples/&quot;&gt;找到一些示例&lt;/a&gt;，也可以找到&lt;a href=&quot;https://jamstackthemes.dev&quot;&gt;丰富多彩的 JAMstack 主题&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://snipcart.com/media/204006/jamstack-vs-wordpress-1.png&quot; alt=&quot;JAMstack workflow&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;headless-cms&quot;&gt;headless CMS&lt;/h2&gt;

&lt;p&gt;JAMstack 静态网站可以通过 &lt;strong&gt;CMS(Content Management System)&lt;/strong&gt; 内容管理系统来进行管理，比如无头(headless) CMS。当 CMS 上触发某个变动时，会重新自动构建新的网站版本并将其部署为静态资源。&lt;/p&gt;

&lt;p&gt;那么问题来了，headless CMS 与传统的 CMS 到底有啥区别呢？&lt;/p&gt;

&lt;p&gt;传统的 CMS 内容管理方法是将所有内容集中在一起，包括内容、图片和其他一些资源，这使得内容构建和展示完全耦合，比如 Wordpress，Drupal，Joomla 等。虽然传统上它们都是 CMS，每次提供服务时都必须与网站一起托管和构建。但 headless CMS 不在乎将内容投放到何处，它不再附加到前端，并且可以在任何平台上查看内容。这种方法的优点很大，并且可以与 JAMstack 站点一起使用，与传统站点相比，JAMstack 站点更安全，更方便地进行扩展。如 Strapi、Ghost、Jekyll Admin 等，更多&lt;a href=&quot;https://headlesscms.org&quot;&gt;可以参考这里&lt;/a&gt; 👈&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://css-tricks.com/wp-content/uploads/2016/03/headless.svg&quot; alt=&quot;headless CMS&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jekyll--strapi-实战&quot;&gt;Jekyll + Strapi 实战&lt;/h2&gt;

&lt;p&gt;之前有说过我的博客用的站点生成器就是 Jekyll，这里我介绍下如何用 &lt;strong&gt;Strapi&lt;/strong&gt; headless CMS 来为站点提供 API 数据支持。大体上其实分为三个步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装和配置 Strapi，启动&lt;/li&gt;
  &lt;li&gt;启动 Jekyll 站点&lt;/li&gt;
  &lt;li&gt;通过一些依赖和配置，让 Jekyll 能正常调用到 Strapi 提供的 API&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一、安装和配置 Strapi&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/strapi/strapi/&quot;&gt;Strapi&lt;/a&gt; 直接可以&lt;a href=&quot;https://strapi.io/documentation/3.0.0-beta.x/getting-started/quick-start-tutorial.html#_1-install-strapi-and-create-a-project&quot;&gt;参考官网的安装步骤&lt;/a&gt;，已经巨详细了，一般情况下这里都不会有什么问题，但是有几个地方需要注意下，我们首先需要安装:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;yarn create strapi-app my-project --quickstart
# or
npx create-strapi-app my-project --quickstart
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--quickstart&lt;/code&gt; 参数这里会默认用到轻便的 SQLite 数据库，你可以不使用该参数，但是会要求你选择所需的数据库，并且在你使用上述命令构建前，就必须让它能够在本地运行。比如 MongoDB，你可以&lt;a href=&quot;https://strapi.io/documentation/3.0.0-beta.x/guides/databases.html#sqlite-installation&quot;&gt;参照这里来进行安装和选择&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装完成后会自动开启 Strapi 项目，这时候需要你在打开的网页中注册 Administrator 用户，它将拥有所有的访问和操作权限。之后便可以去创建 Content Type，具体可以参照官网步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strapi.io/documentation/assets/img/content-type-dashboard.40ce5bb2.png&quot; alt=&quot;Strapi type&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，默认情况下，Strapi 会通过权限来管控发布的 Content Type，也就是说你需要为你所创建的 Content Type 来下放权限，可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Roles &amp;amp; Permissions&lt;/code&gt; 菜单中为他们勾选对应的操作权限，如 find、findone 等。而且在你创建了比如名为 Restaurant 的 Content Type 时，会自动创建对应路由来访问数据，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:1337/restaurants&lt;/code&gt;，如果没有权限的话将返回 403:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strapi.io/documentation/assets/img/restaurant-api.3040f37d.png&quot; alt=&quot;Restaurant&quot; /&gt;&lt;/p&gt;

&lt;p&gt;二、启动 Jekyll 站点&lt;/p&gt;

&lt;p&gt;这个就没什么说了，我们把项目启动即可，可以直接&lt;a href=&quot;http://localhost:2333/2019/10/10/github-pages.html#jekyll&quot;&gt;参考下之前的博客&lt;/a&gt; 👈&lt;/p&gt;

&lt;p&gt;三、配置 Jekyll 使其能访问 Strapi API&lt;/p&gt;

&lt;p&gt;我们这里使用了 &lt;a href=&quot;https://github.com/strapi/jekyll-strapi&quot;&gt;&lt;strong&gt;jekyll-strapi&lt;/strong&gt;&lt;/a&gt; 插件，具体配置方式如下，首先在 gemfile 添加对应 gem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;# If you have any plugins, put them here!
group :jekyll_plugins do  
  gem &quot;jekyll-feed&quot;, &quot;~&amp;gt; 0.6&quot;
  gem &quot;jekyll-strapi&quot;, &quot;~&amp;gt; 0.1&quot;
end  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装这些 gem，然后将他们添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 配置文件中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;gem install jekyll-strapi  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;# _config.yml
plugins:  
  - jekyll-feed
  - jekyll-strapi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后我们运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt; 来安装这些依赖，剩下的我们需要做一些数据访问的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;# _config.yml
strapi:
  # Your API endpoint (optional, default to http://localhost:1337)
  endpoint: http://localhost:1337
  # Collections, key is used to access in the strapi.collections
  # template variable
  collections:
    # Example for a &quot;posts&quot; collection
    posts:
      # Collection name (optional). Used to construct the url requested. Example: type `foo` would generate the following url `http://localhost:1337/foo`.
      type: posts
      # Permalink used to generate the output files (eg. /posts/:id).
      permalink: /posts/:slug/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置之后，我们就可以访问到全局变量 strapi，并且通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;strapi.collection.posts&lt;/code&gt; 来访问到我们所创建的 posts 数据，如果我们在模板中使用的话，可以参考下面:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;div class=&quot;home&quot;&amp;gt;
  &amp;lt;h1 class=&quot;page-heading&quot;&amp;gt;Posts&amp;lt;/h1&amp;gt;
  { %- if strapi.collections.posts.size &amp;gt; 0 -% }
  &amp;lt;ul class=&quot;post-list&quot;&amp;gt;
    { %- for post in strapi.collections.posts -% }
    &amp;lt;li&amp;gt;
      &amp;lt;span class=&quot;post-meta&quot;&amp;gt; by &amp;lt;/span&amp;gt;
      &amp;lt;h3&amp;gt;
        &amp;lt;a class=&quot;post-link&quot; href=&quot;&quot;&amp;gt;
          
        &amp;lt;/a&amp;gt;
      &amp;lt;/h3&amp;gt;
      &amp;lt;!-- Display an excerpt of the article --&amp;gt;
      &amp;lt;p&amp;gt;
&amp;lt;/p&amp;gt;
    &amp;lt;/li&amp;gt;
    { %- endfor -% }
  &amp;lt;/ul&amp;gt;
  { %- endif -% }
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有个地方需要注意的是，在我们如上配置了之后，试着启动 Jekyll 项目时，可能会发现有个报错: &lt;code class=&quot;highlighter-rouge&quot;&gt;The Strapi server sent a error with the following status: 404. Please make sure it is correctly running.&lt;/code&gt;。感谢&lt;a href=&quot;https://stackoverflow.com/questions/54188789/jekyll:-and-strapi-liquid-exception-please-make-sure-strapi-server-is-correctly&quot;&gt;这里提供了帮助&lt;/a&gt;，试着把 Jekyll 和插件版本升级之后就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;gem &quot;jekyll&quot;, &quot;~&amp;gt; 3.8.5&quot;
[...]
group :jekyll_plugins do
  gem &quot;jekyll-feed&quot;, &quot;~&amp;gt; 0.12&quot;
  # github 这里的参数确保了最新修复 bug 的版本，而这个 bug 就是 Can't convert fixnum into String
  gem 'jekyll-strapi', github: 'strapi/jekyll-strapi'
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这些步骤我们其实还只是配置了首页，在我们能够正常访问到 strapi api 获取数据的前提下，我们接下来要为他们创建详情页，首先我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt; 目录下新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;post.html&lt;/code&gt; 来创建模板，配置项我们需要稍作修改:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;# _config.yml
strapi:
  # Your API endpoint (optional, default to http://localhost:1337)
  endpoint: http://localhost:1337
  # Collections, key is used to access in the strapi.collections
  # template variable
  collections:
    # Example for a &quot;posts&quot; collection
    posts:
      # Collection name (optional). Used to construct the url requested. Example: type `foo` would generate the following url `http://localhost:1337/foo`.
      type: posts
      # Permalink used to generate the output files (eg. /posts/:id).
      permalink: /posts/:slug/
      layout: post.html
      # Generate output files or not (default: false)
      output: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到只是新增了 layout 和 output 选项，就是为了要让 Jekyll 利用指定模板自动去为 post 生成新的详情页。重启 Jekyll 项目后，我们可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 目录下看到自动生成的新目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;posts&lt;/code&gt;，里面就包含了自动生成的页面。这样之后，我们就可以访问详情页啦:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.strapi.io/content/images/2018/04/Screen-Shot-2018-04-24-at-22.42.52.png&quot; alt=&quot;strapi posts&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上只是列举一些关键步骤，更多的细节和配置可以直接&lt;a href=&quot;https://strapi.io/blog/building-a-static-website-using-jekyll-and-strapi&quot;&gt;参考这篇文档&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;参考连接&quot;&gt;参考连接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://snipcart.com/blog/jamstack&quot;&gt;New to JAMstack? Everything You Need to Know to Get Started&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://css-tricks.com/what-is-a-headless-cms/&quot;&gt;What is a Headless CMS?&lt;/a&gt; By Chris Coyier&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://strapi.io/blog/building-a-static-website-using-jekyll-and-strapi&quot;&gt;Building a static blog using Jekyll and Strapi&lt;/a&gt; By Pierre Burgy&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="html" /><summary type="html">JAMstack</summary></entry><entry><title type="html">PM2 自动化部署</title><link href="http://localhost:2333/2020/01/19/pm2-deploy.html" rel="alternate" type="text/html" title="PM2 自动化部署" /><published>2020-01-19T17:47:00+08:00</published><updated>2020-01-19T17:47:00+08:00</updated><id>http://localhost:2333/2020/01/19/pm2-deploy</id><content type="html" xml:base="http://localhost:2333/2020/01/19/pm2-deploy.html">&lt;h1 id=&quot;pm2-自动化部署&quot;&gt;PM2 自动化部署&lt;/h1&gt;

&lt;h2 id=&quot;什么是-pm2&quot;&gt;什么是 PM2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/&quot;&gt;&lt;strong&gt;PM2&lt;/strong&gt;&lt;/a&gt; 是一个 node 后台进程管理工具，你可以对进程进行 start、stop、restart 或者 delete 等操作，还可以支持性能监控、负载均衡等功能，同类型的还有 &lt;a href=&quot;https://github.com/foreversd/forever&quot;&gt;&lt;strong&gt;forever&lt;/strong&gt;&lt;/a&gt; 等:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;npm install pm2 -g
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Feature&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Forever&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;PM2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Keep Alive&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Coffeescript&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Log aggregation&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;API&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Terminal monitoring&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Clustering&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JSON configuration&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;PM2 is daemon process manager that will help you manage and keep your application online ✅&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 启动一个 node 程序
pm2 start index.js
# 启动并取别名
pm2 start app_h5/bin/www --name application1
# 在文件改变的时候会重新启动程序
pm2 start index.js --watch

# 中止进程，指定进程 id 或名称，
pm2 stop 0

# 删除进程，all 则删除所有
pm2 delete 0

# 查看详情
pm2 describe 0

# 查看进程的资源消耗情况
pm2 monit

# 重启进程，也可用 restart
# Use reload instead of restart for 0-seconds downtime reloads
# restart 是先 kill 然后重启，而 reload 反之，故不会停机
pm2 reload 0

# 查看日志
pm2 logs 0

# 集群 cluster 启动 - 负载均衡
# -i 表示 number-instances 实例数量
# max 表示 PM2 将自动检测可用 CPU 的数量 可以自己指定数量
pm2 start start.js -i max

# 查看监控界面，即 pm2 list
pm2 l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/unitech/pm2/master/pres/pm2-list.png&quot; alt=&quot;pm2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更新 pm2 的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 保存当前进程状态
pm2 save
# 全局安装
npm i -g pm2
# pm2 update is necessary in order to refresh the PM2 daemon
pm2 update
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;pm2 save&lt;/code&gt; 的用法: pm2 save takes a snapshot of your currently running Node applications. You can then restore these applications using &lt;code class=&quot;highlighter-rouge&quot;&gt;pm2 resurrect&lt;/code&gt;. This is useful because it means you don’t have to manually restart each application when you restart pm2 (such as a machine reboot). Instead, you can just have a script that calls pm2 resurrect and it’ll start up all the Node apps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;自动化部署&quot;&gt;自动化部署&lt;/h2&gt;

&lt;p&gt;一般情况下，我们项目部署在服务器上，但是有个问题，就是每次要更新的话必须在服务器上去操作，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;pm2 reload&lt;/code&gt; 重启该进程，这样显然比较麻烦，因此我们可以借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;pm2 deploy&lt;/code&gt; 来进行自动化部署。具体可以参照 pm2 官方文档 &lt;a href=&quot;https://pm2.keymetrics.io/docs/usage/deployment/&quot;&gt;Deployment 一节&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;1、 Generate a sample &lt;code class=&quot;highlighter-rouge&quot;&gt;ecosystem.json&lt;/code&gt; file that lists the processes and the deployment environment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;pm2 ecosystem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动会创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;ecosystem.json&lt;/code&gt; 文件，当然也支持 yaml 配置文件，然后在对应位置自定义即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;{
  // Applications part
  &quot;apps&quot; : [{
    &quot;name&quot;      : &quot;API&quot;,
    &quot;script&quot;    : &quot;app.js&quot;,
    &quot;env&quot;: {
      &quot;COMMON_VARIABLE&quot;: &quot;true&quot;
    },
    // Environment variables injected when starting with --env production
    // http://pm2.keymetrics.io/docs/usage/application-declaration/#switching-to-different-environments
    &quot;env_production&quot; : {
      &quot;NODE_ENV&quot;: &quot;production&quot;
    }
  },{
    &quot;name&quot;      : &quot;WEB&quot;,
    &quot;script&quot;    : &quot;web.js&quot;
  }],
  // Deployment part
  // Here you describe each environment
  &quot;deploy&quot; : {
    &quot;production&quot; : {
      &quot;user&quot; : &quot;node&quot;,
      // Multi host is possible, just by passing IPs/hostname as an array
      &quot;host&quot; : [&quot;212.83.163.1&quot;, &quot;212.83.163.2&quot;, &quot;212.83.163.3&quot;],
      // Branch
      &quot;ref&quot;  : &quot;origin/master&quot;,
      // Git repository to clone
      &quot;repo&quot; : &quot;git@github.com:repo.git&quot;,
      // Path of the application on target servers
      &quot;path&quot; : &quot;/var/www/production&quot;,
      // Can be used to give options in the format used in the configura-
      // tion file.  This is useful for specifying options for which there
      // is no separate command-line flag, see 'man ssh'
      // can be either a single string or an array of strings
      &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;,
      // To prepare the host by installing required software (eg: git)
      // even before the setup process starts
      // can be multiple commands separated by the character &quot;;&quot;
      // or path to a script on your local machine
      &quot;pre-setup&quot; : &quot;apt-get install git&quot;,
      // Commands / path to a script on the host machine
      // This will be executed on the host after cloning the repository
      // eg: placing configurations in the shared dir etc
      &quot;post-setup&quot;: &quot;ls -la&quot;,
      // Commands to execute locally (on the same machine you deploy things)
      // Can be multiple commands separated by the character &quot;;&quot;
      &quot;pre-deploy-local&quot; : &quot;echo 'This is a local executed command'&quot;
      // Commands to be executed on the server after the repo has been cloned
      &quot;post-deploy&quot; : &quot;npm install &amp;amp;&amp;amp; pm2 startOrRestart ecosystem.json --env production&quot;
      // Environment variables that must be injected in all applications on this env
      &quot;env&quot;  : {
        &quot;NODE_ENV&quot;: &quot;production&quot;
      }
    },
    &quot;staging&quot; : {
      &quot;user&quot; : &quot;node&quot;, // 登录用户名
      &quot;host&quot; : &quot;212.83.163.1&quot;, // 要部署的目标服务器 ip/域名
      &quot;ref&quot;  : &quot;origin/master&quot;, // 用于部署代码时的分支
      &quot;repo&quot; : &quot;git@github.com:repo.git&quot;, // git 仓库地址
      &quot;path&quot; : &quot;/var/www/development&quot;, // 在目标服务器上部署的文件目录地址
      &quot;ssh_options&quot;: [&quot;StrictHostKeyChecking=no&quot;, &quot;PasswordAuthentication=no&quot;],
      &quot;post-deploy&quot; : &quot;pm2 startOrRestart ecosystem.json --env dev&quot;, // 部署后启动的脚本
      &quot;env&quot;  : {
        &quot;NODE_ENV&quot;: &quot;staging&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、Be sure that you have the public &lt;strong&gt;ssh key&lt;/strong&gt; on your local machine&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;ssh-keygen -t rsa
ssh-copy-id node@myserver.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt; 自动生成公钥和私钥，&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-copy-id&lt;/code&gt; 命令将公钥传送到远端服务器，可以查看&lt;a href=&quot;http://localhost:2333/2019/02/03/linux-ssh-rz-sz.html#身份认证&quot;&gt;之前这篇博客&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、Now initialize the remote folder with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 首次部署，该命令会在远端服务器上创建文件目录
pm2 deploy &amp;lt;configuration_file&amp;gt; &amp;lt;environment&amp;gt; setup

# demo
pm2 deploy ecosystem.json production setup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、Deploy your code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 再次部署，会上传项目代码，并用 PM2 启动
# 以后都用此命令进行更新代码和部署即可
pm2 deploy ecosystem.json production
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：本地和服务器确保都安装 PM2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然 deploy 命令也支持其他一些参数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;# pm2 deploy help

setup                run remote setup commands
update               update deploy to the latest release
revert [n]           revert to [n]th last deployment or 1
curr[ent]            output current release commit
prev[ious]           output previous release commit
exec|run &amp;lt;cmd&amp;gt;       execute the given &amp;lt;cmd&amp;gt;
list                 list previous deploy commits
[ref]                deploy to [ref], the &quot;ref&quot; setting, or latest tag
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# Update remote version
pm2 deploy production update

# Revert to -1 deployment
pm2 deploy production revert 1

# execute command on remote machines
pm2 deploy production exec &quot;pm2 reload all&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;与-nginx-的配合使用&quot;&gt;与 Nginx 的配合使用&lt;/h2&gt;

&lt;p&gt;下面是一个官网的 demo，Nginx 将 80 端口代理到 3001 端口，更多可以参照 &lt;a href=&quot;http://localhost:2333/2019/01/30/nginx.html&quot;&gt;Nginx 这篇博客&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;upstream my_nodejs_upstream {
  server 127.0.0.1:3001;
  keepalive 64;
}

server {
  listen 443 ssl;

  server_name www.my-website.com;
  ssl_certificate_key /etc/ssl/main.key;
  ssl_certificate     /etc/ssl/main.crt;

  location / {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $http_host;

    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;

    proxy_pass http://my_nodejs_upstream/;
    proxy_redirect off;
    proxy_read_timeout 240s;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;nodemon--supervisor&quot;&gt;nodemon / supervisor&lt;/h2&gt;

&lt;p&gt;两种常用于开发环境监听文件改动并重启服务的方式，还可以搭配 &lt;strong&gt;&lt;a href=&quot;https://browsersync.io/&quot;&gt;Browsersync&lt;/a&gt;&lt;/strong&gt; 实现客户端自动刷新:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/remy/nodemon&quot;&gt;nodemon&lt;/a&gt;&lt;/strong&gt; - 占用内存更少，易扩展&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/Supervisor/supervisor&quot;&gt;supervisor&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;nodemon index.js

# 也可省略写法，默认找 index.js
nodemon
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="后端" /><category term="Server" /><summary type="html">PM2 自动化部署</summary></entry><entry><title type="html">2019 前端大事件回顾</title><link href="http://localhost:2333/2019/12/23/js-2019.html" rel="alternate" type="text/html" title="2019 前端大事件回顾" /><published>2019-12-23T15:59:00+08:00</published><updated>2019-12-23T15:59:00+08:00</updated><id>http://localhost:2333/2019/12/23/js-2019</id><content type="html" xml:base="http://localhost:2333/2019/12/23/js-2019.html">&lt;h1 id=&quot;2019-前端大事件回顾&quot;&gt;2019 前端大事件回顾&lt;/h1&gt;

&lt;h2 id=&quot;2019-前端大事件回顾-1&quot;&gt;2019 前端大事件回顾&lt;/h2&gt;

&lt;p&gt;本篇文章摘自 &lt;a href=&quot;https://levelup.gitconnected.com/a-recap-of-frontend-development-in-2019-1e7d07966d6c&quot;&gt;A Recap of Frontend Development in 2019 By Trey Huffine&lt;/a&gt;，翻译来自头条的&lt;a href=&quot;https://www.toutiao.com/a6773458884121068035/?tt_from=weixin&amp;amp;utm_campaign=client_share&amp;amp;wxshare_count=1&amp;amp;timestamp=1577080864&amp;amp;app=news_article&amp;amp;utm_source=weixin&amp;amp;utm_medium=toutiao_android&amp;amp;req_id=2019122314010401012903513827E86EA0&amp;amp;group_id=6773458884121068035&quot;&gt;弯月&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;前端在生产和开发中占据着越来越重要的地位，PC 端、手机端、桌面端、智能手表端等等设备都离不开前端的身影。本文将围绕框架、编程语言、工具、React、Vue 等方面，全面回顾 2019 年前端与 Web 开发的大事。&lt;/p&gt;

&lt;h2 id=&quot;npm-dowloads&quot;&gt;NPM Dowloads&lt;/h2&gt;

&lt;p&gt;React 再次荣登前端流行库的榜首，且用户的数量仍在增长，而 jQuery 出乎意料地保住了第二名的位置。紧随其后的是 Angular 和 Vue，一大批饱含热情的开发人员为二者奠定了强大的用户基础。去年，&lt;a href=&quot;https://svelte.dev&quot;&gt;&lt;strong&gt;Svelte&lt;/strong&gt;&lt;/a&gt; 框架收到了很多关注，但还在为获得更多采用而努力，它的三个特点是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要编写的代码量更少&lt;/li&gt;
  &lt;li&gt;抛弃虚拟 DOM&lt;/li&gt;
  &lt;li&gt;真正的响应式编程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/4376/1*n2P26JhioTkWaRYBDzHhGA.png&quot; alt=&quot;npm downloads&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于前端框架的比较，可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2019/10/19/ng-react-vue-comparison.html&quot;&gt;Angular、React 和 Vue&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;webassembly&quot;&gt;WebAssembly&lt;/h2&gt;

&lt;p&gt;经过一年的平静之后，12月初 &lt;a href=&quot;https://webassembly.org&quot;&gt;&lt;strong&gt;WebAssembly&lt;/strong&gt;&lt;/a&gt; 出现了一些重大新闻：W3C 联盟正式推荐其为 Web 语言。自 2017 年发布以来，WebAssembly 引起了广泛的关注，而且采用量也迅速增长。在过去的几年中，我们看到了 WebAssembly 建立了 1.0 规范，而且所有主流浏览器都开始支持 WebAssembly。2019 年，还有一则 WebAssembly 的新闻：字节码联盟（Bytecode Alliance）成立，该联盟旨在通过协作实施标准和提出新标准，以完善 WebAssembly 在浏览器之外的生态。&lt;/p&gt;

&lt;p&gt;我们仍在等待 WebAssembly 真正站稳脚跟，并大面积普及。随着 WebAssembly 每次的更新，我们离这个目标越来越近。毫无疑问，W3C 的声明是让各个公司合法使用 WebAssembly 的重要一步，我们需要继续降低使用 WebAssembly 的入门门槛，让其更方便构建产品。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;WebAssembly 是经过编译器编译之后的代码，体积小、起步快。在语法上完全脱离 JavaScript，同时具有沙盒化的执行环境。具体可以&lt;a href=&quot;https://juejin.im/post/5be293daf265da616c65157e&quot;&gt;参考这一篇博客&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;typescript&quot;&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;2019年是 TypeScript 之年。TypeScript 不仅成为了在 JS 代码中添加类型时的最佳选择，而且许多开发人员在个人项目和工作中对它的喜爱超过了普通的 JavaScript。在 2019 年初发布的 StackOverflow 调查中，TypeScript 与 Python 并列第二，成为了最受欢迎的语言，仅次于 Rust:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1856/1*svNT2igTYXqcz7A8GvztRA.png&quot; alt=&quot;most wanted language&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TypeScript 与所有主流文本编辑器的集成为 Web 开发人员提供了更好的开发体验。JavaScript 开发人员将 TypeScript 视为一种工具：它可以减少错误，同时由于其提供的文档说明类型和对象接口，代码阅读起来更为轻松。值得注意的是，2019 年 TypeScript 的 NPM 下载流行度超过了 React。此外，它的下载量也远远超过了 Flow 和 Reason 等竞争对手。&lt;/p&gt;

&lt;p&gt;Facebook 维护着流行的测试库 Jest 和 Flow，后者是 TypeScript 的竞争对手。2019 年初，Facebook 大胆声明 Jest 将放弃 Flow，转投 TypeScript 的怀抱。这进一步表明 TypeScript 已成为输入 JavaScript 代码的标准选择，2020 年及以后 TypeScript 的使用会进一步增加。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;具体使用方式可以参考之前的两篇博客 - &lt;a href=&quot;http://localhost:2333/2019/02/26/ts-profile.html&quot;&gt;TypeScript 简介&lt;/a&gt;和 &lt;a href=&quot;http://localhost:2333/2019/05/20/ts-advanced.html&quot;&gt;TypeScript 进阶&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;react--react-hooks&quot;&gt;React &amp;amp; React hooks&lt;/h2&gt;

&lt;p&gt;虽然 Vue 和 Angular 拥有大一批饱含热情的用户，Vue 在 GitHub 上的给星数甚至超过了 React，但在个人和专业项目中，React 继续保持领先地位。2018 年末，React 团队引入了钩子。2019 年，钩子吞噬了 React 世界，绝大多数开发人员都将其作为管理状态和组件生命周期的首选方式。2019 年中有关钩子的文章层出不穷，这方面的模式开始走向稳固，重要的 React 包都开始利用自定义钩子来导出其函数库的功能。钩子提供了一种通过简洁的语法管理功能组件的状态和生命周期的方法。另外，React 提供了构建自定义钩子的功能，我们可以利用这个功能创建可重用的代码和共享的逻辑，而无需创建高阶组件或使用 render props。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 React hooks 的使用，可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2019/04/16/react-hooks.html&quot;&gt;React Hooks&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在发布了大量钩子之后，React 团队随后将工作重点转移到通过提供更多工具来改善开发人员的工作。实际上，开发人员的经验是 2019 年 React 大会的主要主题。React 大会的主要发言人及 React 团队经理 Tom Occhino 表示，开发人员的经验主要依赖于三个方面：降低入门的门槛、提高生产率和改善扩展能力。下面让我们来看一看为了支持这三方面，React 团队发布了哪些功能和计划:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全新版本的 React DevTools&lt;/li&gt;
  &lt;li&gt;全新的 React 性能分析工具&lt;/li&gt;
  &lt;li&gt;创建了 React App v3&lt;/li&gt;
  &lt;li&gt;测试工具的更新&lt;/li&gt;
  &lt;li&gt;Suspense&lt;/li&gt;
  &lt;li&gt;并发模式（即将推出）&lt;/li&gt;
  &lt;li&gt;Facebook 使用的 CSS-in-JS（即将推出）&lt;/li&gt;
  &lt;li&gt;渐进/选择性页面 hydration（即将进行）&lt;/li&gt;
  &lt;li&gt;React 核心层面支持可访问性（即将发布）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vue-version-3-release&quot;&gt;Vue version 3 release&lt;/h2&gt;

&lt;p&gt;Vue 的采用率可能尚未达到最高，但其拥有一大批热情高涨的用户。Vue 借鉴了 React 和 Angular 的精华，同时还进行了简化。Vue 最大的新闻是即将发布的 3.0 版本，alpha 版有望在第四季度末发布。2019 年，Vue 2.x 仅在年初收到了一些更新，因为大多数的工作都投入到了 v3 版本中。&lt;/p&gt;

&lt;p&gt;虽然今年发布的版本不多，但这并不意味着 Vue 没有太多大事发生。当 Evan You 向大众征集有关 v3 的建议时，这个版本的变动在社区引发了广泛的争论，请见 Reddit 和 Hacker News 等网站。激怒 Vue 开发人员的关键问题是对框架API 的全面改革。但是，在强烈反对之后，有人指出此次 API 的变更与 Vue 2 完全兼容。虽然许多开发人员仍在关注该版本的发行，但他们声称这些改动可能会让他们考虑 Svelte，因为他们担心 Vue 与 React 太相像。尽管社区中仍有许多人对此表示关注，但在他们等待发布的过程中，喧杂声似乎已平息。除了上述有争论的变更外，Vue 3 还包含其他重大变化:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;组合 API&lt;/li&gt;
  &lt;li&gt;全局 mount / 配置 API 的改动&lt;/li&gt;
  &lt;li&gt;Fragments&lt;/li&gt;
  &lt;li&gt;时间切片支持（实验性）&lt;/li&gt;
  &lt;li&gt;多个 v 模型&lt;/li&gt;
  &lt;li&gt;Portal&lt;/li&gt;
  &lt;li&gt;新的自定义指令 API&lt;/li&gt;
  &lt;li&gt;反应性的&lt;/li&gt;
  &lt;li&gt;虚拟 DOM 重写&lt;/li&gt;
  &lt;li&gt;静态 props hoising&lt;/li&gt;
  &lt;li&gt;钩子 API（实验性）&lt;/li&gt;
  &lt;li&gt;slot 生成优化（父和子组件的单独渲染）&lt;/li&gt;
  &lt;li&gt;更好地支持 TypeScript&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 Vue 的使用，可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2018/06/12/vue-profile.html&quot;&gt;Vue 简介&lt;/a&gt;和 &lt;a href=&quot;http://localhost:2333/2018/07/20/vue-reactivity-in-depth.html&quot;&gt;Vue 深入响应式原理&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;angular-v8--v9&quot;&gt;Angular v8 &amp;amp; v9&lt;/h2&gt;

&lt;p&gt;Angular 刚愎自用的哲学为它赢得了庞大的用户群。由于 Angular 是一个“霸道总裁”式的框架，因此它要求开发人员以 Angular 的方式行事，同时也为开发人员提供了所有必要的工具。这可以避免许多有关引入哪些库和依赖项的争论，而这些争议是 React 应用构建团队中可能需要面对的问题。它还要求开发人员使用 TypeScript 编写应用程序。由于大多数抉择已被确立，因此各个公司将其视为一个不错的选择，因为开发人员可以专注于构建产品，而不必花费时间考虑软件包。&lt;/p&gt;

&lt;p&gt;2019年，Angular 发布了版本 8，并且还发布了一个新的渲染器/编译流水线——名叫 &lt;strong&gt;Ivy&lt;/strong&gt;。Ivy 最大的好处在于构建的包更小，但它提供了许多其他巨大的改进。目前，Ivy 是 Angular 9 之前的可选功能。版本 8 中值得注意的更新包括:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现代 JavaScript 的差分加载&lt;/li&gt;
  &lt;li&gt;默认支持的 Ivy 预览&lt;/li&gt;
  &lt;li&gt;Angular Router 的向后兼容性&lt;/li&gt;
  &lt;li&gt;改进后的 Web Worker 包&lt;/li&gt;
  &lt;li&gt;默认支持的使用情况分享&lt;/li&gt;
  &lt;li&gt;依赖关系更新&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2019 年 12 月期间，Angular 团队为版本 9 的发布做好了准备，该版本将于年底或 2020 年初正式发布。Angular 9 的最大变化是 Ivy 成为了标准渲染器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 Angular 的使用，可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2018/04/26/ng-two-way-data-binding.html&quot;&gt;双向数据绑定的实现&lt;/a&gt; 和 &lt;a href=&quot;http://localhost:2333/2018/06/10/ng-faq.html&quot;&gt;Angular FAQ&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;a11y-and-i18n&quot;&gt;a11y and i18n&lt;/h2&gt;

&lt;p&gt;随着 web 的快速发展，我们的应用逐渐向以下两方面靠拢:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;可访问性&lt;/strong&gt;（Accessibility，简称 A11y）- 让尽可能多的人使用你的网站，传统上我们认为这是关于残疾人的，但实际上它也涵盖了其他群体，比如使用移动设备的人群，那些网络连接缓慢的人群&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;国际化&lt;/strong&gt;（Internationalization，简称 i18n）- 是对应用程序、规范文档的设计和开发，以确保这些应用和规范等可以更好更容易地适应不同文化、地区、语言的用户&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Accessibility 被简称为 A11y 是因为首字母 A 和最后一个字母 y 之间有 11 个字母。同理的有 i18n，和 k8s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;es2019--es2020&quot;&gt;ES2019 &amp;amp; ES2020&lt;/h2&gt;

&lt;p&gt;今年，ECMAScript（JavaScript 的规范）也发表了年度更新，且 ES2019 版本中添加了如下新功能:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Object.fromEntries()&lt;/li&gt;
  &lt;li&gt;String.trimStart()和 String.trimEnd()&lt;/li&gt;
  &lt;li&gt;JSON.stringify中 unicode 的处理改善&lt;/li&gt;
  &lt;li&gt;Array.flat()&lt;/li&gt;
  &lt;li&gt;Array.flatMap()&lt;/li&gt;
  &lt;li&gt;try/catch 绑定&lt;/li&gt;
  &lt;li&gt;Symbol.description&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;尽管 ES2019 进行了一些重大更新，但即将到来的 ES2020 拥有 ES6 / ES2015 以来最令人期待的功能:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;私有类属性&lt;/li&gt;
  &lt;li&gt;Optional Chaining - obj.field?.maybe?.exists&lt;/li&gt;
  &lt;li&gt;nullish coalescing - item ?? ‘use this only if item is null/undefined’&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;BigInts&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;flutter--react-native&quot;&gt;Flutter &amp;amp; React Native&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;React Native&lt;/strong&gt; 推出两年后，&lt;strong&gt;Flutter&lt;/strong&gt; 才发布，但 Flutter 的发展非常迅速。在 Github 上的 star 数目与 React Native 已相当，照此情形 Flutter 很快就过超越 React Native。鉴于 Flutter 没有开发社区的推波助澜（React Web 开发人员推动了 React Native 的发展），所以如此迅速的发展实在令人刮目相看。Flutter 正在努力打造最优秀的的跨平台移动框架:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1872/1*VJ1owQ3o4mStIXvoOgIayQ.jpeg&quot; alt=&quot;flutter&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nodejs--js--openjs&quot;&gt;NodeJS + JS –&amp;gt; OpenJS&lt;/h2&gt;

&lt;p&gt;为了支持 JavaScript 生态系统并加速语言的发展，Node.js 基金会与 JS 基金会合并成立了 &lt;strong&gt;OpenJS&lt;/strong&gt; 基金会。该基金会表示，希望通过中立的组织推进协作和发展，如今他们托管了 31 个开源项目，包括 Node、jQuery 和 Webpack。这一举动为整个 JS 社区带来了积极的影响，并得到了 Google、IBM 和微软等大公司的支持。&lt;/p&gt;

&lt;p&gt;今年，Node 发布了版本 12，该版本遵循长期支持（LTS）策略，可以一直到 2023 年 4 月。Node12 提供了许多新功能、安全更新和性能改进。一些值得注意的更新包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;import/export&lt;/code&gt; 语句的原生支持、私有类属性、兼容 V8 Engine 7.4、对 TLS 1.3 的支持以及其他诊断工具。&lt;/p&gt;

&lt;h2 id=&quot;静态网站--jamstack&quot;&gt;静态网站 &amp;amp; JAMstack&lt;/h2&gt;

&lt;p&gt;随着 &lt;a href=&quot;https://www.gatsbyjs.org&quot;&gt;&lt;strong&gt;Gatsby&lt;/strong&gt;&lt;/a&gt; 等框架利用率的提高，Netlify 等负责托管静态网站的公司也得到了快速增长，于是无数 headless CMS 公司相继出现，静态网站证明了自己是 Web 不可或缺的一部分。静态网站将旧网站与新兴的工具、库和更新结合在一起，提供了无与伦比的体验。我们能够使用 React 等现代库来构建我们的网站，然后在构建时将它们编译成静态 HTML 页面。由于所有页面都是预先构建的，因此服务器不需要花费时间利用请求中的数据渲染页面，这些页面可以立即提供，并利用 CDN 中全局缓存的优势，尽可能迅速地将页面提供给用户。&lt;/p&gt;

&lt;p&gt;静态网站使用的一种流行的编程模式是 &lt;a href=&quot;https://jamstack.org&quot;&gt;&lt;strong&gt;JAMstack&lt;/strong&gt;&lt;/a&gt;。这是一种结合了静态/ SPA 的方式，这些页面都是静态提供的，但是一旦进入客户端，就会被当成 SPA —— 通过 API 和用户交互来推进 UI 的状态。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于什么是 JAMstack 可以&lt;a href=&quot;http://localhost:2333/2020/01/30/jamstack.html&quot;&gt;参考这篇博客&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pwa&quot;&gt;PWA&lt;/h2&gt;

&lt;p&gt;虽然静态网站的速度无人能及，但也并非适合所有应用，另一个绝佳的选择是 &lt;strong&gt;PWA&lt;/strong&gt;（渐进式 Web 应用程序）。我们可以利用 PWA 在浏览器中缓存资源，以确保页面的立即响应与离线支持。此外，在 PWA 方式中，后台工作人员还可以提供推送通知等原生功能。甚至有人声称 PWA 可以取代原生移动应用。无论最终结果将如何，毫无疑问，在很长一段时间内 PWA 将影响各大公司构建产品的主要方式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 PWA 的使用可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2019/04/07/progressive-web-app.html&quot;&gt;PWA 简介&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;frontend-tooling&quot;&gt;Frontend tooling&lt;/h2&gt;

&lt;p&gt;近几年来，前端开发人员总是抱怨厌倦了 JavaScript，但是我们也慢慢看到，开源项目维护人员的不懈努力减轻了人们对 JavaScript 的厌倦。以前，如果我们想构建 SPA，则必须利用 Bower 或 NPM 引入依赖关系，还要掌握如何利用 Browserify 或 Webpack 进行编译，从零开始编写 Express 服务器，并在库发生更新时维护我们的应用。多年来，我们经历了很多痛苦，但如今我们造就了最活跃、最发达的软件包生态系统。我们有很多工具可以帮助我们抽象化构建应用程序中最痛苦的部分：创建 React 应用、Vue CLI、Angular CLI、用于静态网站的 Gatsby、用于 React Native 移动应用的 Expo、用于 SSR 应用程序的 Next / Nuxt、用于创建服务器的生成器、免于为 GraphQL 编写服务器的 Hasura、使用 GraphQL 代码生成器自动生成 TypeScript 类型、Webpack不断得到简化等等，我们总能找到工具帮我们减轻繁重的工作。&lt;/p&gt;

&lt;h2 id=&quot;graphql&quot;&gt;GraphQL&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;GraphQL&lt;/strong&gt; 有望解决传统的基于 REST 的应用程序面临的许多问题。GraphQL 很快就获得了开发人员的喜爱，而各大科技公司也纷纷开始采用它。几年前，GitHub 用 GraphQL 编写了它的最新 API，许多其他组织也在做出了同样的变革。GraphQL 应用程序是数据驱动的（不是端点驱动），因此客户端可以声明所需的确切数据，从服务器接收相应的 JSON 响应。GraphQL API 提供的文档记录了所有的数据及其类型，帮助开发人员更全面地了解 API。由于 GraphQL API 提供了完全类型化的架构，因此它也可以与 TypeScript 应用程序很好地集成。GraphQL 可以通过 GraphQL Code Generator 等工具读取客户端代码中的查询，并将其与架构进行匹配，以提供在整个应用程序中流动的 TypeScript 类型。在过去的一年中，GraphQL 的下载量增加了一倍，而 Apollo 也开始朝着使用最广泛的框架迈进:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/4364/1*Ywtd-nIhwUv8B4oFsU-QqQ.png&quot; alt=&quot;graphql&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 graphQL 和 REST 的介绍可以参考之前这片博客 - &lt;a href=&quot;http://localhost:2333/2018/03/01/http-rest-graphql.html&quot;&gt;REST or GraphQL&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;css-in-js&quot;&gt;CSS in JS&lt;/h2&gt;

&lt;p&gt;Web开发的发展大有让 JavaScript 一统天下的趋势，CSS-in-JS 的采用充分体现了这一点，因为这些CSS样式都是使用 JavaScript 字符串创建的。在这种方式下，我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;import/export&lt;/code&gt;，利用常规的 JavaScript 语法共享样式和依赖项。由于 CSS-in-JS 组件可以将 props 插入到样式字符串中，因此简化了动态样式。如前所述，Facebook 甚至认为 CSS-in -JS 可能会成为前端的未来，并即将发布自己的库。&lt;code class=&quot;highlighter-rouge&quot;&gt;styled-components&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;emotion&lt;/code&gt; 是 CSS-in-JS 的两个主要库，而且 2019 年 emotion 的下载超过了 styled-components。从增长幅度来看，这两个库遥遥领先于其他 CSS-in-JS 库，而且它们还将持续快速增长:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/4380/1*MaV6nzniinnzEwoNvb5_7g.png&quot; alt=&quot;css in js&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 CSS in JS 的介绍可以参考之前的博客 - &lt;a href=&quot;http://localhost:2333/2019/04/13/css-in-js.html&quot;&gt;CSS In JS&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;webpack-5&quot;&gt;webpack 5&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Webpack&lt;/strong&gt; 已成为所有现代 JavaScript 工具链的核心组件，而且也是最常用的构建工具。Webpack 一直在提高性能和可用性，努力为开发人员提供更好的工具。Webpack 5 主要侧重于以下几个方面:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过持久缓存提高构建性能&lt;/li&gt;
  &lt;li&gt;通过更好的算法和默认值来改善长期缓存&lt;/li&gt;
  &lt;li&gt;清理内部模式，同时不会引发任何重大变动&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;chrome&quot;&gt;Chrome&lt;/h2&gt;

&lt;p&gt;Chrome 快速迭代的步伐从未停歇，他们正在迅速为 Web 和开发工具添加新功能。2019 年，Chrome 发布了 7 个稳定版本。对于 IE 及其后续的 Edge 就是个笑话，它们令开发人员苦不堪言。这款浏览器在 Web 功能实现方面一直落后于他人，并且众所周知，为其编写跨浏览器兼容的代码简直就是灾难。为了赢得开发人员，微软决定选择使用 Google 的开源 Chromium 引擎。2019 年中期，这项变更已进入 beta 阶段。&lt;/p&gt;

&lt;h2 id=&quot;2020-年的预测&quot;&gt;2020 年的预测&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;随着代码拆分和 PWA 的进一步使用，性能仍然是 Web 最关键的方面。&lt;/li&gt;
  &lt;li&gt;WebAssembly 会越来越普及，并得到实际采用和应用于产品中。&lt;/li&gt;
  &lt;li&gt;新兴创业公司和新项目都会采用 GraphQL，而其他公司也会纷纷从 REST 向 GraphQL 迁移。&lt;/li&gt;
  &lt;li&gt;TypeScript 将成为新兴创业公司和项目的默认选择。&lt;/li&gt;
  &lt;li&gt;我们有望看到没有服务器且构建在区块链之上的真实应用，这会让 Web 更加开放。&lt;/li&gt;
  &lt;li&gt;CSS-in-JS可能取代普通的CSS，会成为默认的样式设置方式。&lt;/li&gt;
  &lt;li&gt;“无代码”应用越来越流行。随着AI的改进和应用抽象层的增加，构建应用程序会越来越容易。2020年，我们有望看到无需编写代码即可创建应用的重大转变。&lt;/li&gt;
  &lt;li&gt;Flutter 可能会取代 React Native，成为构建跨平台移动应用的最佳方式。&lt;/li&gt;
  &lt;li&gt;Svelte 将会用于更多实际项目。&lt;/li&gt;
  &lt;li&gt;Deno（Node 创建者构建的 TypeScript 运行时）将投入实际使用。&lt;/li&gt;
  &lt;li&gt;AR / VR 将取得巨大进步，其中包括使用 A-Frame、React VR 和 Google VR 等库，并改进浏览器中原生的 AR / VR 工具。&lt;/li&gt;
  &lt;li&gt;容器化（例如 Docker、Kubernetes）的影响在前端开发中越来越普遍。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://levelup.gitconnected.com/a-recap-of-frontend-development-in-2019-1e7d07966d6c&quot;&gt;A Recap of Frontend Development in 2019&lt;/a&gt; By Trey Huffine&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5be293daf265da616c65157e&quot;&gt;WebAssembly 完全入门 —— 了解 wasm 的前世今身&lt;/a&gt; By SH的全栈笔记&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://1024.com/a/354/一文看懂什么是jamstack&quot;&gt;一文看懂什么是 JAMstack&lt;/a&gt; By air&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="JavaScript" /><summary type="html">2019 前端大事件回顾</summary></entry><entry><title type="html">JSBridge</title><link href="http://localhost:2333/2019/12/19/js-bridge.html" rel="alternate" type="text/html" title="JSBridge" /><published>2019-12-19T19:53:00+08:00</published><updated>2019-12-19T19:53:00+08:00</updated><id>http://localhost:2333/2019/12/19/js-bridge</id><content type="html" xml:base="http://localhost:2333/2019/12/19/js-bridge.html">&lt;h1 id=&quot;jsbridge&quot;&gt;JSBridge&lt;/h1&gt;

&lt;h2 id=&quot;什么是-jsbridge&quot;&gt;什么是 JSBridge&lt;/h2&gt;

&lt;p&gt;想当年最开始工作的时候，就是做的移动端 hybrid 混合式开发，里面很重要的一环就是 JS 与原生 Native 的相互通信，而它就是我们今天要介绍的主人翁 - &lt;strong&gt;JSBridge&lt;/strong&gt;。顾名思义，它作为一座桥梁，连接了 JS 与 Native，让前端可以方便地调用原生的摄像头、视频等，而原生也可以接收前端发出的信息而作出相应的处理。准确来讲，它并不是一项技术，而是一套解决方案。在介绍 JSBridge 原理之前，我们先看看传统方式是怎么来使用的。以下主要摘自 &lt;a href=&quot;https://blog.csdn.net/xiangzhihong8/article/details/66970600&quot;&gt;JSBridge 深度剖析&lt;/a&gt;这篇博客:&lt;/p&gt;

&lt;h2 id=&quot;传统方式&quot;&gt;传统方式&lt;/h2&gt;

&lt;h3 id=&quot;js-调用-native&quot;&gt;JS 调用 Native&lt;/h3&gt;

&lt;p&gt;JS 调用 Native 主要是通过两种方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API 注入&lt;/li&gt;
  &lt;li&gt;URL Scheme&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;api-注入&quot;&gt;API 注入&lt;/h4&gt;

&lt;p&gt;注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JS 的 Context(window) 中注入对象或者方法，让 JS 调用时，直接执行相应的 Native 代码逻辑，这里也对应三个不同平台进行分析:&lt;/p&gt;

&lt;p&gt;1、 IOS(UIWebView)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// Native 中通过引入官方提供的 JavaScriptCore 库(iOS7 以上),然后可以将 api 绑定到 JSContext 上
// import &amp;lt;JavaScriptCore/JavaScriptCore.h&amp;gt;

JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

// 注册方法为 postBridgeMessage
context[@&quot;postBridgeMessage&quot;] = ^(NSArray&amp;lt;NSArray *&amp;gt; *calls) {
  // Native 逻辑
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到上面注册了一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;postBridgeMessage&lt;/code&gt; 的方法，因此我们可以在前端进行调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;window.postBridgeMessage(message)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;IOS7 才出现这种方式，在这之前，JS 无法直接调用 Native，只能通过 JSBridge 方式间接调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、 IOS(WKWebView)&lt;/p&gt;

&lt;p&gt;首先，&lt;strong&gt;WKWebView&lt;/strong&gt; 是 ios8 之后推行的，可以替代之前的 &lt;strong&gt;UIWebView&lt;/strong&gt; 控件，解决了很多性能和兼容上的问题，那么它又是怎么使用的呢:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;@interface WKWebVIewVC ()&amp;lt;WKScriptMessageHandler&amp;gt;

@implementation WKWebVIewVC

- (void)viewDidLoad {
  [super viewDidLoad];

  WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
  configuration.userContentController = [[WKUserContentController alloc] init];
  WKUserContentController *userCC = configuration.userContentController;
  // 注入对象 nativeBridge
  [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];

  WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];
  // ...
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
  if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) {
    NSLog(@&quot;前端传递的数据 %@: &quot;, message.body);
    // Native 逻辑
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到上面注册了一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nativeBridge&lt;/code&gt; 的对象，因此我们可以在前端进行调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;window.webkit.messageHandlers.nativeBridge.postMessage(message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、 Android&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;public class JavaScriptInterfaceDemoActivity extends Activity {
  private WebView Wv;

  @Override
  publicvoidonCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);

    Wv = (WebView)findViewById(R.id.webView);
    final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);

    // Android 容器允许 JS 脚本
    Wv.getSettings().setJavaScriptEnabled(true);
    // Android 容器设置侨连对象
    Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;);
    // ...
  }

  public class JavaScriptInterface {
    Context mContext;

    JavaScriptInterface(Context c) {
      mContext = c;
    }

    // 暴露出的接口
    @JavascriptInterface
    public void postMessage(String webMessage){
      // Native 逻辑
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到上面用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nativeBridge&lt;/code&gt; 设置了侨连对象，并且暴露出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage&lt;/code&gt; 接口，因此我们通过下面方式访问即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 前端调用 nativeBridge
window.nativeBridge.postMessage(message)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Android4.2(API17) 以上版本，暴露的接口要加上注解 &lt;code class=&quot;highlighter-rouge&quot;&gt;@JavascriptInterface&lt;/code&gt;，否则会找不到该方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 API17 以前，&lt;code class=&quot;highlighter-rouge&quot;&gt;addJavascriptInterface&lt;/code&gt; 是有风险的，黑客可以通过反编译获取 Native 注册的 JS 对象，然后在页面通过反射 Java 的内置静态类，获取一些敏感的信息和破坏&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;拦截-url-scheme&quot;&gt;拦截 URL Scheme&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;url scheme&lt;/strong&gt; 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的。具体来讲如果是系统的 url scheme，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;tel://136xxx5495&lt;/code&gt; ，则打开系统应用，否则看是否有 app 注册这种 scheme，有则打开对应 app，注意这种 scheme 必须原生 app 注册后才会生效:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;&amp;lt;!-- 普通的 url --&amp;gt;
https://host:port/path
&amp;lt;!-- url scheme - scheme 这里就相当于协议 --&amp;gt;
scheme://host:port/path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而我们通过拦截 url scheme，就可以达到传输数据的目的，进而实现两端的通信。在前端，一般是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;iframe.src&lt;/code&gt; 来发送 url scheme 请求，然后 Native 捕获后，根据定义好的协议，分析当前触发了哪种方法。相较于上面的 API 注入，它的适用性更广，IOS 和安卓都可兼容，但是请求可能会有一些耗时。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;iframe.src&lt;/code&gt; 不选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;locaiton.href&lt;/code&gt; ？因为如果通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;location.href&lt;/code&gt; 连续调用 Native，在 Native 层只能接收到最后一次请求，从而很容易丢失一些调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;native-调用-js&quot;&gt;Native 调用 JS&lt;/h3&gt;

&lt;p&gt;Native 调用 JS 相对较简单一些，只用去执行 JS 暴露出来的全局方法即可。&lt;/p&gt;

&lt;p&gt;1、IOS(UIWebView)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;[uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、IOS(WKWebView)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// completionHandler 会在 JS 方法执行完后执行
[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、Android&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果
webView.loadUrl(&quot;javascript:&quot; + javaScriptString);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 Kitkat 4.4 之后的版本，也可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;evaluateJavascript&lt;/code&gt; 方法实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;webView.evaluateJavascript(javaScriptString, new ValueCallback&amp;lt;String&amp;gt;() {
  @Override
  public void onReceiveValue(String value){
    // 可以拿到 JS 返回值
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsbridge-原理及简单实现&quot;&gt;JSBridge 原理及简单实现&lt;/h2&gt;

&lt;p&gt;有了上述的双端通信的基础通道，我们就可以基于此去构建一套易用的方法封装，解决一些兼容性或安全问题，更易于维护和扩展，一个简单的通信流程如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/0*i0r9tA8EGzSBwhAj.png&quot; alt=&quot;JSBridge&quot; /&gt;&lt;/p&gt;

&lt;p&gt;要实现 JSBridge，我们可以按以下步骤分析:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设计出一个 Native 与 JS 交互的全局桥对象&lt;/li&gt;
  &lt;li&gt;JS 如何调用 Native&lt;/li&gt;
  &lt;li&gt;Native 如何得知 api 被调用&lt;/li&gt;
  &lt;li&gt;Native 如何调用 JS&lt;/li&gt;
  &lt;li&gt;H5 中 api 方法的注册以及格式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、 &lt;strong&gt;设计出一个 Native 与 JS 交互的全局桥对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们首先要定义一个全局变量，并定义一些方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const JSBridge = window.JSBridge || (window.JSBridge = {})
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;registerHandler - 注册本地 JS 方法，注册后 Native 可通过 JSBridge 调用。调用后会将方法注册到本地变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;messageHandlers&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;callHandler - JS 调用原生开放的 api，调用后实际上还是本地通过 url scheme 触发。调用时会将回调 id  存放到本地变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;responseCallbacks&lt;/code&gt; 中&lt;/li&gt;
  &lt;li&gt;_handleMessageFromNative - 原生调用 JS 注册的方法，或者通知前端页面执行回调方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/db68a2b9154d16b09ce8046f369ae34199cf2f01.png&quot; alt=&quot;JSBridge props&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;JS 如何调用 Native&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其关键就在于 &lt;code class=&quot;highlighter-rouge&quot;&gt;callHandler&lt;/code&gt; 方法，实际执行了以下步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;判断是否有回调函数，若有，则生成一个回调函数 id，并将 id 和对应回调添加进入回调函数集合 responseCallbacks 中，其中 handlerName 是和 app 商议好的方法名称&lt;/li&gt;
  &lt;li&gt;通过特定的参数转换方法，将传入的数据、方法名一起拼接成一个 url scheme&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 调用线程
function callHandler(handlerName, data, responseCallback) {
  _doSend({
    handlerName: handlerName, // 和 app 商议好的方法名称
    data: data // 要传递的数据，结构可以相互约定
  }, responseCallback);
}

// 触发 native 处理 message，如果有回调的话，则会带上生成的回调 id
function _doSend(message, responseCallback) {
  if (responseCallback) {
    const callbackId = generateCallbackId() // 生成一些回调 id
    responseCallbacks[callbackId] = responseCallback
    message.callbackId = callbackId // 发送的 message 中只会传递回调函数的 id
  }

  // 发送的 message 存在一个 sendMessageQueue 队列中
  sendMessageQueue.push(message)
  
  // 通过 iframe.src 发送 url scheme
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;iframe.src&lt;/code&gt; 发送 url scheme 的实现如下，我们这里的目的只是告诉 Native 有新消息需要处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 定义 url scheme
const uri = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE

// 创建隐藏 iframe 过程
const messagingIframe = document.createElement('iframe')
messagingIframe.style.display = 'none'
document.documentElement.appendChild(messagingIframe)

// 通过 iframe.src 触发 scheme，通知 Native，有新数据(message)需要处理
messagingIframe.src = uri
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、 &lt;strong&gt;Native 如何得知 api 被调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上一步，我们已经成功在前端页面中触发 scheme，那么 Native 如何捕获 scheme 被触发呢？安卓和 IOS 捕获方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// Android
public boolean shouldOverrideUrlLoading(WebView view, String url){
  // 如果返回 false，则 WebView 处理链接 url，如果返回 true，代表 WebView 根据程序来执行 url
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// ios
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
  NSURL *url = [request URL];

  NSString *requestString = [[request URL] absoluteString];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 Native 已经接收到了 JS 调用的方法，那么会通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;_fetchQueue&lt;/code&gt; 统一处理存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessageQueue&lt;/code&gt; 中的数据，并重置为空:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 获取 sendMessageQueue 返回给 Native
// 由于 Android 不能直接获取返回的内容，所以使用 shouldOverrideUrlLoading 的方式返回内容
function _fetchQueue() {
  const messageQueueString = JSON.stringify(sendMessageQueue);
  sendMessageQueue = [];
  // android can't read directly the return data, so we can reload iframe src to communicate with java
  if (messageQueueString !== '[]') {
    bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、 &lt;strong&gt;Native 如何调用 JS，以及 H5 中 api 方法的注册以及格式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JS 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;registerHandler&lt;/code&gt; 来注册方法提供给 Native 调用，这些注册的方法会统一放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;messageHandlers&lt;/code&gt; 中管理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;function registerHandler(handlerName, handler) {
  messageHandlers[handlerName] = handler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来再看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;_dispatchMessageFromNative&lt;/code&gt; 的实现，主要用于处理前端主动调用时的回调或 Native 主动调用 JS 注册方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 参考 JsBridge 仓库的 assets/WebViewJavascriptBridge 实现
// 提供给 native 使用，对接收到的数据队列进行遍历执行
function _dispatchMessageFromNative(messageJSON) {
  setTimeout(function() {
    var message = JSON.parse(messageJSON);
    var responseCallback;
    // java call finished, now need to call js callback function
    // 处理前端主动调用时的回调
    // responseId 是 java 执行 sendResponse 处理回调信息时赋值的 - response.responseId = callbackId;
    if (message.responseId) {
      // 根据 id 找到 responseCallbacks 对应的回调方法
      responseCallback = responseCallbacks[message.responseId];
      if (!responseCallback) {
        return;
      }
      responseCallback(message.responseData);
      delete responseCallbacks[message.responseId];
    } else {
      // 直接发送，Native 主动调用 JS 注册方法
      if (message.callbackId) {
        var callbackResponseId = message.callbackId;
        responseCallback = function(responseData) {
          _doSend('response', responseData, callbackResponseId);
        };
      }

      var handler = WebViewJavascriptBridge._messageHandler;
      if (message.handlerName) {
        handler = messageHandlers[message.handlerName];
      }
      // 在本地函数集合 messageHandlers 中查找指定 handler 并执行
      try {
        handler(message.data, responseCallback);
      } catch (exception) {
        if (typeof console != 'undefined') {
          console.log(&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;, message, exception);
        }
      }
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的流程如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/1dda1826cc58c69285e46c138ea54245cfe3b66c.png&quot; alt=&quot;whole period&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在实际的开发中，我们统一出以下方案来针对 IOS 和安卓:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/0*gNSgNMbYQaeoFxDA.png&quot; alt=&quot;strategy&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多可以参考 IOS &lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot;&gt;&lt;strong&gt;WebViewJavascriptBridge&lt;/strong&gt;&lt;/a&gt; 和安卓 &lt;a href=&quot;https://github.com/lzyzsd/JsBridge&quot;&gt;JsBridge&lt;/a&gt; 的实现 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xiangzhihong8/article/details/66970600&quot;&gt;JSBridge 深度剖析&lt;/a&gt; By xiangzhihong8&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/be491bfbca0d&quot;&gt;JSBridge 总结&lt;/a&gt; By NowhereToRun&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="JavaScript" /><summary type="html">JSBridge</summary></entry><entry><title type="html">富文本原理</title><link href="http://localhost:2333/2019/12/18/js-rich-editor.html" rel="alternate" type="text/html" title="富文本原理" /><published>2019-12-18T20:22:00+08:00</published><updated>2019-12-18T20:22:00+08:00</updated><id>http://localhost:2333/2019/12/18/js-rich-editor</id><content type="html" xml:base="http://localhost:2333/2019/12/18/js-rich-editor.html">&lt;h1 id=&quot;富文本原理&quot;&gt;富文本原理&lt;/h1&gt;

&lt;h2 id=&quot;富文本&quot;&gt;富文本&lt;/h2&gt;

&lt;h3 id=&quot;contenteditable&quot;&gt;contenteditable&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable&quot;&gt;&lt;strong&gt;contenteditable&lt;/strong&gt;&lt;/a&gt; 是一个枚举属性，表示元素是否可被用户编辑。如果可以，浏览器会修改元素的部件以允许编辑:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;blockquote contenteditable=&quot;true&quot;&amp;gt;
  &amp;lt;p&amp;gt;Edit this content to add your own quote&amp;lt;/p&amp;gt;
  &amp;lt;!-- 子元素不想被编辑，添加 false 即可 --&amp;gt;
  &amp;lt;p contentEditable=&quot;false&quot;&amp;gt;不能编辑我&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;

&amp;lt;cite contenteditable=&quot;true&quot;&amp;gt;-- Write your own name here&amp;lt;/cite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote contenteditable=&quot;true&quot;&gt;
  &lt;p&gt;Edit this content to add your own quote&lt;/p&gt;
  &lt;p contenteditable=&quot;false&quot;&gt;不能编辑我&lt;/p&gt;
  &lt;cite style=&quot;color:white&quot;&gt;-- Write your own name here&lt;/cite&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;documentexeccommand&quot;&gt;document.execCommand&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand&quot;&gt;&lt;strong&gt;document.execCommand&lt;/strong&gt;&lt;/a&gt; 允许运行命令来操纵可编辑内容区域的元素，说人话，当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;contentEditable&lt;/code&gt; 时，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;execCommand()&lt;/code&gt; 将影响当前活动的可编辑元素。语法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * 返回一个 Boolean ，如果是 false 则表示操作不被支持或未被启用
 *
 * @param {*} aCommandName - 一个 DOMString ，命令的名称
 * @param {*} aShowDefaultUI - 一个 Boolean， 是否展示用户界面，一般为 false
 * @param {*} aValueArgument - 一些命令（如 insertImage）需要额外的参数（insertImage 需要提供插入 image 的 url），默认为 null。
 */
bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对命令名称，我们可以看下默认常用的有哪些，需要注意的是不同浏览器表现可能有所不同，使用的话要考虑到兼容性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;backColor - 修改文档的背景颜色。在 styleWithCss 模式下，则只影响容器元素的背景颜色。这需要一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;color&amp;gt;&lt;/code&gt; 类型的字符串值作为参数传入。注意，IE 浏览器用这个设置文字的背景颜色&lt;/li&gt;
  &lt;li&gt;bold - 开启或关闭选中文字或插入点的粗体字效果。IE 浏览器使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; 标签，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 标签&lt;/li&gt;
  &lt;li&gt;copy - 拷贝当前选中内容到剪贴板&lt;/li&gt;
  &lt;li&gt;createLink - 将选中内容创建为一个锚链接。这个命令需要一个 hrefURI 字符串作为参数值传入。URI 必须包含至少一个字符，例如一个空格。（浏览器会创建一个空链接）&lt;/li&gt;
  &lt;li&gt;cut - 剪贴当前选中的文字并复制到剪贴板&lt;/li&gt;
  &lt;li&gt;delete - 删除选中部分&lt;/li&gt;
  &lt;li&gt;fontName - 在插入点或者选中文字部分修改字体名称. 需要提供一个字体名称字符串 (例如：”Arial”)作为参数&lt;/li&gt;
  &lt;li&gt;fontSize - 在插入点或者选中文字部分修改字体大小. 需要提供一个 HTML 字体尺寸 (1-7) 作为参数&lt;/li&gt;
  &lt;li&gt;foreColor - 在插入点或者选中文字部分修改字体颜色. 需要提供一个颜色值字符串作为参数。&lt;/li&gt;
  &lt;li&gt;formatBlock - 添加一个 HTML 块式标签在包含当前选择的行, 如果已经存在了，更换包含该行的块元素，需要提供一个标签名称字符串作为参数(例如 “H1”, “P”, “DL”, “BLOCKQUOTE”)&lt;/li&gt;
  &lt;li&gt;heading - 添加一个标题标签在光标处或者所选文字上。 需要提供标签名称字符串作为参数 (例如. “H1”, “H6”)&lt;/li&gt;
  &lt;li&gt;insertImage - 在插入点插入一张图片并删除选中的部分。需要一个 URL 字符串(可以为 base64)作为参数。这个 URL 图片地址至少包含一个字符。空白字符也可以&lt;/li&gt;
  &lt;li&gt;italic - 在光标插入点开启或关闭斜体字。IE 浏览器使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;i&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;justifyCenter - 对光标插入位置或者所选内容进行文字居中。同理还有 justifyLeft、justifyRight 等&lt;/li&gt;
  &lt;li&gt;paste - 在光标位置粘贴剪贴板的内容，如果有被选中的内容，会被替换&lt;/li&gt;
  &lt;li&gt;redo - 重做被撤销的操作&lt;/li&gt;
  &lt;li&gt;removeFormat - 对所选内容去除所有格式&lt;/li&gt;
  &lt;li&gt;underline - 在光标插入点开启或关闭下划线&lt;/li&gt;
  &lt;li&gt;undo - 撤销最近执行的命令&lt;/li&gt;
  &lt;li&gt;unlink - 去除所选的锚链接的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 加粗
document.execCommand('bold', false, null)
// 添加一个块标签包裹
document.execCommand('formatBlock', false, '&amp;lt;blockquote&amp;gt;')
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器会对 &lt;code class=&quot;highlighter-rouge&quot;&gt;contenteditable&lt;/code&gt; 生成的可编辑区维护一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;undo&lt;/code&gt; 栈和 &lt;code class=&quot;highlighter-rouge&quot;&gt;redo&lt;/code&gt; 栈，使我们能够执行前进和后退的操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;selection--range&quot;&gt;Selection / Range&lt;/h3&gt;

&lt;p&gt;当我们执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;execCommand&lt;/code&gt; 的时候，我们需要指明对哪些选区进行操作，即 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Selection&quot;&gt;&lt;strong&gt;Selection&lt;/strong&gt;&lt;/a&gt;，它表示用户选择的文本范围或插入符号的当前位置。文本选区由用户拖拽鼠标经过文字而产生，要获取用于检查或修改的 Selection 对象，请调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;window.getSelection()&lt;/code&gt;，它包含了以下术语:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;锚点(anchor)&lt;/strong&gt; - 锚指的是一个选区的起始点(注意不同于 HTML 中的锚点链接)。当我们使用鼠标框选一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;焦点(focus)&lt;/strong&gt; - 选区的焦点是该选区的终点，当您用鼠标框选一个选区的时候，焦点是你的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;范围(range)&lt;/strong&gt; - 范围指的是文档中连续的一部分。一个范围包括整个节点，也可以包含节点的一部分，例如文本节点的一部分。用户通常下只能选择一个范围，但是有的时候用户也有可能选择多个范围。“范围”会被作为 range 对象返回。Range对象也能通过 DOM 创建、增加、删减&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Selection 对象所对应的是用户所选择的 &lt;strong&gt;ranges(区域)&lt;/strong&gt;，俗称拖蓝。默认情况下，该函数只针对一个区域，我们可以这样使用这个函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const selObj: Selection = window.getSelection()
const range: Range = selObj.getRangeAt(0) // 获取我们选中的区间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Selection 拥有以下常用的属性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;anchorNode - 返回该选区起点所在的节点（Node）&lt;/li&gt;
  &lt;li&gt;anchorOffset - 返回一个数字，其表示的是选区起点在 anchorNode 中的位置偏移量&lt;/li&gt;
  &lt;li&gt;focusNode - 返回该选区终点所在的节点&lt;/li&gt;
  &lt;li&gt;focusOffset - 返回一个数字，其表示的是选区终点在 focusNode 中的位置偏移量&lt;/li&gt;
  &lt;li&gt;isCollapsed - 返回一个布尔值，用于判断选区的起始点和终点是否在同一个位置&lt;/li&gt;
  &lt;li&gt;rangeCount - 返回该选区所包含的连续范围的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且有以下常用方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getRangeAt - 返回选区开始的节点（Node）&lt;/li&gt;
  &lt;li&gt;collapse - 将当前的选区折叠为一个点&lt;/li&gt;
  &lt;li&gt;addRange - 一个区域（Range）对象将被加入选区&lt;/li&gt;
  &lt;li&gt;removeRange - 从选区中移除一个区域&lt;/li&gt;
  &lt;li&gt;removeAllRanges - 将所有的区域都从选区中移除&lt;/li&gt;
  &lt;li&gt;deleteFromDocument - 从页面中删除选区中的内容&lt;/li&gt;
  &lt;li&gt;toString - 返回当前选区的纯文本内容&lt;/li&gt;
  &lt;li&gt;containsNode - 判断某一个 node 是否为当前选区的一部分&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Range 对象也包含了很多属性和方法，具体可以&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Range&quot;&gt;查阅这里&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们直接用一些例子来对比下选区和相应的属性值:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/17/vRNApDcCBuPza65.png&quot; alt=&quot;rich-editor-selection.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意的是 2 步骤中，如果有一段文本有设置命令，则它会被分割成多个片段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;setselectionrange&quot;&gt;setSelectionRange&lt;/h3&gt;

&lt;p&gt;上述是我们主动去选择一块儿区域，我们也可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;setSelectionRange&lt;/code&gt; 来创建一片选区:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * 每次调用这个这个方法会更新 HTMLInputElement 的 selectionStart, selectionEnd,和 selectionDirection 属性
 *
 * @param {*} selectionStart - 被选中的第一个字符的位置
 * @param {*} selectionEnd - 被选中的最后一个字符的 下一个 位置
 * @param {*} selectionDirection - 一个指明选择方向的字符串，有&quot;forward&quot;,&quot;backward&quot;和&quot;none&quot; 3个可选值
 */
inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，setSelectionRange 只能在一个被 focused 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素中选中特定范围的内容，否则无法选中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script&gt;
  const selectText = () =&gt; {
    const input = document.querySelector('#mytextbox')
    input.focus()
    input.setSelectionRange(7, 11) // 选择特定部分
    // input.setSelectionRange(0, -1) // 全选
  }

  const execCopyText = node =&gt; {
    let canUserSelect = true
    const selection = window.getSelection()
    const range = document.createRange() // 返回一个 Range 对象

    // 不让选也要选
    if (getComputedStyle(node).userSelect === 'none' || getComputedStyle(node)['-webkit-user-select'] === 'none') {
      canUserSelect = false
      node.style.userSelect = 'text'
      node.style['-webkit-user-select'] = 'text'
    }

    // 设置 Range 使其包含一个 Node 的内容
    range.selectNodeContents(node)

    selection.removeAllRanges()
    selection.addRange(range)
    document.execCommand('copy')

    if (!canUserSelect) {
      node.style.userSelect = 'none'
      node.style['-webkit-user-select'] = 'none'
    }
  }

  const copyText = () =&gt; {
    const input = document.querySelector('#test')
    input.focus()
    execCopyText(input)
  }
&lt;/script&gt;

&lt;body&gt;
  &lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;mytextbox&quot; size=&quot;20&quot; value=&quot;Tate &amp;amp; Snow&quot; /&gt;&lt;/p&gt;
  &lt;p id=&quot;test&quot; style=&quot;user-select:none;-webkit-user-select:none&quot;&gt;Tate &amp;amp; Snow Copied&lt;/p&gt;
  &lt;p&gt;
    &lt;button style=&quot;padding:2px&quot; onclick=&quot;selectText()&quot;&gt;Select Snow&lt;/button&gt;
    &lt;button style=&quot;padding:2px&quot; onclick=&quot;copyText()&quot;&gt;Copy text&lt;/button&gt;
  &lt;/p&gt;
&lt;/body&gt;

&lt;p&gt;如果不是 input 框呢，我们还可以通过其他方式来实现”隔空拷贝”。可以看是否能选中 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tate &amp;amp; Snow Copied&lt;/code&gt;，不行的话试试点击下上面的 “Copy text” 按钮 😄:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const execCopyText: (node: HTMLElement) =&amp;gt; void = node =&amp;gt; {
  let canUserSelect = true
  const selection = window.getSelection() as Selection
  const range = document.createRange() // 返回一个 Range 对象

  // 不让选也要选
  // 如果是 safari 浏览器，则需要判断 getComputedStyle(node)['-webkit-user-select']，其他同理做兼容性处理
  if (getComputedStyle(node).userSelect === 'none') {
    canUserSelect = false
    node.style.userSelect = 'text'
  }

  // 设置 Range 使其包含一个 Node 的内容
  range.selectNodeContents(node)

  selection.removeAllRanges()
  selection.addRange(range)
  document.execCommand('copy')

  if (!canUserSelect) {
    node.style.userSelect = 'none'
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;简单的富文本实现&quot;&gt;简单的富文本实现&lt;/h3&gt;

&lt;p&gt;我们了解了关于富文本的一些技术实现后，很容易就可以手动撸一个了:&lt;/p&gt;

&lt;style&gt;
  .container button {
    padding: 5px;
    cursor: pointer;
  }
  .container label {
    padding: 5px;
    background-color: white;
    cursor: pointer;
  }
  .editor-container {
    display: flex;
  }
  .editor-container div {
    width: 400px;
    height: 200px;
    overflow: auto;
    background-color: white;
  }
  .editor-container div p {
    color: black !important;
  }
  .editor-container div a {
    color: red !important;
  }
&lt;/style&gt;

&lt;div&gt;
  &lt;div class=&quot;container&quot; role=&quot;nav&quot;&gt;
    &lt;button onclick=&quot;exec('copy')&quot;&gt;复制&lt;/button&gt;
    &lt;!-- &lt;button onclick=&quot;exec('paste')&quot;&gt;粘贴&lt;/button&gt; --&gt;
    &lt;button onclick=&quot;exec('bold')&quot;&gt;加粗&lt;/button&gt;
    &lt;button onclick=&quot;exec('underline')&quot;&gt;下划线&lt;/button&gt;
    &lt;button onclick=&quot;exec('formatBlock', false, '&amp;lt;p&amp;gt;')&quot;&gt;段落&lt;/button&gt;
    &lt;button onclick=&quot;createLink()&quot;&gt;设置超链接&lt;/button&gt;
    &lt;button onclick=&quot;createImage()&quot;&gt;设置图片链接&lt;/button&gt;
    &lt;button onclick=&quot;clickImage()&quot;&gt;插入图片&lt;/button&gt;
    &lt;button onclick=&quot;exec('removeFormat')&quot;&gt;清除样式&lt;/button&gt;
    &lt;button onclick=&quot;exec('undo')&quot;&gt;撤销&lt;/button&gt;
    &lt;button onclick=&quot;exec('redo')&quot;&gt;重做&lt;/button&gt;
    &lt;input id=&quot;editor-img&quot; style=&quot;display:none&quot; type=&quot;file&quot; accept=&quot;image/gif, image/jpeg, image/png&quot; onchange=&quot;insertImage(event)&quot; /&gt;
  &lt;/div&gt;
  &lt;div role=&quot;editor-container&quot; class=&quot;editor-container&quot;&gt;
    &lt;div style=&quot;margin-right:10px&quot; role=&quot;editor&quot; oninput=&quot;print()&quot; contenteditable=&quot;true&quot;&gt;不妨来试一试 😜&lt;/div&gt;
    &lt;div role=&quot;preview&quot;&gt;不妨来试一试 😜&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  let currentRange = null // 当前选区
  const saveSelection = () =&gt; { // 保存当前 Range 对象
    const selection = window.getSelection()
    if (selection.rangeCount &gt; 0) {
      return selection.getRangeAt(0)
    }
    return null
  }
  const restoreSelection = () =&gt; {
    const selection = window.getSelection()
    if (currentRange) {
      selection.removeAllRanges()  // 清空所有 Range 对象
      selection.addRange(currentRange) // 恢复保存的 Range
    }
  }
  const exec = (aCommandName, aShowDefaultUI = false, aValueArgument = null) =&gt; {
    document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)
  }
  const saveCurrentSelection = () =&gt; {
    currentRange = saveSelection()
  }
  const createLink = () =&gt; {
    const url = window.prompt('请输入超链接')
    if (url) {
      exec('createLink', false, url)
    }
  }
  const clickImage = () =&gt; {
    saveCurrentSelection()
    document.querySelector('#editor-img').click()
  }
  const createImage = () =&gt; {
    saveCurrentSelection()
    const url = window.prompt('请输入图片链接')
    if (url) {
      exec('insertImage', false, url)
    }
  }
  const insertImage = (e) =&gt; {
    let reader = new FileReader()
    let file = e.target.files[0]
    // document.querySelector('.editor-container div[role=&quot;editor&quot;]').focus()
    reader.onload = () =&gt; {
      let base64Img = reader.result
      restoreSelection()
      exec('insertImage', false, base64Img)
      document.querySelector('.editor-img input').value = '' // 解决同一张图片上传无效的问题
    }
    reader.readAsDataURL(file)
  }
  const print = () =&gt; {
    document.querySelector(&quot;div[role='preview']&quot;).innerText = document.querySelector(&quot;div[role='editor']&quot;).innerHTML
  }
&lt;/script&gt;

&lt;p&gt;但是我们一定要关注 focus 的状态，只有聚焦在编辑区才能执行相应的命令，因此我们可以定义一些方法来保存和恢复选区的 Range 对象:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;let currentRange = null // 当前选区
const saveSelection = () =&amp;gt; { // 保存当前 Range 对象
  const selection = window.getSelection()
  if (selection.rangeCount &amp;gt; 0) {
    return selection.getRangeAt(0)
  }
  return null
}
const restoreSelection = () =&amp;gt; {
  const selection = window.getSelection()
  if (currentRange) {
    selection.removeAllRanges()  // 清空所有 Range 对象
    selection.addRange(currentRange) // 恢复保存的 Range
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;draftjs&quot;&gt;Draft.js&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://draftjs.org&quot;&gt;&lt;strong&gt;Draft.js&lt;/strong&gt;&lt;/a&gt; 是 facebook 推出的用于 React 的富文本编辑器框架，是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Immutable.js&lt;/code&gt; 来保存数据的。一个炒鸡简单的 demo 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/441ad6e66bcdf56276026625ad31a1e7a634d822/68747470733a2f2f6d656469612e67697068792e636f6d2f6d656469612f5848556a6178454c7063313153695253714e2f67697068792e676966&quot; alt=&quot;Draft.js&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;import React from 'react'
import ReactDOM from 'react-dom'
import { Editor, EditorState } from 'Draft.js'

function MyEditor() {
  const [editorState, setEditorState] = React.useState(
    EditorState.createEmpty()
  )

  const editor = React.useRef(null)

  function focusEditor() {
    editor.current.focus()
  }

  React.useEffect(() =&amp;gt; {
    focusEditor()
  }, [])

  return (
    &amp;lt;div onClick={focusEditor}&amp;gt;
      &amp;lt;Editor
        ref={editor}
        editorState={editorState}
        onChange={editorState =&amp;gt; setEditorState(editorState)}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;editorstate&quot;&gt;EditorState&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://draftjs.org/docs/api-reference-editor-state&quot;&gt;&lt;strong&gt;EditorState&lt;/strong&gt;&lt;/a&gt; 是编辑器最顶层的状态对象，它是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Immutable Record&lt;/code&gt; 对象，保存了编辑器中全部的状态信息，包括文本状态、选中状态等:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.wukai.me/asset/images/2019-07-21-draft-editor-01.png&quot; alt=&quot;EditorState&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当操作 EditorState 对象时，我们不应该直接通过 Immutable 的 API 来获取想要的值，而是通过它暴露出来的静态方法和实例方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getCurrentContent(): ContentState - 返回一个 &lt;strong&gt;ContentState&lt;/strong&gt; 对象，存放的是当前编辑器中的内容&lt;/li&gt;
  &lt;li&gt;getSelection(): SelectionState - 返回当前选中的状态&lt;/li&gt;
  &lt;li&gt;getCurrentInlineStyle(): DraftInlineStyle - 返回一个代表着编辑器“当前”内联样式的 &lt;code class=&quot;highlighter-rouge&quot;&gt;OrderedSet&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;static createEmpty(?decorator): EditorState - 创建空的 EditorState 实例&lt;/li&gt;
  &lt;li&gt;static createWithContent(contentState, ?decorator): EditorState - 基于 ContentState 和 decorator 返回一个新的 EditorState&lt;/li&gt;
  &lt;li&gt;static create(config): EditorState&lt;/li&gt;
  &lt;li&gt;static push(editorState, contentState, changeType): EditorState - 返回一个新的 EditorState 对象，该对象使用指定的 ContentState 作为新的当前内容。基于changeType，这个ContentState可能会被视为撤销/重做的边界状态&lt;/li&gt;
  &lt;li&gt;static undo(editorState): EditorState - 从 undo 栈 pop 出一个新的 EditorState 对象，更新为当前的 ContentState 对象&lt;/li&gt;
  &lt;li&gt;static redo(editorState): EditorState - 同上，只不过是 redo 栈&lt;/li&gt;
  &lt;li&gt;static forceSelection(editorState, selectionState): EditorState - 返回一个新的 EditorState 对象，该对象使用指定的 SelectionState，并强制选择被渲染&lt;/li&gt;
  &lt;li&gt;static set(editorState, EditorStateRecordType): EditorState&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 创建空的 EditorState 实例
const createEmptyEditorState: (p?: any) =&amp;gt; EditorState = decorator =&amp;gt;
  EditorState.createEmpty(decorator)

const createEditorState: (state: ContentState, p?: any) =&amp;gt; EditorState = (contentState, decorator) =&amp;gt;
  EditorState.createWithContent(contentState, decorator)

// 基于 raw 来创建 EditorState 对象
const emptyEditorState = isEmptyObject(raw) ? createEmptyEditorState() : createEditorState(convertFromRaw(raw))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;contentstate&quot;&gt;ContentState&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://draftjs.org/docs/api-reference-content-state&quot;&gt;&lt;strong&gt;ContentState&lt;/strong&gt;&lt;/a&gt; 是用来保存编辑器里的全部内容和渲染前后的两个选中状态，常用的方法有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getEntityMap(): EntityMap - 返回一个包含所有已创建的 DraftEntity 记录的存储对象 EntityMap&lt;/li&gt;
  &lt;li&gt;getBlockMap(): BlockMap - 获取 BlockMap，表示整个文档状态的 ContentBlock 对象组成的完整有序映射&lt;/li&gt;
  &lt;li&gt;getBlockForKey(key: string): ContentBlock - 根据 key 返回对应的 ContentBlock 对象&lt;/li&gt;
  &lt;li&gt;getFirstBlock() - 获取第一个 ContentBlock 对象，同理有 &lt;code class=&quot;highlighter-rouge&quot;&gt;getLastBlock&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;getLastCreatedEntityKey(): string - 返回最近一次创建的 DraftEntityRecord 对象的应用 key。因为在 ContentState 对象中可以通过字符串 key 来引用对应的实体对象。应在 CharacterMetadata 对象中使用字符串 key 来标记对应的字符实体&lt;/li&gt;
  &lt;li&gt;createEntity(type: DraftEntityType, mutability: DraftEntityMutability, data?: Object): ContentState - 返回 EntityMap 中包含了新建的 DraftEntity 对象的 ContentState 对象&lt;/li&gt;
  &lt;li&gt;getEntity(key: string): DraftEntityInstance - 根据 key 返回对应的 DraftEntityInstance 对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;EditorState.getCurrentContent()&lt;/code&gt; 来获取当前的 ContentState，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;toObject()&lt;/code&gt; 转换为普通 javascript 对象后，可以看到它主要包含了 &lt;strong&gt;BlockMap&lt;/strong&gt; 和 &lt;strong&gt;EntityMap&lt;/strong&gt; 有序映射，我们可以分别通过上面提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;getBlockMap&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getEntityMap&lt;/code&gt; 方法来获取他们:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;# blockMap: OrderedMap {size: 6, _map: Map, _list: List, __ownerID: undefined, __hash: undefined}
# entityMap: {0: &quot;1&quot;}
# selectionAfter: SelectionState {_map: Map, __ownerID: undefined}
# selectionBefore: SelectionState {_map: Map, __ownerID: undefined}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么他们到底是什么呢？通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;convertToRaw(currentContent)&lt;/code&gt; 转换后看看其中的内容，这里只有 blocks 和 entityMap 这两项:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;# blocks: Array(6)
  0: {key: &quot;dpibs&quot;, text: &quot;123&quot;, type: &quot;unstyled&quot;, depth: &quot;0&quot;, inlineStyleRanges: Array(5), …}
  1: {key: &quot;8evo3&quot;, text: &quot;&quot;, type: &quot;unstyled&quot;, depth: &quot;0&quot;, inlineStyleRanges: Array(0), …}
  2: {key: &quot;9p4vp&quot;, text: &quot;&quot;, type: &quot;unstyled&quot;, depth: &quot;0&quot;, inlineStyleRanges: Array(0), …}
  3: {key: &quot;eigub&quot;, text: &quot;tate&quot;, type: &quot;unstyled&quot;, depth: &quot;0&quot;, inlineStyleRanges: Array(2), …}
  4: {key: &quot;607oo&quot;, text: &quot;&quot;, type: &quot;unstyled&quot;, depth: &quot;0&quot;, inlineStyleRanges: Array(0), …}
  5:
    data: {}
    depth: &quot;0&quot;
    entityRanges: Array(1)
      0: {offset: 0, length: 4, key: 0}
    inlineStyleRanges: Array(2)
      0: {offset: 0, length: 4, style: &quot;FONTFAMILY-Helvetica&quot;}
      1: {offset: 0, length: 4, style: &quot;LINEHEIGHT-1.5&quot;}
    key: &quot;ff87&quot;
    text: &quot;link&quot;
    type: &quot;unstyled&quot;
# entityMap:
  0:
    data: {url: &quot;www.baidu.com&quot;}
    mutability: &quot;MUTABLE&quot;
    type: &quot;LINK&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 blocks 这个数组中依次存放了各个 block 的信息，每一个 block 都是一个 &lt;strong&gt;ContentBlock&lt;/strong&gt; 对象。而 entityMap 则包含了所有实体。&lt;/p&gt;

&lt;h3 id=&quot;contentblock&quot;&gt;ContentBlock&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://draftjs.org/docs/api-reference-content-block&quot;&gt;&lt;strong&gt;ContentBlock&lt;/strong&gt;&lt;/a&gt; 表示编辑器内容中每一个 block 的完整状态，类似于段落这种块级元素，主要包含了以下几方面:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key - 标识符，获取方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;getKey()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;type - 这是何种类型的 block，常见的有 &lt;code class=&quot;highlighter-rouge&quot;&gt;unstyled&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;paragragh&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 等，获取方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;getType()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;text - 纯文字，不包括任何样式、修饰或 HTML 信息，获取方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;getText()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;data - 块级元数据，获取方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;getData()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;entityRanges - 实体
    &lt;ul&gt;
      &lt;li&gt;type - 实体类型&lt;/li&gt;
      &lt;li&gt;data - 实体包含的数据&lt;/li&gt;
      &lt;li&gt;mutability - 标识实体在用户编辑的时候展现出来的特性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;inlineStyleRanges - 所有内联样式
    &lt;ul&gt;
      &lt;li&gt;offset - 偏移量&lt;/li&gt;
      &lt;li&gt;length - 字符长度&lt;/li&gt;
      &lt;li&gt;style - 样式类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;characterList - 是一个 immutable List 列表，其中包含该块中每个字符的 &lt;strong&gt;CharacterMetadata&lt;/strong&gt; 对象，我们通过这种方式用代码来构建块的样式和实体，获取方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;getCharacterList()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过在这些 characterList 列表和 CharacterMetadata 对象上大量使用不可变和数据持久化特性，使得在编辑器中编辑内容占用内存很小。当我们创建一个包含 text 但不包含 characterList 的 ContentBlock 对象时，会默认为提供的文本添加一个带有空 CharacterMetadata 对象的 characterList。&lt;/p&gt;

&lt;h3 id=&quot;charactermetadata&quot;&gt;CharacterMetadata&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CharacterMetadata&lt;/strong&gt; 表示一个包含单一字符行内样式和实体信息的对象。CharacterMetadata 对象被即时的汇总和共享。如果两个字符拥有相同的行内样式和实体，它们会被表示为相同的 CharacterMetadata 对象。因此，我们只需要尽可能多的组合带有实体 key 的内联样式集合，以达到即便内容的大小和复杂性增加，我们的内存占用也很小的目的。为此，你需要用过提供的静态方法来为 CharacterMetadata 对象创建或应用变更，这能确保最大限度的复用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;static create(…): CharacterMetadata - 根据提供的配置信息生成一个 CharacterMetadata 对象&lt;/li&gt;
  &lt;li&gt;static applyStyle(…): CharacterMetadata - 在 CharacterMetadata 对象上应用指定内联样式&lt;/li&gt;
  &lt;li&gt;static removeStyle(…): CharacterMetadata - 从 CharacterMetadata 对象中移除指定内联样式&lt;/li&gt;
  &lt;li&gt;static applyEntity(…): CharacterMetadata - 在 CharacterMetadata 对象上应用一个实体 key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如我要做个选中后清除选区所有内联样式的功能，那我可能会针对所选的 block 中 characterList 进行遍历，清除每一个 CharacterMetadata 对象包含的内联样式信息，那么首先我们要筛选出选中的 block 萌:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const getSelectedBlocks: (state: EditorState) =&amp;gt; ContentBlock[] = editorState =&amp;gt; {
  const selection = editorState.getSelection()
  const contentState = editorState.getCurrentContent()

  const startKey = selection.getStartKey() // 包含选区起始位置的 block 的 key
  const endKey = selection.getEndKey() // 包含选区结束位置的 block 的 key
  const isSameBlock = startKey === endKey
  const startingBlock = contentState.getBlockForKey(startKey)
  const selectedBlocks = [startingBlock]

  if (!isSameBlock) { // 如果是好多 block
    let blockKey = startKey

    while (blockKey !== endKey) {
      const nextBlock = contentState.getBlockAfter(blockKey)
      selectedBlocks.push(nextBlock)
      blockKey = nextBlock.getKey()
    }
  }

  return selectedBlocks
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们需要更新 characterList 列表，把空的样式覆盖进去并更新当前的 EditorState:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 更新 characterList 列表
const updateEachCharacterOfSelection: (state: EditorState, f: any) =&amp;gt; any = (editorState, callback) =&amp;gt; {
  const selection = editorState.getSelection()
  const contentState = editorState.getCurrentContent()
  const contentBlocks = contentState.getBlockMap()
  const selectedBlocks = getSelectedBlocks(editorState)

  if (selectedBlocks.length === 0) {
    return editorState
  }

  const startKey = selection.getStartKey()
  const startOffset = selection.getStartOffset()
  const endKey = selection.getEndKey()
  const endOffset = selection.getEndOffset()

  const nextContentBlocks = contentBlocks.map((block?: ContentBlock | undefined) =&amp;gt; {
    const curBlock = block as ContentBlock
    if (!selectedBlocks.includes(curBlock)) {
      return block
    }

    const blockKey = curBlock.getKey()
    const charactersList = curBlock.getCharacterList()
    let nextCharactersList = null

    if (blockKey === startKey &amp;amp;&amp;amp; blockKey === endKey) {
      nextCharactersList = charactersList.map((character, index) =&amp;gt; {
        const i = index as number
        if (i &amp;gt;= startOffset &amp;amp;&amp;amp; i &amp;lt; endOffset) {
          return callback(character)
        }
        return character
      })
    } else if (blockKey === startKey) {
      nextCharactersList = charactersList.map((character, index) =&amp;gt; {
        const i = index as number
        if (i &amp;gt;= startOffset) {
          return callback(character)
        }
        return character
      })
    } else if (blockKey === endKey) {
      nextCharactersList = charactersList.map((character, index) =&amp;gt; {
        const i = index as number
        if (i &amp;lt; endOffset) {
          return callback(character)
        }
        return character
      })
    } else {
      nextCharactersList = charactersList.map(character =&amp;gt; {
        return callback(character)
      })
    }

    return curBlock.merge({
      characterList: nextCharactersList,
    })
  })

  return EditorState.push(editorState, (contentState as any).merge({
    blockMap: nextContentBlocks,
    selectionBefore: selection,
    selectionAfter: selection,
  }), 'remove-range')
}

// 清除内联样式
const removeSelectionInlineStyles: (state: EditorState) =&amp;gt; EditorState = editorState =&amp;gt;
  updateEachCharacterOfSelection(editorState, (characterMetadata: CharacterMetadata) =&amp;gt;
    (characterMetadata as any).merge({
      style: Immutable.OrderedSet([]),
    }),
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;entity&quot;&gt;Entity&lt;/h3&gt;

&lt;p&gt;文本中会有许多高级的元数据，&lt;strong&gt;Entity&lt;/strong&gt; 实体就是用于表示这些元数据，使得我们可以在内容中添加链接，图片等，链接，提及和嵌入式内容都可以使用实体来实现。在上面 ContentBlock 里有介绍到，它有三个属性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;type - 实体类型，例如’LINK’，’MENTION’，’PHOTO’。&lt;/li&gt;
  &lt;li&gt;mutability - 此属性表示在编辑器中编辑文本范围时，使用此实体对象注释的一系列文本的行为。它拥有以下三种值:
    &lt;ul&gt;
      &lt;li&gt;IMMUTABLE - 如果不从文本中删除实体注释，则无法更改此文本。比如 mention&lt;/li&gt;
      &lt;li&gt;MUTABLE - 允许自由改变 Entity 的文本，如超链接&lt;/li&gt;
      &lt;li&gt;SEGMENTED - “分段”的实体以与“不可变”实体非常相似的方式与其文本紧密耦合，但允许通过删除进行自定义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;data - 包含实体元数据的可选对象。 例如，“LINK” 实体对象可能包含该链接的 href 的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用 decorator 装饰器或自定义块组件，可以根据实体元数据向编辑器添加丰富的渲染样式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Entity 本身的 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 等方法已经被弃用，直接使用上述 ContentState 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;createEntity&lt;/code&gt; 代替，其他同理。我们尝试创建和检索实体:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;contentState.createEntity&lt;/code&gt; 来创建实体。&lt;/li&gt;
  &lt;li&gt;他接受上面 3 个属性作为参数。&lt;/li&gt;
  &lt;li&gt;此方法返回一个 ContentState 记录。&lt;/li&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;contentState.getLastCreatedEntityKey&lt;/code&gt; 来获取创建的实体记录的 key&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const contentState = editorState.getCurrentContent()
const contentStateWithEntity = contentState.createEntity(
  'LINK',
  'MUTABLE',
  { url: 'http://www.baidu.com' }
)
const entityKey = contentStateWithEntity.getLastCreatedEntityKey()
const currentContent = Modifier.applyEntity(
  contentStateWithEntity,
  selectionState,
  entityKey
)
const newEditorState = EditorState.push(editorState, { currentContent })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于给定的文本范围，则可以通过在 ContentBlock 对象上使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;getEntityAt()&lt;/code&gt; 方法来提取其关联的实体 key，从而传递目标偏移值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const getEntityKey: (state: EditorState, k?: SelectionState) =&amp;gt; string = (editorState, selection) =&amp;gt; {
  const selectionState = selection || editorState.getSelection()
  const startKey = selectionState.getStartKey()
  const startOffset = selectionState.getStartOffset()
  return editorState
    .getCurrentContent()
    .getBlockForKey(startKey)
    .getEntityAt(startOffset)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;decorator&quot;&gt;Decorator&lt;/h3&gt;

&lt;p&gt;内联和块级样式并不是我们想要添加到编辑器的唯一富文本样式。例如，Facebook 评论输入给提及和标签提供了蓝色背景高亮。为了支持自定义富文本的灵活性，Draft 提供了一个“修饰器”系统，即 &lt;strong&gt;Decorator&lt;/strong&gt;，我们可以看作是用来添加高级富内容的一种方法。&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CompositeDecorator&lt;/code&gt; 类定义所需的修饰器行为。该类允许您提供多个 DraftDecorator 对象，并根据策略依次搜索每一组文本。修饰器存储在 EditorState 记录中。当创建一个新的 EditorState 对象（例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;EditorState.createEmpty()&lt;/code&gt;）的时候，可以选择提供修饰器参数。当然我们也可以动态区更新这些修饰器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 获取 entity type
const getEntityType: (state: ContentState, k: string) =&amp;gt; DraftEntityType = (contentState, entityKey) =&amp;gt;
  contentState
    .getEntity(entityKey)
    .getType()

const getEntityData: (state: ContentState, k: string) =&amp;gt; any = (contentState, entityKey) =&amp;gt;
  contentState
    .getEntity(entityKey)
    .getData()

// 设置新的修饰器
const turnOffHandleDecorations: (state: EditorState, k: object) =&amp;gt; EditorState = (editorState, decorator) =&amp;gt;
  EditorState.set(editorState, { decorator })

function findLinkEntities(contentBlock: ContentBlock, callback: (start: number, end: number) =&amp;gt; void, contentState: ContentState) {
  contentBlock.findEntityRanges(
    (character: CharacterMetadata) =&amp;gt; {
      const entityKey = character.getEntity()
      return (
        entityKey !== null &amp;amp;&amp;amp; getEntityType(contentState, entityKey) === LINK_ENTITY
      )
    },
    callback,
  )
}

const LinkComponent = (props: ILinkProps) =&amp;gt; {
  const { contentState, children, entityKey } = props
  const { url } = getEntityData(contentState, entityKey) // 获取实体内容
  return (
    &amp;lt;a target='_blank' onClick={e =&amp;gt; previewLink(e, url)} href={url}&amp;gt;
      {children}
    &amp;lt;/a&amp;gt;
  )
}

// 定义一些修饰器
const decorator = new CompositeDecorator([
  {
    strategy: findLinkEntities, // 指定策略
    component: LinkComponent, // 指定 React 组件去渲染它们
  },
])

function RichEditor(props: IProps) {
  //...
  const [editorState, setEditorState] = useState&amp;lt;EditorState&amp;gt;(turnOffHandleDecorations(emptyEditorState, decorator))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;richutils&quot;&gt;RichUtils&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;RichUtils&lt;/strong&gt; 是为实现富文本编辑器准备的一组实用的静态函数集合。在使用中，这些方法接收带有相关参数的 EditorState 对象，并且返回 EditorState 对象，我们常用的如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;toggleBlockType(editorState: EditorState, blockType: string): EditorState - 在选中区域上切指定的块级样式&lt;/li&gt;
  &lt;li&gt;toggleInlineStyle(editorState: EditorState, inlineStyle: string): EditorState - 在选中区域上切换指定的内联样式。如果用户的选区是折叠的，则应用或移除内部状态的样式&lt;/li&gt;
  &lt;li&gt;toggleLink(editorState: EditorState, targetSelection: SelectionState, entityKey: string): EditorState - 切换超链接样式，entityKey 为 null 则为清除&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 切换内联样式，比如 BOLD、ITALIC、UNDERLINE 等
const toggleInlineStyle = (inlineStyle: string) =&amp;gt; {
  setEditorState(
    RichUtils.toggleInlineStyle(
      editorState,
      inlineStyle,
    ),
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于我们自定义的内联样式，切记如果用户的选区是折叠的，则应用或移除内部状态的样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const toggleSelectionInlineStyle: (state: EditorState, p: string, k: string) =&amp;gt; EditorState = (editorState, style, prefix = '') =&amp;gt; {
  let nextEditorState = editorState
  if (prefix) {
    nextEditorState = updateEachCharacterOfSelection(nextEditorState, (characterMetadata: CharacterMetadata) =&amp;gt; {
      // tslint:disable-next-line:max-line-length
      return (characterMetadata as any).toJS().style.reduce((c: CharacterMetadata, characterStyle: string): CharacterMetadata =&amp;gt; {
        if (characterStyle.startsWith(prefix) &amp;amp;&amp;amp; style !== characterStyle) {
          return CharacterMetadata.removeStyle(c, characterStyle)
        } else {
          return c
        }
      }, characterMetadata)
    })
  }
  return RichUtils.toggleInlineStyle(nextEditorState, style)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RichUtils 还提供有关 Web 编辑器可用的核心键盘命令的信息，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cmd + B&lt;/code&gt;（粗体），&lt;code class=&quot;highlighter-rouge&quot;&gt;Cmd + I&lt;/code&gt;（斜体）等。我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;handleKeyCommand&lt;/code&gt; 属性来观察和处理键盘命令，并将它们传入 RichUtils 中来应用或删除所需的样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const handleKeyCommand: (p: DraftEditorCommand, k: EditorState) =&amp;gt; DraftHandleValue = (command, state) =&amp;gt; {
  const newState = RichUtils.handleKeyCommand(state, command)
  if (newState) {
    setEditorState(newState)
    return 'handled'
  }
  return 'not-handled'
}

// 返回的 Editor 组件
&amp;lt;Editor
  handleKeyCommand={handleKeyCommand}
  onChange={state =&amp;gt; setEditorState(state)}
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;modifier&quot;&gt;Modifier&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Modifier&lt;/strong&gt; 模块是一组实用的静态函数，主要封装 ContentState 对象上的各种常用编辑操作。任何情况下，这些方法都接收具有相关参数的 ContentState 对象，并返回一个新的 ContentState 对象。如果实际并未发生任何编辑行为，将原样返回输入的 ContentState 对象。具体方法可以查看文档，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;removeInlineStyle&lt;/code&gt; 方法可以从整个选中范围中移除指定的内联样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// deprecated 可以用上述的 toggleSelectionInlineStyle 优化
const setNextEditorState: (
  state: EditorState, selection: SelectionState, p: IStyleObject, k: EditorChangeType,
) =&amp;gt; EditorState = (editorState, selection, reduceStyle, changeType) =&amp;gt; {
  // 清除之前的样式
  const nextContentState = Object.keys(reduceStyle).reduce(
    (state, font) =&amp;gt; Modifier.removeInlineStyle(
      state, selection, font,
    ), getCurrentContent(editorState),
  )

  // 由 nextContentState 产生新的 editorState
  return EditorState.push(
    editorState,
    nextContentState,
    changeType,
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;数据转换&quot;&gt;数据转换&lt;/h3&gt;

&lt;p&gt;因为富文本编辑器不可能凭空存在，因此对内容进行保存和传输非常重要，你可能希望将 ContentState 对象转换为原生 JS，或者反过来将原生 JS 转换为 ContentState 对象。目前提供了三个方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;convertFromRaw(rawState: RawDraftContentState): ContentState - 将一个原始 state 转换为 ContentState 对象&lt;/li&gt;
  &lt;li&gt;convertToRaw(contentState: ContentState): RawDraftContentState - 将一个 ContentState 对象转换为原生 JS 结构，当需要保存编辑器状态、将编辑数据转换为其他格式，或在应用中开发其他功能时，非常有用。&lt;/li&gt;
  &lt;li&gt;convertFromHTML - 将一段 HTML 片段转换为一个包含两个 key 的对象。其中一个(contentBlocks)保存 ContentBlock 对象数组，另一个(entityMap)保存对 entityMap 的引用。再从 contentBlocks 和 entityMap 构造 contentState，然后使用该 contentState 更新 editorState&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const sampleMarkup =
  '&amp;lt;b&amp;gt;Bold text&amp;lt;/b&amp;gt;, &amp;lt;i&amp;gt;Italic text&amp;lt;/i&amp;gt;&amp;lt;br/ &amp;gt;&amp;lt;br /&amp;gt;' +
  '&amp;lt;a href=&quot;http://www.facebook.com&quot;&amp;gt;Example link&amp;lt;/a&amp;gt;'

const blocksFromHTML = convertFromHTML(sampleMarkup)
const state = ContentState.createFromBlockArray(
  blocksFromHTML.contentBlocks,
  blocksFromHTML.entityMap
)

setEditorState(EditorState.createWithContent(state))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;emmmm… 是的你没看错，它并没有转换成 html 的方法，因此我们常借助于一些其他库，比如 &lt;a href=&quot;https://www.npmjs.com/package/draft-js-export-html&quot;&gt;draft-js-export-html&lt;/a&gt;，下面会介绍到详细用法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;draftjs-实战&quot;&gt;Draft.js 实战&lt;/h2&gt;

&lt;h3 id=&quot;默认样式&quot;&gt;默认样式&lt;/h3&gt;

&lt;p&gt;Draft 里面有默认的块级和内联样式，块级比如有 “blockquote”、”code-block”、”ordered-list-item” 等；内联样式比如有 “bold”、”italic”、”underline” 等，我们看其中一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const BLOCK_TYPES: IRichEditorControls[] = [
  { label: '引用', style: 'blockquote', icon: FormatQuote },
  { label: '无序列表', style: 'unordered-list-item', icon: FormatListBulleted },
  { label: '有序列表', style: 'ordered-list-item', icon: FormatListNumbered },
  { label: '代码块', style: 'code-block', icon: Code },
]

// 获取 block type
const getBlockType: (state: EditorState) =&amp;gt; DraftBlockType = editorState =&amp;gt;
  editorState
    .getCurrentContent()
    .getBlockForKey(editorState.getSelection().getStartKey())
    .getType()

interface IProps {
  editorState: EditorState
  onToggle: (p: DraftBlockType) =&amp;gt; void
  children?: React.ReactNode
}

function BlockStyleControls(props: IProps) {
  const { editorState, onToggle, children } = props
  const blockType = getBlockType(editorState)

  return (
    &amp;lt;div className='RichEditor-controls'&amp;gt;
      {children}
      {BLOCK_TYPES.map(type =&amp;gt; (
        &amp;lt;StyleButton
          key={type.label}
          active={type.style === blockType}
          icon={type.icon}
          label={type.label}
          onToggle={onToggle}
          style={type.style}
        /&amp;gt;
      ))}
    &amp;lt;/div&amp;gt;
  )
}

export default BlockStyleControls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里从父组件传入的 onToggle 其实就是上述自定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;toggleInlineStyle&lt;/code&gt; 方法，是不是很简单，而且我们可以直接实现 redo/undo 操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const undo: (state: EditorState) =&amp;gt; EditorState = editorState =&amp;gt;
  EditorState.undo(editorState)

const redo: (state: EditorState) =&amp;gt; EditorState = editorState =&amp;gt;
  EditorState.redo(editorState)

// 只要传过来一个标示即可
const toggleUndoOrRedo = (doStyle: string) =&amp;gt; {
  if (doStyle === 'undo') {
    setEditorState(undo(editorState))
  } else {
    setEditorState(redo(editorState))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然我们也可以去修改默认的配置，就要用到下面讲到的 Editor 对象去操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;自定义样式&quot;&gt;自定义样式&lt;/h3&gt;

&lt;h4 id=&quot;editor&quot;&gt;Editor&lt;/h4&gt;

&lt;p&gt;在自定义样式前，我们有必要先了解下核心受控的 contentEditable 组件，即 &lt;strong&gt;Editor&lt;/strong&gt; 自身的 API 和 props:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;editorState - EditorState 对象由 Editor 创建&lt;/li&gt;
  &lt;li&gt;onChange - 在 Editor 编辑或文本选区(selection)变化的时候触发&lt;/li&gt;
  &lt;li&gt;placeholder&lt;/li&gt;
  &lt;li&gt;blockRenderMap - 提供了 block 的渲染配置，每个块级样式映射了一个元素标签以及一个可选的 wrapper 元素包裹起来&lt;/li&gt;
  &lt;li&gt;blockRendererFn - 可选地设置一个函数来定义自定义块的呈现&lt;/li&gt;
  &lt;li&gt;customStyleMap - 可选地设置一个内联样式表，以应用到具有指定样式的文本范围&lt;/li&gt;
  &lt;li&gt;customStyleFn - 可选地设置一个函数来将内联样式转换为 CSS 样式并应用到具体指定样式的文本范围&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;块级样式&quot;&gt;块级样式&lt;/h4&gt;

&lt;p&gt;这一节主要讲 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockRenderMap&lt;/code&gt; 的应用，以“居中、居左”这种功能项为例，我们直接在默认样式里的配置上加入这几种自定义样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const BLOCK_TYPES: IRichEditorControls[] = [
  // ...
  { label: '居左', style: ALIGN_KEYS.left, icon: FormatAlignLeft },
  { label: '居中', style: ALIGN_KEYS.center, icon: FormatAlignCenter },
  { label: '居右', style: ALIGN_KEYS.right, icon: FormatAlignRight },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们新建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Align.ts&lt;/code&gt; 文件来定义我们需要用来渲染的组件和样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// Align.ts
function Align(props: IProps) {
  const { type, children } = props
  return (
    &amp;lt;div className={'align-' + type}&amp;gt;
      {/* here, children contains a &amp;lt;section&amp;gt; container, as that was the matching element */}
      {children}
    &amp;lt;/div&amp;gt;
  )
}

export const ALIGN_KEYS = {
  center: 'align-center',
  left: 'align-left',
  right: 'align-right',
}

// https://draftjs.org/docs/advanced-topics-custom-block-render-map
const blockRenderMap = Immutable.Map({
  [ALIGN_KEYS.center]: {
    wrapper: &amp;lt;Align type='center' /&amp;gt;,
  },
  [ALIGN_KEYS.left]: {
    wrapper: &amp;lt;Align type='left' /&amp;gt;,
  },
  [ALIGN_KEYS.right]: {
    wrapper: &amp;lt;Align type='right' /&amp;gt;,
  },
})

export default blockRenderMap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们导出了一个 blockRenderMap 对象，我们需要编辑器去应用我们所配置的样式，因此这里需要用到 Editor 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockRenderMap&lt;/code&gt; 属性进行配置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;import { DefaultDraftBlockRenderMap } from 'draft-js'

// 与默认的块级样式合并
const extendedBlockRenderMap = DefaultDraftBlockRenderMap.merge(blockRenderMapAlign)

function RichEditor(props: IProps) {
  // ...
  return {
    // ...
    &amp;lt;Editor
      ref={editor}
      blockRenderMap={extendedBlockRenderMap}
      editorState={editorState}
      onChange={state =&amp;gt; setEditorState(state)}
      placeholder='写点什么呢...'
      spellCheck={true}
    /&amp;gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;内联样式&quot;&gt;内联样式&lt;/h4&gt;

&lt;p&gt;这一节主要讲 &lt;code class=&quot;highlighter-rouge&quot;&gt;customStyleMap&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;customStyleFn&lt;/code&gt; 的应用，以设置字体为例，我们不妨先针对这个控件创建新的文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// FontFamilyControls
const FONTFAMILY_TYPES = [
  { label: '默认', style: 'FONTFAMILY-inherit' },
  { label: 'Arial', style: 'FONTFAMILY-Arial' },
  { label: 'Artnext', style: 'FONTFAMILY-Artnext' },
  { label: 'Avenir', style: 'FONTFAMILY-Avenir' },
  { label: 'Banghdad', style: 'FONTFAMILY-Banghdad' },
  { label: 'Helvetica', style: 'FONTFAMILY-Helvetica' },
  { label: 'Muli', style: 'FONTFAMILY-Muli' },
  { label: 'SF ui test', style: 'FONTFAMILY-SF ui test' },
  { label: 'PingFangSC', style: 'FONTFAMILY-PingFangSC' },
  { label: '思源黑体', style: 'FONTFAMILY-Souce Han Sans CN' },
]

const defaultValue = 'FONTFAMILY-inherit'

interface IProps {
  editorState: EditorState
  saveCurrentSelection: () =&amp;gt; void // 保存选区
  onToggle(p: string, k: string): void
}

function FontFamilyControls(props: IProps) {
  const { onToggle, saveCurrentSelection, editorState } = props
  const classes = useStyle()
  const [currentValue, setCurrentValue] = useState&amp;lt;string&amp;gt;(defaultValue)
  const inputLabel = useRef&amp;lt;HTMLLabelElement&amp;gt;(null)
  const [labelWidth, setLabelWidth] = useState(0)

  useEffect(() =&amp;gt; {
    setLabelWidth(inputLabel.current!.offsetWidth)
  }, [])

  const getFontFamilyFromStyle: (p: string) =&amp;gt; string = style =&amp;gt; style.replace(fontFamilyKey, '')

  const onChoose = (e: React.ChangeEvent&amp;lt;{ value: unknown }&amp;gt;) =&amp;gt; {
    const { target: { value = '' } = {} } = e
    saveCurrentSelection()
    onToggle(value as string, fontFamilyKey)
  }

  const fontFamilyStyle: (p: string) =&amp;gt; React.CSSProperties = style =&amp;gt; ({
    fontFamily: getFontFamilyFromStyle(style),
  })

  return (
    &amp;lt;FormControl variant='outlined' className={classes.formControl}&amp;gt;
      &amp;lt;InputLabel ref={inputLabel} htmlFor='select-outlined-label'&amp;gt;字体&amp;lt;/InputLabel&amp;gt;
      &amp;lt;Select
        value={currentValue}
        onChange={onChoose}
        MenuProps={HigherMenuProps}
        input={&amp;lt;OutlinedInput labelWidth={labelWidth} name='style' id='select-outlined-label' /&amp;gt;}
      &amp;gt;
        {FONTFAMILY_TYPES.map(({ style, label }: IFontSize) =&amp;gt; (
          &amp;lt;MenuItem key={label} style={fontFamilyStyle(style)} value={style}&amp;gt;{label}&amp;lt;/MenuItem&amp;gt;
        ))}
      &amp;lt;/Select&amp;gt;
    &amp;lt;/FormControl&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，最终实现的也是 toggle 方法，让我们看看父组件里面怎么实现吧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 切换字体大小，将此方法传入子组件，属性为 toggle
const changeFont: (p: string, k: string) =&amp;gt; void = (inlineStyle, key) =&amp;gt; {
  // 储存选择过的颜色，是为了在去除掉以前的样式中用
  let newStyleMap = {}
  const value = getStyleValue(inlineStyle) // 根据内联样式获取对应的 css 样式值

  // 假设这里对字体、字体大小和行高等样式进行处理
  if (key === fontSizeKey) {
    newStyleMap = {
      [inlineStyle]: {
        fontSize: `${value}px`,
      },
    }
  } else if (key === fontFamilyKey) {
    newStyleMap = {
      [inlineStyle]: {
        fontFamily: value,
      },
    }
  } else if (key === lineHeightKey) {
    newStyleMap = {
      [inlineStyle]: {
        lineHeight: value,
      },
    }
  }

  // 更新自定义颜色
  setCustomStyleMap({ ...customStyleMap, ...newStyleMap })
  // 清除旧样式并更新新样式
  setEditorState(toggleSelectionInlineStyle(editorState, inlineStyle, key))
  clearCurrentSelection()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，我们使用了钩子 setCustomStyleMap 来设置了自定义的内联样式，那么同样我们还是需要 Editor 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;customStyleMap&lt;/code&gt; 配置来应用这些样式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;&amp;lt;Editor
  ref={editor}
  blockRenderMap={extendedBlockRenderMap}
  blockStyleFn={getBlockStyle}
  customStyleMap={customStyleMap}
  customStyleFn={customStyleFn}
  editorState={editorState}
  onChange={state =&amp;gt; setEditorState(state)}
  placeholder='写点什么呢...'
  spellCheck={true}
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是有一点需要注意的是，我们新增的自定义样式都是临时的，是根据不同样式类型自动生成的，当我们关闭编辑器保存内容后重新打开时，这些样式如果没有被保存的话，将无法按照它来渲染，因为我们需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;customStyleFn&lt;/code&gt; 来定义渲染规则:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;// 设置样式 key
const styleKeys = {
  fontSizeKey: 'FONTSIZE-',
  fontFamilyKey: 'FONTFAMILY-',
  fontColorKey: 'COLOR-',
  fontBgColorKey: 'BGCOLOR-',
  lineHeightKey: 'LINEHEIGHT-',
}

const removeKey: (p: string) =&amp;gt; string = key =&amp;gt; key.replace('Key', '')

const getFirstElement = (styles: DraftInlineStyle) =&amp;gt; {
  const styleElement: IInlineStyleElement = {}
  Object.keys(styleKeys).forEach((key: string) =&amp;gt; {
    // styles is immutable
    (styleElement as any)[removeKey(key)] = styles.filter((value: any) =&amp;gt; value.startsWith((styleKeys as any)[key])).first()
  })
  return styleElement
}

const customStyleFn: (p: DraftInlineStyle) =&amp;gt; any = style =&amp;gt; {
  const output: any = {}
  // styles immutable
  const { getFirstElement, getStyleValue } = stateToHtmlOptions
  const {
    fontColor, fontBgColor, fontSize, fontFamily, lineHeight,
  } = getFirstElement(style)

  if (fontColor) { output.color = getStyleValue(fontColor) }

  if (fontBgColor) { output.backgroundColor = getStyleValue(fontBgColor) }

  if (fontSize) { output.fontSize = `${getStyleValue(fontSize)}px` }

  if (fontFamily) { output.fontFamily = getStyleValue(fontFamily) }

  if (lineHeight) { output.lineHeight = getStyleValue(lineHeight) }

  return output
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok 完事，至于其他超链接的实现这里就不展示了，上面再讲 entity 的时候，代码已经贴的差不多了。剩下的就是如何导出我们写好的富文本了。&lt;/p&gt;

&lt;h3 id=&quot;导出-html&quot;&gt;导出 html&lt;/h3&gt;

&lt;p&gt;当我们导出 html 标签的时候，我们又需要对不同样式类型进行解析和转换，这里推荐一个库 &lt;a href=&quot;https://www.npmjs.com/package/draft-js-export-html&quot;&gt;draft-js-export-html&lt;/a&gt;，使用方法很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;import {stateToHTML} from 'draft-js-export-html'

const html = stateToHTML(contentState, options)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它支持众多的 options 可选项，具体可以查阅文档，我们这里直接贴例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const options = {
  defaultBlockTag: 'div',
  inlineStyleFn: (styles: DraftInlineStyle) =&amp;gt; {
    // styles immutable
    const {
      fontSize, fontColor, fontBgColor, fontFamily, lineHeight,
    } = getFirstElement(styles)

    let style = {}

    if (fontSize) {
      style = { ...style, 'font-size': getStyleValue(fontSize) }
    }

    if (fontFamily) {
      style = { ...style, 'font-family': getStyleValue(fontFamily) }
    }

    if (fontColor) {
      style = { ...style, color: getStyleValue(fontColor) }
    }

    if (fontBgColor) {
      style = { ...style, 'background-color': getStyleValue(fontBgColor) }
    }

    if (lineHeight) {
      // FIXME: 为了防止自动加上 px，所以暂时采用 !important
      style = { ...style, 'line-height': `${getStyleValue(lineHeight)} !important` }
    }

    if (!isEmptyObject(style)) {
      return {
        element: 'span',
        style,
      }
    }

    return styles
  },
  blockStyleFn: (block: ContentBlock) =&amp;gt; {
    let output
    switch (block.getType()) {
      case ALIGN_KEYS.center:
        output = getAlignStyle('center')
        break
      case ALIGN_KEYS.left:
        output = getAlignStyle('left')
        break
      case ALIGN_KEYS.right:
        output = getAlignStyle('right')
        break
      default:
        break
    }

    return output
  },
  entityStyleFn: (entity: EntityInstance) =&amp;gt; {
    if (entity.getType() === LINK_ENTITY) {
      const { url: href } = entity.getData()
      return {
        element: 'a',
        attributes: {
          href,
          target: '_blank',
        },
        // style: {
        //   // Put styles here...
        // },
      }
    }
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样转换之后，我们就可以得到我们心爱的 html 文本啦，赶紧拿去前台渲染吧 😁&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于 draft.js 开发的也有好多好用的插件和成熟的富文本工具，比如 &lt;a href=&quot;https://braft.margox.cn&quot;&gt;braft-editor&lt;/a&gt; 等，其他关于富文本的库也有很多，比如 &lt;a href=&quot;http://neilj.github.io/Squire/&quot;&gt;squire&lt;/a&gt; 等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5cfe4e8a6fb9a07ec63b09a4#heading-0&quot;&gt;富文本原理了解一下？&lt;/a&gt; By 尤水就下&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.wukai.me/2019/07/21/draftjs-editor-tutorial-1/&quot;&gt;从插入图片功能的实现来介绍如何用 Draft.js 编写富文本编辑器&lt;/a&gt; By 吴锴&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://seejs.me/draft-js-cn/docs/kuai-su-kai-shi/gai-yao.html&quot;&gt;Draft.js 中文翻译文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="JavaScript" /><summary type="html">富文本原理</summary></entry><entry><title type="html">Node 熔断与容灾</title><link href="http://localhost:2333/2019/12/16/node-circuit-breaker.html" rel="alternate" type="text/html" title="Node 熔断与容灾" /><published>2019-12-16T15:51:00+08:00</published><updated>2019-12-16T15:51:00+08:00</updated><id>http://localhost:2333/2019/12/16/node-circuit-breaker</id><content type="html" xml:base="http://localhost:2333/2019/12/16/node-circuit-breaker.html">&lt;h1 id=&quot;node-熔断与容灾&quot;&gt;Node 熔断与容灾&lt;/h1&gt;

&lt;h2 id=&quot;熔断&quot;&gt;熔断&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;熔断(Circuit Breaker)&lt;/strong&gt;直译过来就是断路开关的意思，这是一种代码模式 (pattern)。电路我们都知道，开关闭合，电路通；开关打开，电路断；其实对应我们业务代码简单来讲的话，就是正常情况下每个用户请求过来时，我们正常调用提供服务的接口获取数据（开关闭合），业务正常跑。但是当调用的接口持续出现问题，比如超时或者报错，这时候作为调用方发现了这种情况的出现，应该不再继续去调出错的接口（开关打开）。这样接口（服务）提供方有机会能恢复自身的服务。当然这里说的不再继续调用并不是永远不再调用，而是一段时间内，比如 30s，过了 30s 后会再次尝试调用服务，如果这时候发现服务正常，则我们的接口调用逻辑也恢复。如果失败，那么 30s 后再次尝试，依次类推。&lt;/p&gt;

&lt;h2 id=&quot;容灾&quot;&gt;容灾&lt;/h2&gt;

&lt;p&gt;顾名思义。细想我们刚刚说的熔断里的“开关打开”的情况，当开关打开时，一段时间内我们是不去调用服务的，那么这时候对于用户来的请求该怎么办？最简单的办法就是直接返回一些错误提示，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;service unavailable&lt;/code&gt; 等等。不过我们还有更好的处理方式：当“开关闭合”业务正常跑时，接口是能返回正确的数据的，这时我们可以有选择性的把之前返回的正确数据放入缓存中，如果接口出现问题”开关打开“，我们可以把缓存中的这些数据拿出来返回给用户而不是返回“服务不可用”这样的提示，这就叫容灾。之所以说是有选择性，是因为有些接口的数据可能因人而异，比如每个用户访问都会得到不同于其他人的结果（比如精准投放或者用户推荐），我们只能抽样选择部分接口的数据存入缓存，等接口出问题时再把这些数据返回给所有用户，这时提供的服务是有损的，不过对于容灾来讲已经足够了，至少用户能看到有意义的数据。&lt;/p&gt;

&lt;h2 id=&quot;opossum&quot;&gt;opossum&lt;/h2&gt;

&lt;h3 id=&quot;三种状态&quot;&gt;三种状态&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nodeshift/opossum&quot;&gt;&lt;strong&gt;opossum&lt;/strong&gt;&lt;/a&gt; 是一个基于 Node 的熔断和容灾处理库，举个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const CircuitBreaker = require('opossum')

function asyncFunctionThatCouldFail (x, y) {
  return new Promise((resolve, reject) =&amp;gt; {
    // Do something, maybe on the network or a disk
  })
}

const options = {
  timeout: 3000, // If our function takes longer than 3 seconds, trigger a failure
  errorThresholdPercentage: 50, // When 50% of requests fail, trip the circuit
  resetTimeout: 30000 // After 30 seconds, try again.
}
const breaker = new CircuitBreaker(asyncFunctionThatCouldFail, options)

breaker.fire(params)
  .then(console.log)
  .catch(console.error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以利用回调做一些容灾的工作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;const breaker = new CircuitBreaker(asyncFunctionThatCouldFail, options)
// if asyncFunctionThatCouldFail starts to fail, firing the breaker
// will trigger our fallback function
breaker.fallback(() =&amp;gt; 'Sorry, out of service right now')
breaker.on('fallback', (result) =&amp;gt; reportFallbackEvent(result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://martinfowler.com/bliki/images/circuitBreaker/sketch.png&quot; alt=&quot;circuit breaker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;熔断触发后，&lt;code class=&quot;highlighter-rouge&quot;&gt;circuit breaker&lt;/code&gt; 状态置为 &lt;strong&gt;open&lt;/strong&gt;，open 状态下所有的请求会直接失败或者根据缓存的设定返回容灾数据。当我们设置的 &lt;code class=&quot;highlighter-rouge&quot;&gt;options.resetTimeout&lt;/code&gt; 失效后，比如这里过 30s 后， &lt;code class=&quot;highlighter-rouge&quot;&gt;circuit breaker&lt;/code&gt; 状态置为 &lt;strong&gt;half open&lt;/strong&gt;，请求会再次到 api 服务，如果返回成功，则状态置为 &lt;strong&gt;closed&lt;/strong&gt;，业务正常；如果返回失败，则重新进入 open 状态，且 30s 后重试，如此循环，即 &lt;strong&gt;circuit trip&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When a fallback function is triggered, it’s considered a failure, and the fallback function will continue to be executed until the breaker is closed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://martinfowler.com/bliki/images/circuitBreaker/state.png&quot; alt=&quot;state switch&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;事件监听&quot;&gt;事件监听&lt;/h3&gt;

&lt;p&gt;除了上述的 fallback，我们还可以针对其他一些事件进行监听:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fire - emitted when the breaker is fired.&lt;/li&gt;
  &lt;li&gt;reject - emitted when the breaker is open (or halfOpen).&lt;/li&gt;
  &lt;li&gt;timeout - emitted when the breaker action times out.&lt;/li&gt;
  &lt;li&gt;success - emitted when the breaker action completes successfully&lt;/li&gt;
  &lt;li&gt;failure - emitted when the breaker action fails, called with the error&lt;/li&gt;
  &lt;li&gt;open - emitted when the breaker state changes to open&lt;/li&gt;
  &lt;li&gt;close - emitted when the breaker state changes to closed&lt;/li&gt;
  &lt;li&gt;halfOpen - emitted when the breaker state changes to halfOpen&lt;/li&gt;
  &lt;li&gt;fallback - emitted when the breaker has a fallback function and executes it&lt;/li&gt;
  &lt;li&gt;semaphoreLocked - emitted when the breaker is at capacity and cannot execute the request&lt;/li&gt;
  &lt;li&gt;healthCheckFailed - emitted when a user-supplied health check function returns a rejected promise&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;circuit.on('open',
  () =&amp;gt; $(element).append(
    makeNode(`OPEN: The breaker for ${route} just opened.`)))

circuit.on('halfOpen',
  () =&amp;gt; $(element).append(
    makeNode(`HALF_OPEN: The breaker for ${route} is half open.`)))

circuit.on('close',
  () =&amp;gt; $(element).append(
    makeNode(`CLOSE: The breaker for ${route} has closed. Service OK.`)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;Circuit breakers are a valuable place for monitoring. Any change in breaker state should be logged and breakers should reveal details of their state for deeper monitoring. Breaker behavior is often a good source of warnings about deeper troubles in the environment. Operations staff should be able to trip or reset breakers.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://martinfowler.com/bliki/CircuitBreaker.html&quot;&gt;CircuitBreaker&lt;/a&gt; By Martin Fowler&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="后端" /><category term="Node" /><summary type="html">Node 熔断与容灾</summary></entry><entry><title type="html">JSDoc</title><link href="http://localhost:2333/2019/12/09/js-doc.html" rel="alternate" type="text/html" title="JSDoc" /><published>2019-12-09T20:00:00+08:00</published><updated>2019-12-09T20:00:00+08:00</updated><id>http://localhost:2333/2019/12/09/js-doc</id><content type="html" xml:base="http://localhost:2333/2019/12/09/js-doc.html">&lt;h1 id=&quot;jsdoc&quot;&gt;JSDoc&lt;/h1&gt;

&lt;h2 id=&quot;jsdoc-1&quot;&gt;JSDoc&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jsdoc/jsdoc&quot;&gt;&lt;strong&gt;JSDoc&lt;/strong&gt;&lt;/a&gt; 是根据注释自动生成 API 文档的工具，类似的还有 YUIDoc、JSDuck、ESDoc 等。用法很简单，先安装，之后通过命令行对指定文件进行操作即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 安装
npm i -g jsdoc
# 指定文件
jsdoc example.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;块标签--内联标签&quot;&gt;块标签 / 内联标签&lt;/h3&gt;

&lt;p&gt;JSDoc 注释一般应该放置在方法或函数声明之前，它必须以 &lt;code class=&quot;highlighter-rouge&quot;&gt;/**&lt;/code&gt; 开始，以便由 JSDoc 解析器识别。其他任何以 &lt;code class=&quot;highlighter-rouge&quot;&gt;/*&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/***&lt;/code&gt; 或者超过 3 个星号的注释，都将被 JSDoc 解析器忽略。让我们先看个简单的栗子 🌰:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * Book 类，代表一个书本.
 * @constructor
 * @param {string} title - 书本的标题.
 * @param {string} author - 书本的作者.
 */
function Book(title, author) {
  this.title = title
  this.author = author
}

Book.prototype = {
  /**
   * 获取书本的标题
   * @returns {string|*}
   */
  getTitle() {
    return this.title
  },
  /**
   * 设置书本的页数
   * @param pageNum {number} 页数
   */
  setPageNum(pageNum) {
    this.pageNum = pageNum
  }
}

const book = new Book('柳林风声', '肯尼斯·格雷厄姆')
console.log(book.getTitle())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完命令后我们会默认得到一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;out&lt;/code&gt; 的文件夹，结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;├── out
│  ├── Book.html
│  ├── example.js.html
│  ├── fonts
│  ├── index.html
│  ├── scripts
│  └── styles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/09/HsTKRIEZ8tFUowf.png&quot; alt=&quot;jsdoc-example.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到，JSDoc 为我们提供了&lt;a href=&quot;https://jsdoc.app/index.html&quot;&gt;非常丰富的标签&lt;/a&gt;，它的解析器会对这些标签进行额外处理。这些标签大概可以分成两类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;块标签(Block Tags)&lt;/strong&gt;：以 @ 符号开头，后跟一个空格。如 @param、@example&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;内联标签(Inline Tags)&lt;/strong&gt;：位于块标签内的标签，以 @ 符号开头，内联标签及其文本必须在花括号内，如 {@link}、{@tutorial}&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * @param {string} name - see {@link Person} and {@link Person#getName}
 */
function InlineTag() {}

InlineTag.prototype.getName = function (name) {
  // todo...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的块标签汇总如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * @author Tate
 * @class
 * @name Greetings - 强制 JSDoc 使用这个给定的名称，而忽略实际代码里的名称
 * @description Base Class of Greetings.
 * @param {string} guest
 * @param {Object} options - The options of Greetings. See {@link Option} for detail.
 * @return {Greetings}
 *
 * @example - 描述多个示例
 * // create your Greetings
 * new Greetings(guest, options)
 */
class Greetings {
  /**
   * @private
   * @function
   * @name Greetings#sayHello
   * @description say hello to guest
   */
  sayHello() {
    // todo
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;vscode 结合 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document this&lt;/code&gt; 插件食用最佳，可以自动生成一些基于 JSDoc 规范的注释&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;命令行参数&quot;&gt;命令行参数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;jsdoc&lt;/strong&gt; 命令支持很多参数，具体可以&lt;a href=&quot;https://jsdoc.app/about-commandline.html&quot;&gt;参考这里&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-a &lt;value&gt;, --access &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;Only display symbols with the given access property: private, protected, public, or undefined, or all for all access levels. By default, all except private symbols are shown.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c &lt;value&gt;, --configure &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;The path to a JSDoc configuration file. Defaults to conf.json or conf.json.EXAMPLE in the directory where JSDoc is installed.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d &lt;value&gt;, --destination &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;The path to the output folder for the generated documentation. For JSDoc’s built-in Haruki template, use console to dump data to the console. Defaults to ./out.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–debug&lt;/td&gt;
      &lt;td&gt;Log information that can help debug issues in JSDoc itself.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e &lt;value&gt;, --encoding &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;Assume this encoding when reading all source files. Defaults to utf8.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-h, –help&lt;/td&gt;
      &lt;td&gt;Display information about JSDoc’s command-line options, then exit.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–match &lt;value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;Only run tests whose names contain value.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–nocolor&lt;/td&gt;
      &lt;td&gt;When running tests, do not use color in the console output. On Windows, this option is enabled by default.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p, –private&lt;/td&gt;
      &lt;td&gt;Include symbols marked with the @private tag in the generated documentation. By default, private symbols are not included.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-P, –package&lt;/td&gt;
      &lt;td&gt;The package.json file that contains the project name, version, and other details. Defaults to the first package.json file found in the source paths.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–pedantic&lt;/td&gt;
      &lt;td&gt;Treat errors as fatal errors, and treat warnings as errors. Defaults to false.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-q &lt;value&gt;, --query &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;A query string to parse and store in the global variable env.opts.query. Example: foo=bar&amp;amp;baz=true.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r, –recurse&lt;/td&gt;
      &lt;td&gt;Recurse into subdirectories when scanning for source files and tutorials.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-R, –readme&lt;/td&gt;
      &lt;td&gt;The README.md file to include in the generated documentation. Defaults to the first README.md file found in the source paths.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t &lt;value&gt;, --template &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;The path to the template to use for generating output. Defaults to templates/default, JSDoc’s built-in default template.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-T, –test&lt;/td&gt;
      &lt;td&gt;Run JSDoc’s test suite, and print the results to the console.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u &lt;value&gt;, --tutorials &lt;value&gt;&lt;/value&gt;&lt;/value&gt;&lt;/td&gt;
      &lt;td&gt;Directory in which JSDoc should search for tutorials. If omitted, no tutorial pages will be generated. See the tutorial instructions for more information.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v, –version&lt;/td&gt;
      &lt;td&gt;Displays JSDoc’s version number, then exits.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–verbose&lt;/td&gt;
      &lt;td&gt;Log detailed information to the console as JSDoc runs. Defaults to false.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-X, –explain&lt;/td&gt;
      &lt;td&gt;Dump all doclets to the console in JSON format, then exit.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 将生成的文件自动放入 mydoc 目录下
jsdoc example.js example2.js -d mydocs
# 使用指定模板
jsdoc example.js -t path/to/clean-jsdoc-theme
# 根据配置文件生成
jsdoc example.js -c ./conf.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;

&lt;h4 id=&quot;source&quot;&gt;source&lt;/h4&gt;

&lt;p&gt;jsdoc 配置文件有以下比较重要的几个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;source.include - 可选路径数组，应该包含的&lt;/li&gt;
  &lt;li&gt;source.exclude - 可选路径数组，应该忽略的&lt;/li&gt;
  &lt;li&gt;source.includePattern - 可选正则表达式，所有文件必须匹配，JSDoc 进行扫描&lt;/li&gt;
  &lt;li&gt;source.excludePattern - 任何匹配该正则表达式的文件都被忽略&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JSON&quot;&gt;{
  &quot;source&quot;: {
    &quot;include&quot;: [&quot;./a.js&quot;, &quot;./lib&quot;, &quot;./_private&quot;],
    &quot;exclude&quot;: [&quot;./lib/ignore.js&quot;],
    &quot;includePattern&quot;: &quot;.+\\.js?$&quot;,
    &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置项还支持 templates、plugins 等。详细的&lt;a href=&quot;https://jsdoc.app/about-configuring-jsdoc.html&quot;&gt;请看文档这里&lt;/a&gt; 👈&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JSON&quot;&gt;{
  &quot;plugins&quot;: [], // No plugins are loaded
  &quot;recurseDepth&quot;: 10, // 搭配 -r 参数使用，JSDoc will search for files 10 levels deep
  &quot;source&quot;: {
    &quot;includePattern&quot;: &quot;.+\\.js(doc|x)?$&quot;, // Only files ending in .js, .jsdoc, and .jsx will be processed
    &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; // Any file starting with an underscore, or in a directory starting with an underscore, will be ignored
  },
  &quot;sourceType&quot;: &quot;module&quot;, // JSDoc supports code that uses ES2015 modules
  &quot;tags&quot;: {
    &quot;allowUnknownTags&quot;: true, // JSDoc allows you to use unrecognized tags
    &quot;dictionaries&quot;: [&quot;jsdoc&quot;, &quot;closure&quot;] // Both standard JSDoc tags and Closure Compiler tags are enabled
  },
  &quot;templates&quot;: { // Inline {@link} tags are rendered in plain text
    &quot;cleverLinks&quot;: false,
    &quot;monospaceLinks&quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;templates&quot;&gt;templates&lt;/h4&gt;

&lt;p&gt;这里举一个模板的栗子，比如 &lt;a href=&quot;https://github.com/ankitskvmdam/clean-jsdoc-theme&quot;&gt;clean-jsdoc-theme&lt;/a&gt;，我们直接通过以下命令来使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# 安装
npm install clean-jsdoc-theme -D
# 套用模板
jsdoc example.js -t ./node_modules/clean-jsdoc-theme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/09/aurXhomDEGF1xpe.png&quot; alt=&quot;jsdoc-template&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多模板可以&lt;a href=&quot;https://cancerberosgx.github.io/jsdoc-templates-demo/demo/&quot;&gt;参考这里 jsdoc-templates-demo&lt;/a&gt; 👈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有其他的一些工具，比如有转换成 markdown 格式的 &lt;a href=&quot;https://github.com/jsdoc2md/jsdoc-to-markdown&quot;&gt;&lt;strong&gt;jsdoc-to-markdown&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SHELL&quot;&gt;# npm i -g jsdoc-to-markdown
jsdoc2md example.js &amp;gt; example.md
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * A quite wonderful function.
 * @param {object} - privacy gown
 * @param {object} - security
 * @returns {survival}
 */
function protection (cloak, dagger) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-TEXT&quot;&gt;## protection(cloak, dagger) ⇒ &amp;lt;code&amp;gt;survival&amp;lt;/code&amp;gt;
A quite wonderful function.

**Kind**: global function

| Param  | Type                | Description  |
| ------ | ------------------- | ------------ |
| cloak  | &amp;lt;code&amp;gt;object&amp;lt;/code&amp;gt; | privacy gown |
| dagger | &amp;lt;code&amp;gt;object&amp;lt;/code&amp;gt; | security     |
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;文件类型支持&quot;&gt;文件类型支持&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JSX：JSDoc3.4 版本后支持&lt;/li&gt;
  &lt;li&gt;Typescript - 有一些标签已经支持，&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc&quot;&gt;详细请看这里&lt;/a&gt; 👈&lt;/li&gt;
  &lt;li&gt;vue - jsdoc-vuejs&lt;/li&gt;
  &lt;li&gt;css/sass/less - 如 &lt;a href=&quot;http://sassdoc.com/&quot;&gt;sassdoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-JS&quot;&gt;/**
 * @type {string}
 */
const s

/** @type {Window} */
const win

/** @type {PromiseLike&amp;lt;string&amp;gt;} */
const promisedString

// You can specify an HTML Element with DOM properties
/** @type {HTMLElement} */
const myElement = document.querySelector(selector)
element.dataset.myData = ''

/**
 * @type {string | boolean}
 */
const sb

/** @type {number[]} */
const ns
/** @type {Array&amp;lt;number&amp;gt;} */
const nas
/** @type {(s: string, b: boolean) =&amp;gt; number} Typescript syntax */
const sbn
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.shouce.ren/api/view/a/13232&quot;&gt;JSDoc 中文在线文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="前端" /><category term="JavaScript" /><summary type="html">JSDoc</summary></entry><entry><title type="html">帝王篇 - 秦</title><link href="http://localhost:2333/2019/11/26/history-qin.html" rel="alternate" type="text/html" title="帝王篇 - 秦" /><published>2019-11-26T19:19:00+08:00</published><updated>2019-11-26T19:19:00+08:00</updated><id>http://localhost:2333/2019/11/26/history-qin</id><content type="html" xml:base="http://localhost:2333/2019/11/26/history-qin.html">&lt;h1 id=&quot;帝王篇---秦&quot;&gt;帝王篇 - 秦&lt;/h1&gt;

&lt;p&gt;由于个人比较喜欢听百家讲坛，这个系列只是作为一个笔记，而之前只在本子上记录，也比较松散，看到隋朝时候才打算写入博客 😶，干脆就一起整理下吧 😀&lt;/p&gt;

&lt;h2 id=&quot;秦前-221---前-207&quot;&gt;秦（前 221 - 前 207）&lt;/h2&gt;

&lt;p&gt;前 221 年，秦王&lt;strong&gt;嬴政&lt;/strong&gt;称帝，史称“秦始皇”。前 207 年，刘邦攻占咸阳，继立的&lt;strong&gt;子婴&lt;/strong&gt;贬去帝号，称秦王，向&lt;strong&gt;刘邦&lt;/strong&gt;投降，秦亡。虽然秦朝建立的时间很短，但是如果追溯秦朝建立过程的话，可以回到六百多年前&lt;strong&gt;西周&lt;/strong&gt;周孝王时期的非子。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;秦(前 221 - 前 207)&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;首都&lt;/td&gt;
      &lt;td&gt;咸阳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;君主&lt;/td&gt;
      &lt;td&gt;秦始皇嬴政、秦二世胡亥、秦王子婴&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;成立&lt;/td&gt;
      &lt;td&gt;前 221 嬴政灭六国后称帝&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;灭亡&lt;/td&gt;
      &lt;td&gt;前 207 刘邦攻入咸阳，子婴投降&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;烽火戏诸侯---襄公立国&quot;&gt;烽火戏诸侯 - 襄公立国&lt;/h3&gt;

&lt;p&gt;早在西周时期，非子因善于养马，得到周孝王的赏识，获封秦地，赐姓嬴，成为秦国始封君，号称秦嬴。不过非子只是封地不足五十里的“附庸”，既不是诸侯，也算不上卿和大夫。公元前 858 年，非子去世，之后的族人没有多大作为，直到秦襄公。&lt;/p&gt;

&lt;p&gt;当时西周已经历周厉王和周宣王时期，周厉王与民争利，国人暴动，逃离镐京，天子威风扫地；周宣王虽然前期通过“宣王中兴”的治理挽回一些局势，但是晚年大规模的对外用兵且接连失败耗尽了天子的兵力，加之独断专行、不进忠言、滥杀大臣，宣王中兴遂成昙花一现，反而让诸侯势力更加强大，也为西周在&lt;strong&gt;周幽王&lt;/strong&gt;时期的灭亡埋下伏笔。&lt;/p&gt;

&lt;p&gt;周幽王贪婪腐败，不问政事，任用虢石父为卿士，执掌政事。虢石父为人奸佞乖巧，善于奉承，贪图财利，但周幽王却很重用他，因此引起百姓强烈不满。周幽王八年（前774年），周幽王废嫡立庶，废黜王后申后和太子姬宜臼，而立宠妃&lt;strong&gt;褒姒&lt;/strong&gt;为王后，褒姒所生之子姬伯服为太子，并加害太子姬宜臼，致使申后的父亲申侯大为愤怒。&lt;/p&gt;

&lt;p&gt;褒姒生来不爱笑，周幽王想出各种办法让她笑，但她始终不笑。于是有人建议周幽王点烽火逗她笑，点燃烽火后，诸侯都率兵赶来。诸侯到后却发现没有敌人，褒姒看到诸侯惊慌失措的样子，果然哈哈大笑。周幽王非常高兴，因此多次点燃烽火。后来诸侯们不再相信，渐渐不肯应召而来。周幽王十一年（前771年），申侯联合缯侯、西夷犬戎攻打周幽王，周幽王点燃烽火召集诸侯援救，大部分诸侯却没有前来援救。犬戎最终在骊山之下杀死周幽王，俘虏褒姒，西周灭亡。&lt;/p&gt;

&lt;p&gt;但是勤王的诸侯里，就有秦襄公，作战有功，十分卖力，而且还派兵护送周幽王儿子&lt;strong&gt;周平王&lt;/strong&gt;姬宜臼迁都，建立&lt;strong&gt;东周&lt;/strong&gt;。于是就提拔了秦襄公为侯，赐封给他西戎攻占的岐山以西土地，只要打下来就归他所有，但是秦襄公直至公元前 766 年战死，也未能攻下西戎之地。之后的族人也没有多大作为，直至&lt;strong&gt;秦穆公&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;收复西戎---秦晋之好&quot;&gt;收复西戎 - 秦晋之好&lt;/h3&gt;

&lt;p&gt;秦穆公收复西戎得一人之手，即&lt;strong&gt;由余&lt;/strong&gt;，由余其实是周幽王弟弟周携王的后人。当年周幽王被杀后，朝中大臣遂拥立幽王之弟王子余臣即位，号周携王，而另一方面废太子姬宜臼也在申候等支持下自立，号周平王，于此西周末期形成二王并立局面。后来周平王蛊惑晋文侯势力杀死周携王，确立周平王的王室地位。周携王的族人，兵败逃亡于相邻的西戎。&lt;/p&gt;

&lt;p&gt;至由余时，已在戎地任大夫一职，因为熟悉中原，戎王便派由余出访秦国。时穆公见由余才德，倍加钦慕，便用计使由余留在了秦国。由余任上卿后，及时调整秦国东争战略，改为西进，在由余的帮助下，于前 659 年秦国一举征服西戎十二国，开地千里，称霸西方。正所谓饷公得其名，穆公得其实，同时一举奠定了日后秦国春秋五霸的地位。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;春秋五霸(史记)：齐桓公、晋文公、秦穆公、楚庄王、宋襄公&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;秦穆公取得西戎之地后想东扩，但是东边是实力强大的晋国。晋献公&lt;strong&gt;假道伐虢&lt;/strong&gt;顺带灭了虞国，俘获&lt;strong&gt;百里奚&lt;/strong&gt;，秦穆公亲自向晋献公提亲，晋献公就把大女儿嫁给了他，并用百里奚做陪嫁的奴隶送到秦国。途中百里奚逃跑到楚国宛邑后被扣，秦穆公打听到是个非常有才能的人，于是用五张黑羊皮换了回来。后入秦做大夫，为秦穆公时贤臣，著名的政治家、思想家，又称“五羖大夫”。同时他又推荐了另一个号称比他更有能力的王佐之才&lt;strong&gt;蹇叔&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;晋献公晚年年迈昏庸，受宠最多的妃子骊姬，谎称太子申生要毒死晋献公，借晋献公之手除去申生。于是，晋献公另外两个儿子&lt;strong&gt;夷吾&lt;/strong&gt;(后来的晋惠公)和&lt;strong&gt;重耳&lt;/strong&gt;(后来的晋文公)为了活命，分别逃往他国避难。再后来，晋国臣子里克杀死骊姬的儿子奚齐和她妹妹的儿子卓子，想迎奉重耳回国。公子夷吾以割让黄河以西之地为条件请求秦国发兵，助其返回晋国继位，秦穆公本来也想迎奉重耳，但臣子认为重耳贤能皆胜过夷吾，会让晋国变得强大，从而威胁到自己的国家，于是秦穆公转而迎立夷吾为国君，是为晋惠公。晋惠公继位后，却背约不肯割地，而且畏权杀死里克等老臣，又派人追杀重耳，并且恩将仇报，在秦国闹饥荒时不接济秦国，反倒发兵攻打秦国，终遭惨败，在&lt;strong&gt;韩原之战&lt;/strong&gt;中还被俘虏。最终秦穆公不计前嫌，以诸侯之礼待之，并且送回晋国。晋惠公主动割地，还叫儿子公子圉到秦国做人质，这才将两国的关系修好。&lt;/p&gt;

&lt;p&gt;秦穆公为了掌控公子圉，把自己的女儿怀嬴嫁给了他。然而公子圉听说自己的父亲病了，害怕国君的位置会被传给别人，就扔下妻子，一个人偷偷跑回晋国。第二年，夷吾一死，公子圉就做了晋国君主，是为晋怀公，跟秦国不相往来。没想到晋怀公又是一个忘恩负义的夷吾，秦穆公当然很生气，立即决定要帮助重耳当上晋国国君，重耳在秦穆公的帮助下攻下晋都，并派人杀死晋怀公，晋怀公在位不到一年就身死。秦穆公把女儿怀赢改嫁给了重耳。&lt;/p&gt;

&lt;p&gt;公元前 628 年晋文公和郑文公去世，秦穆公便想借此机会打败晋国，谋求霸业，便命孟明视为大将，西乞术和白乙丙为副将去打晋国，结果大败而归被俘，由于晋襄公的后母是秦穆公的女儿，在她的劝说下便放了他们。于是孟明视操练士卒，演练阵法，为报仇做着不懈的努力，在经过又一次失败后，孟明视开始从自己身上找原因。他认识到自己的指挥才能不够，训练军队和作战的方法也有缺陷。于是他变卖家财，抚恤伤亡将士家属，亲自训练军队，和士兵朝久相处，同甘共苦。秦穆公三十六年（公元前 624 年），孟明视再次请求出征，一路上势如破竹，没几天就把过去被晋军攻占去的城池收了回来。消息传至晋国都城，朝野兵民一片惊慌，不敢迎战。晋襄公无法，只得命令晋军坚守，不得与秦军交战。&lt;/p&gt;

&lt;h3 id=&quot;商鞅变法---合纵连横&quot;&gt;商鞅变法 - 合纵连横&lt;/h3&gt;

&lt;p&gt;春秋战国时期，是分封制崩溃、中央集权制确立的过渡时期，在这一时期，铁制农具的使用和牛耕的逐步推广，导致原有的土地国有制，逐步被土地私有制所代替，地主和农民两大对立的阶级产生。新兴军功地主阶级随着经济实力的增长，要求获得相应的政治权利，从而引起了社会秩序的变动。因此，纷纷要求在政治上进行改革，发展封建经济，建立地主阶级统治。各国纷纷掀起变法运动，如魏国的&lt;strong&gt;李悝变法&lt;/strong&gt;、楚国的&lt;strong&gt;吴起变法&lt;/strong&gt;等。&lt;/p&gt;

&lt;p&gt;到了秦国的&lt;strong&gt;秦孝公&lt;/strong&gt;即位以后，决心图强改革，便下令招贤。&lt;strong&gt;商鞅&lt;/strong&gt;自魏国入秦，并提出了废井田、重农桑、奖军功、实行统一度量和建立县制等一整套变法求新的发展策略，深得秦孝公的信任。经过商鞅变法，秦国的经济得到发展，军队战斗力不断加强，发展成为战国后期最富强的集权国家。&lt;/p&gt;

&lt;p&gt;公元前 338 年，秦孝公去世，其子&lt;strong&gt;秦惠文王&lt;/strong&gt;继位。变法侵犯了贵族们的利益，因之遭到他们的强烈反对。商鞅失去变法的强有力支持者，有口难辩，只得逃亡。最后，商鞅在秦军追捕中毙命，只落得个“车裂”的下场。但变法得以继续实行下去。&lt;/p&gt;

&lt;p&gt;公元前 325 年，自称秦王，成为秦国第一位君王，西举巴蜀，东割膏腴之地，攻灭义渠，稳定西戎。秦国的强大引发了其他六国的担忧和恐惧，两边施行了生存策略和应对策略，即&lt;strong&gt;公孙衍&lt;/strong&gt;、&lt;strong&gt;苏秦&lt;/strong&gt;的合纵和&lt;strong&gt;张仪&lt;/strong&gt;的连横。合纵就是南北纵列的国家联合起来，共同对付强国，阻止齐、秦两国兼并弱国；连横就是秦或齐拉拢一些国家，共同进攻另外一些国家，目的是为了解除合纵。最终，由于六国集团各自心怀鬼胎，时刻把自家利益摆在首位，导致连横的一方取得了胜利。尽管如此，强大的秦国，也在相当长时间内，不敢小视六国的合纵，从一定程度上对抗了强秦吞并六国的野心。&lt;/p&gt;

&lt;p&gt;公元前 311 年秦惠文王病逝，帝位传给了嬴荡，即秦武王。武王性格桀骜不驯而好斗，喜欢和别人比力气，一次与大力士孟说角力比赛举龙文赤鼎时，不料鼎落砸断了胫骨，不治身亡，年仅 23 岁且无嗣。在宣太后芈氏(电视剧里的芈月)和其弟权臣&lt;strong&gt;魏冉&lt;/strong&gt;的操作下，让在燕国做人质的儿子惠文王同父异母的弟弟赢稷继位，即&lt;strong&gt;秦昭襄王&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;昭王称霸---东周灭亡&quot;&gt;昭王称霸 - 东周灭亡&lt;/h3&gt;

&lt;p&gt;魏冉随后平定了王室内部争夺君位的动乱，诛杀惠文后及公子壮、公子雍，将秦武王后驱逐至魏国，肃清了与秦昭襄王不和的诸公子。因秦昭襄王年幼，由宣太后以太后之位主政，魏冉辅政。秦昭襄王四十一年，当时被称为四贵的穰侯魏冉、华阳君芈戎、泾阳君公子芾、高陵君公子悝擅权，出现了私家财富重于秦王室的局面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;范雎&lt;/strong&gt;本是魏国中大夫须贾门客，因被怀疑通齐卖魏而被鞭笞致死，后逃亡至秦。范雎见秦昭王之后，提出了远交近攻的策略，抨击穰侯魏冉越过韩国和魏国而进攻齐国的为己谋利的做法。他主张将韩、魏作为秦国兼并的主要目标，同时应该与齐国等保持良好关系。范遂被拜为客卿，之后，他又提醒昭王，秦国的王权太弱，需要加强王权。秦昭王遂于前 266 年废太后，并将四贵赶出函谷关外，拜范雎为相。&lt;/p&gt;

&lt;p&gt;秦昭襄王在位期间任用白起为将军，先后战胜三晋、齐国、楚国，攻取魏国的河东郡和南阳郡、楚国的黔中郡和郢都。发动长平之战，大胜赵军。秦昭襄王五十一年（公元前 256 年），此时周赧王在位，由于政局混乱，分裂为东西两周国，两部分由东周公和西周公分治。秦国的大将赵掺攻打韩国，攻占了阳城，斩首了四万人。攻打赵国，攻占了二十几个县，斩杀及俘虏了九万人。周赧王姬延非常恐慌，和燕国、楚国密谋联合各国，再订立合纵盟约攻秦。秦国立即起兵攻打西周国，西周君跑到秦国，叩头认罪，把全部三十六邑、三万人口都献给秦昭襄王。秦国将西周君绑在柱子上游街示众，贬为平民，便放其回到西周。同年，周赧王郁愤而终，国权已为西周公与东周公把持，西周公据洛阳，东周公据巩邑。其后不久，西周文公姬咎逝世，西周一地的民众就纷纷向东方逃亡。秦国于是轻易地收取九鼎和其他珍宝，并且未立新王，东周灭亡，同时宣告着历时八百年的周王朝走向终结。公元前 249 年，秦庄襄王灭掉东周公。东、西两周就全都归属于秦国，周王朝的祭祀从此断绝。&lt;/p&gt;

&lt;p&gt;秦昭襄王五十六年（公元前 251 年），昭襄王去世，终年七十五岁。&lt;/p&gt;

&lt;h3 id=&quot;奇货可居---邯郸献姬&quot;&gt;奇货可居 - 邯郸献姬&lt;/h3&gt;

&lt;p&gt;由于昭王在位时间很久，太子早年下世，于是次子安国君改立为太子，即秦孝文王。&lt;strong&gt;异人&lt;/strong&gt;是秦孝文王之子，秦始皇之父，后得到华阳夫人宠爱后改名子楚。异人母子均不受秦孝文王的宠爱，加上他有子二十多人，异人于是被送往赵国邯郸作为质子。其时秦、赵两国关系恶化，不时发生战争，异人倍受冷遇。他缺少出行的车马和日用的财物，生活困窘，十分失意。&lt;/p&gt;

&lt;p&gt;卫国富商&lt;strong&gt;吕不韦&lt;/strong&gt;在邯郸遇到异人，称之“&lt;strong&gt;奇货可居&lt;/strong&gt;”，决定在他身上做笔大买卖，便告之曰：“吾能大子之门”，而异人一开始并瞧不起他，因为士农工商，商人地位低下。吕不韦便给他描绘政治蓝图，异人这才恍然大悟：“必如君策，请得分秦国，与君共之”。之后吕不韦拿出五百金给异人，作为异人在赵国日常生活和交结宾客之用，又拿着另外一半钱进京说服华阳夫人和其弟。华阳夫人最受宠但是无子，而且“以色事人者，色衰而爱驰”，吕不韦告诉她倘若能立异人为太子，这样一来，不是储君的异人也能继位为王，他肯定会感念华阳夫人的恩德，而无子的华阳夫人也因此有了日后的依靠。华阳夫人听从，便让安国君刻下玉符，又送好多礼物给在赵国的异人，请吕不韦教导他，因此异人的名声在诸侯中越来越大。&lt;/p&gt;

&lt;p&gt;吕不韦有一个绝好善舞的妾&lt;strong&gt;赵姬&lt;/strong&gt;，异人在吕不韦家中筵席上看到此女后非常喜欢，就站起身来向吕不韦祝酒，请求把此女赐给他。吕不韦很生气，但转念一想，已经为异人破费了大量家产，为的借以钓取奇货，于是就献出了这个女子。十月后，此女生下儿子&lt;strong&gt;嬴政&lt;/strong&gt;，即之后的秦始皇，异人就立此赵姬为夫人。&lt;/p&gt;

&lt;p&gt;华阳夫人和安国君要求赵国将公子异人遣返秦国，赵国不肯放行，随后吕不韦就去游说赵王。但在赵王打算将异人送回秦国时，两国间却爆发战争。公元前 257 年（秦昭王五十年），派王齮围攻邯郸，情况非常紧急，赵国想杀死异人。异人就和吕不韦密谋，拿出六百斤金子送给守城官吏，得以脱身，逃到秦军大营，这才得以顺利回国。赵国又想杀异人的妻子赵姬和儿子政，以异人夫人是赵国富豪人家的女儿，才得以藏起来，因此母子二人竟得活命。&lt;/p&gt;

&lt;p&gt;公元前 251 年（秦昭王五十六年），昭王去世，太子安国君继位为秦孝文王，华阳夫人为王后，并立异人为太子，尔后赵国也护送子楚的夫人和儿子政回到秦国。秦孝文王由于年事已高，加冕三天而死。于是异人继位，为秦庄襄王，并尊奉华阳王后为华阳太后，生母夏姬为夏太后。公元前 249 年（庄襄王元年），任命吕不韦为丞相，封为文信侯，河南洛阳十万户作为他的食邑。吕不韦家有奴仆万人。三年后，庄襄王薨，子政继位，是为&lt;strong&gt;秦始皇&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;赵姬淫乱---吕不韦之死&quot;&gt;赵姬淫乱 - 吕不韦之死&lt;/h3&gt;

&lt;p&gt;嬴政继位后，尊奉吕不韦为相邦，称他为“仲父”。赵太后由于淫乱不止，常常和前夫吕不韦私通。吕不韦唯恐事情败露，灾祸降临在自己头上，于是招揽了一位门客“猛男”&lt;strong&gt;嫪毐&lt;/strong&gt;，伪装成宦官专门送进宫内服侍赵太后。赵太后暗和他通奸，特别喜爱他。后来赵太后怀孕在身，恐怕别人知道，假称算卦不吉，需要换一个环境来躲避一下，就迁移到雍地的宫殿中居住。嫪毐一直跟着赵太后，得到的赏赐非常丰厚，而太后凡事也都由嫪毐决定。嫪毐的仆人有数千人，希望做官而自愿成为嫪毐门客的，也有上千人，因此嫪毐受宠后成为了一股强大的势力。&lt;/p&gt;

&lt;p&gt;公元前 238 年（秦王政九年），有人告发嫪毐实际并不是宦官，常常和赵太后淫乱私通，并生下两个儿子，都把他们隐藏起来，还和赵太后密谋说“若是秦王死去，就立这儿子继位”。于是嬴政命法官严查此事，把事情真相全部弄清，最终牵连到相国吕不韦。嫪毐发动叛乱失败而被秦王嬴政处以极刑，车裂而死，并夷三族，又杀太后所生的两个儿子，并把赵太后迁到雍地居住。&lt;/p&gt;

&lt;p&gt;秦王想杀掉相国吕不韦，但因他侍奉先王有很大功劳，还有很多宾客辩士为他说情，所以秦王不忍心处罚吕不韦。公元前 237 年（秦王政十年）十月，免去了吕不韦的相邦职务。等到齐人茅焦劝说秦王，秦王这才到雍地迎接赵太后，使她又回归咸阳，但把吕不韦遣出京城，前往河南的封地。又过了一年多，各诸侯国的宾客使者络绎不绝，前来问候吕不韦。秦王恐怕他发动叛乱，就写信给吕不韦说：“你对秦国有何功劳？秦国封你在河南，食邑十万户。你对秦王有什么血缘关系？而号称仲父。你与家属都一概迁到蜀地去居住！”吕不韦一想到自己已经逐渐被逼迫，害怕日后被杀，喝下酖酒自杀而死。&lt;/p&gt;

&lt;p&gt;吕不韦当时门客有三千人，本来是为了储备人才，因为当时战国四公子都有门客数千，秦国这边并不能落后。吕不韦还专门主持编纂了黄老道家名著《吕氏春秋》，此书以儒家学说为主干，以道家理论为基础，融合了杂家思想。本想以此作为大秦统后的意识形态，但后来执政的秦始皇却选择了法家思想，使包括道家在内的诸子百家全部受挫。自从吕不韦死后，秦王政下了《逐客书》，凡是参加吊唁的门客或被免爵或被流放，逐出六国食客，但被门客&lt;strong&gt;李斯&lt;/strong&gt;的《谏逐客书》所劝阻，随即提拔李斯为廷尉。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;战国四公子 - 魏国的&lt;strong&gt;信陵君&lt;/strong&gt;魏无忌、赵国的平原君赵胜、楚国的春申君黄歇、齐国的孟尝君田文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;横扫六合&quot;&gt;横扫六合&lt;/h3&gt;

&lt;p&gt;在李斯的通天大计下，秦王政积极推行统一战略。前 236 年，赵、燕两国发生战争。赵国出兵攻燕，而秦国以救燕为名派王翦等将出兵分别夹攻赵国，先后攻取了赵的阏与等邑，漳水流域已为秦所占有。前 234 年，秦又大举向赵进攻，以所取的赵地建立雁门郡和云中郡。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;始皇帝十六年（前 231 年），魏国被迫把部分土地献秦，韩国亦被迫把南阳地献给了秦。秦派内史腾做南阳假守。始皇帝十七年（前230年），秦派内史腾攻韩，俘虏了韩王安，于韩地建置颍川郡，&lt;strong&gt;【韩亡】&lt;/strong&gt;。这时赵国发生大旱灾。秦将王翦率领土兵直下井陉，秦将杨端和率领河内兵进围赵都邯郸。赵派&lt;strong&gt;李牧&lt;/strong&gt;、司马尚带领大军抵御。赵王宠臣郭开受了秦国贿赂，散布流言说李牧、司马尚谋反。赵王因此改用赵葱和颜聚替李牧、司马尚，并且杀死李牧。&lt;/li&gt;
  &lt;li&gt;始皇帝十八年（前 229 年），&lt;strong&gt;王翦&lt;/strong&gt;大破赵军，杀赵葱，俘虏赵王，&lt;strong&gt;【赵亡】&lt;/strong&gt;。赵公子嘉率领其宗族数百人逃到赵的代郡，自立为代王。秦国在赵都邯郸一带建立邯郸郡。&lt;/li&gt;
  &lt;li&gt;始皇帝二十年（前 227 年），秦始皇派大将王翦、辛胜攻燕国。燕、代两国发兵抵抗，被秦军败于易水以西。次年，秦军攻下燕都蓟城。燕王喜迁都到辽东。秦将李信带兵追击，燕王喜听从代王嘉的计策，杀太子丹，把太子丹的首级献给秦求和。&lt;/li&gt;
  &lt;li&gt;始皇帝二十一年（前 226 年），韩国都城发生叛乱，秦国出兵平定韩的叛乱，乘机处死韩王安。&lt;/li&gt;
  &lt;li&gt;始皇帝二十二年（前 225 年），秦始皇派将军&lt;strong&gt;王贲&lt;/strong&gt;攻魏，包围了魏都大梁，引黄河水灌城，三个月大梁城坏，魏王出降，&lt;strong&gt;【魏亡】&lt;/strong&gt;。秦始皇就在魏的东部地区建立砀郡。同年，秦始皇派李信、蒙武带 20 万大军攻楚。李信攻楚的平舆，蒙武攻楚的寝，取得初步胜利。秦楚两军在城父邑相遇，楚乘秦军不备发起反攻，大败秦军。后秦始皇派王翦带 60 万大军出征，大破楚军于蕲，迫使楚将&lt;strong&gt;项燕&lt;/strong&gt;自杀。接着秦军攻入楚都寿春，俘虏了楚王负刍。秦于楚地设九江郡、长沙郡。&lt;/li&gt;
  &lt;li&gt;始皇帝二十五年（前 222 年），王翦平定了楚的江南地，降服了越国之君，设置会稽郡，&lt;strong&gt;【楚亡】&lt;/strong&gt;。秦始皇在灭楚的同时，不断地向东扩展，陆续设郡，并攻取齐地，设置薛郡。同年，秦始皇派王贲攻燕的辽东，虏燕王喜，&lt;strong&gt;【燕亡】&lt;/strong&gt;。接着又回师攻代，虏代王嘉，建立代郡和辽东郡。&lt;/li&gt;
  &lt;li&gt;始皇帝二十六年（前 221年 ），秦将王贲从燕国南下攻齐，俘虏齐王建，&lt;strong&gt;【齐亡】&lt;/strong&gt;，在齐旧地建立了齐郡和琅邪郡。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;战国七雄 - 齐、楚、燕、韩、赵、魏、秦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;秦国从公元前 230 年起，到灭齐时止，耗时十年陆续兼并了六国，继而于公元前 219 年开始平定南方百越，从此，秦始皇完成统一大业，结束了贵族王侯专政的王国时代，进入了君主的帝国时代。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;灭六国者六国也，非秦也；族秦者秦也，非天下也。 - 杜牧《阿房宫赋》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;韩前-403---前-230&quot;&gt;韩（前 403 - 前 230）&lt;/h4&gt;

&lt;p&gt;韩国是周朝的周王族诸侯国之一，与魏国、赵国合称三晋，国君为姬姓韩氏，是晋国大夫韩武子的后代。韩国以其著名的兵器——弩，为各国所畏惧。所谓“天下之强弓劲弩皆从韩出”，韩国的弩能射 800 米之外，“远者括蔽洞胸，近者镝弇心”。除此以外，韩国的剑也异常锋利，皆“陆断牛马，水截鹄雁”，“当敌则斩坚甲铁幕”。韩国国势最强是韩昭侯在位时。他用法家的&lt;strong&gt;申不害&lt;/strong&gt;为相，内政修明，韩国成小康之治。由于地处中原，韩国被魏国、齐国、楚国和秦国包围，所以完全没有发展的空间，国土也是七国之中最小的一个，使韩国成为山东六国中第一个被秦所灭的诸侯国，于前 230 年覆亡。&lt;/p&gt;

&lt;h5 id=&quot;三家分晋&quot;&gt;三家分晋&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;三家分晋&lt;/strong&gt;是指中国春秋末年，晋国被韩、赵、魏三家瓜分的事件。在历史上，“三家分晋”被视为春秋之终、战国之始的分水岭。一向称为中原霸主的晋国，到了春秋末期，国君的权力也衰落了，实权由六家大夫（韩、赵、魏、智、范、中行）把持，另外还包括郤、栾等大家族。他们各有各的地盘和武装，互相攻打。后来有两家（范、中行）被打散了，还剩下智家、赵家、韩家、魏家。这四家中以智家的势力最大。&lt;/p&gt;

&lt;p&gt;春秋末期，越国王&lt;strong&gt;勾践&lt;/strong&gt;在&lt;strong&gt;范蠡&lt;/strong&gt;帮助下卧薪尝胆，灭掉吴国王&lt;strong&gt;夫差&lt;/strong&gt;，越王勾践率军北上举行诸侯会盟，成为春秋时期最后一位霸主。智伯瑶执政后，对三家大夫赵襄子、魏桓子、韩康子说：“晋国本来是中原霸主，后来被吴、越夺去了霸主地位。为了使晋国强大起来，我主张每家都拿出一百里土地和户口来归给公家，我智家先拿出一个万户邑献给晋公，你们呢？”。随后在威逼下，韩、魏妥协，而赵襄子由于不答应被三队人马包围，之后赵襄子派人说服韩、魏，趁夜水淹智伯瑶大军，并杀掉了智伯瑶。&lt;/p&gt;

&lt;p&gt;韩、赵、魏为了免除后患，开始率军攻打智氏封邑，一次杀智伯家族二百余口，天下震惊！连智家的土地也由三家平分。晋出公大怒，向齐、鲁两国借兵讨伐三卿。韩、赵、魏三卿联手攻打晋出公，出公无力抵抗，只好被迫出逃，结果病死在路上。晋出公死后，宗室姬骄被立为国君，史称晋哀公。以后，他们又把晋国留下的其他土地也瓜分了。&lt;/p&gt;

&lt;p&gt;公元前 403 年，韩、赵、魏三家打发使者上洛邑去见周威烈王，要求周天子把他们三家封为诸侯。周威烈王想不承认也没有用，不如做个顺水人情，就把三家正式封为诸侯。&lt;/p&gt;

&lt;h5 id=&quot;韩非子&quot;&gt;韩非子&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;韩非&lt;/strong&gt;是战国末期带有唯物主义色彩的哲学家，是法家思想之集大成者，韩非将商鞅的「法」，申不害的「术」和慎到的「势」集于一身，并且将老子的辩证法、朴素唯物主义与法融为一体。韩非精于“刑名法术之学”，“而其归本于黄老”。与秦相李斯都是荀子的学生。韩非文章出众，连李斯也自叹不如。韩非目睹战国后期的韩国积贫积弱，多次上书韩王，希望改变当时治国不务法制、养非所用、用非所养的情况，但其主张始终得不到采纳。韩非认为这是“廉直不容于邪枉之臣。”便退而著书，被誉为最得老子思想精髓的两个人之一(另一人为庄周)。&lt;/p&gt;

&lt;p&gt;韩非的书传到秦国，秦王非常赞赏韩非的才华。不久，因秦国攻韩，韩王不得不起用韩非，并派他出使秦国。公元前 233 年，韩非子被韩王派遣出使秦国，秦王很喜欢韩非，倍受赏识和重用。由于李斯提出灭六国一统天下的通天大计，而首要目标就是韩国，但作为韩国公子的韩非与李斯政见相左（韩非主张存韩灭赵），妨碍秦国统一大计，于是李斯就向秦王上疏辩驳，认为韩非是为了保全韩国而有私心，想从秦国取利。秦王政听从了李斯的建议而逮捕韩非，最后逼其服毒自杀。&lt;/p&gt;

&lt;h4 id=&quot;赵前-403---前-222&quot;&gt;赵（前 403 - 前 222）&lt;/h4&gt;

&lt;p&gt;赵国也是自公元前 403 年三家分晋后独立，乃嬴姓赵氏，为商朝名臣飞廉次子季胜之后，原为赵侯。&lt;/p&gt;

&lt;h5 id=&quot;胡服骑射---沙丘宫变&quot;&gt;胡服骑射 - 沙丘宫变&lt;/h5&gt;

&lt;p&gt;赵武灵王即位的时候，赵国正处在国势衰落时期，就连中山那样的邻界小国也经常来侵扰。而在和一些大国的战争中，赵国常吃败仗，大将被擒，城邑被占。赵国眼看着被别国兼并。特别是赵国在地理位置上，东北同东胡相接，北边与匈奴为邻，西北与林胡、楼烦为界。这些部落都是以游牧为生，长于骑马射箭，他们常以骑兵进犯赵国边境。于是便发布胡服骑射的国策，在全国开始了影响深远的“胡服骑射”，全国士兵改变传统的宽大战服改为紧小为特征的胡服，改变传统的步兵为主体的军队结构改为骑兵和弓弩兵为主体的军队构成。经过“胡服骑射”改革的赵国，成为当时除秦国外，国力最强的国家。&lt;/p&gt;

&lt;p&gt;中山虽然不是一流强国，史载“千乘之国”，且处于赵国的心脏地带，给赵国的国家安全和统一带来了极大的威胁。邻近的齐国、燕国与中山相勾结，共同对付赵国。赵武灵王在中山同为白狄族的肥人的后裔&lt;strong&gt;肥义&lt;/strong&gt;的帮助下，展开了对中山的进攻。&lt;/p&gt;

&lt;p&gt;赵武灵王十一年（公元前 315 年），赵国的邻国燕国由于子之之乱发生了严重的政治问题，赵武灵王想通过迎立新的燕王，使燕王能够对赵国感恩，既而与赵国结成稳固的联盟。同时，赵武灵王想破坏燕国与韩国对赵国的夹击盟约。赵武灵王以平叛驱齐为号召，派乐池奉公子职引军入燕，与太子平和匡章的齐军交战，并成功地说服中山王借燕国内乱之机，大举攻燕。中山取得了占领燕国土地数百里、城池几十座的大胜利。齐宣王见赵国插手燕国内政，与齐国为敌，便派遣精锐的齐军，意图在本土之外，借燕国的军备潜能与赵国决战。赵武灵王对公子职和易王后假称齐军强硬，赵军很难战胜齐军，请公子职向外公秦惠王求救，于是在赵武灵王十四年（公元前 312 年），秦惠王派出大军，兵分两路攻齐救燕，齐军很快就被击败了。此后，燕国在相当长的时间里都是赵国和秦国的稳固盟友。赵武灵王十五年，公子职正式登上王位。&lt;/p&gt;

&lt;p&gt;赵武灵王的第一位夫人是韩国国君的女儿，生下太子赵章后不幸去世。赵武灵王后来娶了一个应梦美女名吴娃，她相貌端庄，性格温柔，深得武灵王宠爱。后吴娃生下一子，名何。数年后吴娃病逝，对此赵武灵王十分悲痛，每当想起吴娃，总是愁肠百结，为了报答吴娃对自己的钟爱，赵武灵王决定圆其遗愿。乃废太子章而传王位于吴娃之子何，是为赵惠文王。从此，他自号主父，让曾经辅佐自己坐稳王位的国相肥义教导扶助次子赵何。天赋聪敏的赵何，在肥义的帮助下很快进入了王的角色，学会了治理赵国的一套本领。&lt;/p&gt;

&lt;p&gt;新王赵何日益坐大，不足 50 岁的赵武灵王徒然生起了一种失落感。他看着被废的公子章一副大度无私一如既往的孝敬自己的作派，开始后悔自己当时的一时冲动，废了太子又让了王位。在深感内疚的同时，计划着一个弥补公子赵章的办法。前 296 年，乃封公子章于代，号安阳君，使大臣田不礼佐之。公元前 295 年，赵武灵王经过深思熟虑之后，打算把公子章立为代王。意赵王何和代王两王并行，自己做为父王统治二王东山再起重掌赵国朝政。但这个计划遭到宰相肥义的明确反对。肥义把赵武灵王的想法告诉了赵王何，并一块商议对策。肥义要赵王何做好准备，控制军队，以防事态起变。赵武灵王见肥义不同意，就把此事告诉了公子章和大臣田不礼，暗示他们有所准备，采取必要的行动，夺回王位及权力。&lt;/p&gt;

&lt;p&gt;前 295 年，赵主父携二子赵何与赵章游沙丘宫，赵章与其亲信田不礼谋，乃假主父之命，召赵何。赵何欲往，肥义察觉情形不对，为保赵何，自己先亲往。肥义在去主父宫途中惨遭刀斧手杀害。赵章见事情败露，急领亲兵攻打赵何宫。大臣李兑与公子赵成早有防备，保护赵王何，杀退赵章。赵章见夺位无望，便快马逃入主父宫，求父亲庇护。主父心软，遂纳赵章。很快，李兑、赵成带兵包围主父宫，要求主父交出赵章，主父不允。李兑、赵成乃遣人索之于宫中，得赵章而杀之。李兑、赵成思忖“以章故围主父。即解兵，吾属夷矣！”因之他们俩也想置主父于死地来保证自己的安全。此时赵何是赵国正统的国君，除掉相当于“太上皇”的主父，肯定符合赵何的利益。但是赵何、赵成、李兑谁也不愿意，也不敢担待这弑父弑君之名，便又生一条毒计。赵成、李兑向主父宫中喊话：“后出者夷！”宫中侍从闻此言，如地震来临一般，纷纷外涌，倾巢而出，但唯独不放主父出来，高大巍峨的城墙内只留下主父一人。主父欲出不能，欲食不得，他们不弑君，而是困住主父，让其在宫中自生自灭，最终饿死。&lt;/p&gt;

&lt;h5 id=&quot;纸上谈兵---长平之战&quot;&gt;纸上谈兵 - 长平之战&lt;/h5&gt;

&lt;p&gt;沙丘宫变之后，赵武灵王薨，赵惠文王继位。期间赵国名将名相辈出，如&lt;strong&gt;蔺相如&lt;/strong&gt;、廉颇、&lt;strong&gt;赵奢&lt;/strong&gt;、李牧等，数败秦军。于渑池与秦盟会后，趁秦攻楚的机会出击关东，夺取齐的高唐，又遍击关东诸国，夺取土地。一时在关东声威无两，直至因上党郡归属问题导致的长平之战。在战国中后期，东方三强（魏、齐、楚）相继衰落，秦国之威独步天下之时，赵国时为中流砥柱，其作用可谓是举足轻重。&lt;/p&gt;

&lt;p&gt;赵国对秦国而言可谓是东出的最大的阻碍，秦赵两国统治集团明争暗斗，尔虞我诈，外交伐谋是越演越烈。武灵王使秦、&lt;strong&gt;完璧归赵&lt;/strong&gt;与&lt;strong&gt;渑池相会&lt;/strong&gt;等重大外交事件的发生，就是秦赵双方相互试探、暗中较劲的真实体现。秦昭襄王威震天下，却受辱于赵国大臣蔺相如并非其心甘情愿，实是迫于赵国实力，不敢造次发难、迫不得已耳。这一轮政治外交上的较量，秦国外厉内荏，赵国争锋相对，秦国没有讨得任何便宜。前 269 年秦派大将胡阳率精兵数万越韩境上党进攻赵国的阏与，反被赵奢所统领的赵军精锐突骑所击败。悲壮惨烈的秦赵长平大战就是在这样的时代背景下拉开序幕。&lt;/p&gt;

&lt;p&gt;公元前 262 年，秦国出兵攻伐韩国的野王，野王投降秦国，韩国上党郡与本国的联系被切断。韩桓惠王惧怕秦军兵锋，决定主动把上党郡献给秦国，以息战祸。上党郡守却不愿降秦。韩桓惠王于是派冯亭接替上党郡守遂行降秦的相关事宜，冯亭也不愿降秦，为避免加强秦国，同时利用赵国力量抗秦，他献郡于赵国，赵孝成王接受，封冯亭为华阳君同时仍任上党郡守，派平原君赵胜领五万赵军接收上党。公元前 261 年，秦国进攻韩国，断绝了韩国上党郡与韩国本土的联系。&lt;/p&gt;

&lt;p&gt;公元前 261 年 4 月，秦国派王龁(he)领兵进攻上党，意欲一举兼并之。廉颇领兵二十万救援上党。其时，上党大部分土地已被秦军攻陷，冯亭率残部归附于廉颇军中。赵军于百里石长城全线布防，以故关为重点防御地段。居高临下抵御秦军。秦军进攻受挫，约赵军出长城决战。赵军拒不出战。在廉颇的统御下，赵军坚壁以战成功的遏制了秦军的攻势。秦军攻战数月毫无进展，因补给线漫长后勤压力太大。为扭转局势，秦利用赵国派使者入咸阳和谈的机会，示好于赵，其他诸侯国惧怕秦赵媾和于己不利不敢支援赵国；同时使用反间计，在邯郸散布谣言：“秦之所恶，独畏马服子赵括将耳，廉颇易与，且降矣。”年轻气盛的赵孝成王本自恼怒廉颇军队伤亡很多，屡次战败却坚守营垒不敢出战，谣言四起，不啻于火上浇油。于是赵王力排众议，临阵换将，以自己喜爱的年轻将领赵奢之子赵括替代廉颇为长平前线最高统帅。&lt;/p&gt;

&lt;p&gt;公元前 260 年夏，赵括接管长平前线四十五万赵军。秦国得知消息后秘密派遣武安君&lt;strong&gt;白起&lt;/strong&gt;抵达长平接替王龁指挥秦军。赵括到达前线后，立即改变原有的军事部署和防守战略并撤换大批中下级军官，收缩兵力准备主动出击，企图一战歼灭秦军，收复上党。赵括在对秦军所知甚少的情况下，指挥主力出击屯扎在故关前的秦军部队。秦军按照白起的将令，接战不久后便诈败，沿直通长平的大道逃跑，把追击的赵军主力引诱到预设战场。赵括不知中计，指挥全军猛攻秦军阵地，给予秦军重大杀伤，但秦军顽强抵抗，赵军无法攻破。此时赵军主力已经远离故关 12 公里而被包围。赵孝成王意欲合纵抗秦，遣使求救于临近的楚、魏等国。但由于之前赵国使者入咸阳和谈得秦昭襄王厚遇，诸侯国不愿救赵。赵孝成王只得派出本国的部队赶往长平前线救援。9 月，在被困 46 天后，赵括在突围时被秦军射杀。赵军伤病饿殍无法再战，只得全体投降。秦军俘虏赵军近 40 万人，己方伤亡过半。&lt;/p&gt;

&lt;p&gt;秦军对近 40 万降卒心有余悸。白起假意许诺说准备把降兵中身体强健的带回秦国，而年老体弱伤残幼小的会放归赵国。赵人不疑。白起又以酒肉安抚降卒，后令秦兵以白布裹头，吩咐说“凡首无白布者，即系赵人，当尽杀之。”赵国降卒不曾准备，又无器械，束手就戮。40 万赵军，一夜俱尽。史载当时“血流淙淙有声，杨谷之水皆变为丹，至今号为丹水”。唯有 240 名年纪幼小的赵兵被秦军放归赵国以散布恐慌，震慑山东六国。坑杀赵卒的消息传入赵国，整个国家中“子哭其父，父哭其子，兄哭其弟，弟哭其兄，祖哭其孙，妻哭其夫，沿街满市，号痛之声不绝”。&lt;/p&gt;

&lt;p&gt;长平之战后，白起本拟乘胜灭赵，韩国和赵国惊恐万分，派苏代用重金贿赂秦相应侯范雎，为了防止白起功劳太大，遂以秦兵疲惫，急待休养为由，请求允许韩、赵割地求和。秦昭襄王应允。韩割垣雍，赵割六城以求和，正月皆休兵。白起闻知此事，从此与范雎结下仇怨。之后秦王政不听白起的建议再一次发起邯郸之战，被信陵君窃符救赵，损失惨重。遂强令白起出兵，白起自称病重，经范雎请求，仍称病不起而不发兵，之后被赐死。&lt;/p&gt;

&lt;h5 id=&quot;邯郸之战&quot;&gt;邯郸之战&lt;/h5&gt;

&lt;p&gt;秦虽然取得长平之战的胜利，但士卒死伤过半，粮草消耗巨大，秦无力继续攻邯郸灭赵。且士卒连年征战，士气低靡，战线太长补给困难。加上新占之地民心不固，随时都有可能叛乱。韩魏楚蠢蠢欲动，其侧翼相当不安全，故秦接受了赵国的割地求和。然而，赵在割地上却分歧扩大。最终赵王决定不履行和约，转而备战。秦昭襄王大怒，遂以举国之兵攻赵，邯郸之战爆发。&lt;/p&gt;

&lt;p&gt;秦昭襄王四十八年（前 259 年），赵孝成王六年元月，秦聚兵约五十万人，分兵三路，左路司马梗率军进攻赵之太原，取之，以牵制赵北方主力使不得南下；右路约十万增兵南阳，以拒魏楚联军；中路军约三十万人，直取赵之邯郸。七、八月间，赵之武安、皮牢，两座赵都唯一可依赖的战略屏蔽被秦攻破。次年十月秦围邯郸。赵国采取坚壁清野的战略，集中各地的守军、老弱病残及粮食全力保卫都城邯郸。邯郸城内，天寒地冻，伤员遍城，但士兵依旧士气高昂。平原君赵胜将府内积粮存衣，散布赵民，并令其家人抢救伤员，大将军廉颇带甲上城亲自督战，平原君亦往之。赵兵多弱，廉颇命弱者立城，强者于城内休养，逢战而轮换，又命善射者集而射秦。期间赵之精锐常出城，多有不回，但秦亦伤亡惨重。&lt;/p&gt;

&lt;p&gt;赵军依旧不屈的抵抗着。同时平原君赵胜的外交战开始起作用，至十二月初，终于，魏军八万楚军十万均已赶到邯郸外围，秦国也不断的增兵汾城以为声援，双方大战一触即发。同年十二月，信陵君窃符指挥魏楚联军，对秦军发动了强大的攻势，魏军击于西，楚军击于东，赵军应于内，秦军三面受敌，全线崩溃。王龁率秦军主力向西急退数百里，入汾城才稍事喘息。在邯郸城南驻防的秦军郑安平部约两万人，被赵军重重围困。郑安平部远离主力，粮草断绝，突围无望，只得全军降赵。三国联军乘胜进攻汾城，秦军大败，被迫撤至河西，夹河对峙。联军乘势收复河东六百里之地，其威大震。长平邯郸之战后，赵国实力迅速下滑，再也无力同秦国争霸天下。东方六国从此再也没有一个国家可以单独抗衡秦国。战国进入了诸侯合纵抗秦的时代。&lt;/p&gt;

&lt;p&gt;长平之战、邯郸之战后，赵国实力及其地位一落千丈。廉颇在赵国之败后，被赵王重新任用相国并封为信平君，于赵孝成王十五年破燕军；十六年围燕都；二十一年取魏繁阳。其后因事逃奔魏，后转至楚为将，率军作战因楚兵不如赵兵，战不得志，在寿春抑郁而终，临死思报赵国。庞煖在廉颇出走后，面对秦国、燕国的进攻毅然挑起了赵国的大梁。赵悼襄王三年，燕犯赵，庞煖率军抵。于常山东垣战燕军。此战，赵兵多用强弓劲弩，其伤亡甚重。燕军皆不利。后撤，遇李牧。又撤，遇庞煖。大败。此战死燕兵二万余人，其余的奔溃或投降了赵军。其后与李牧合兵下燕，武遂、方城。赵王赞其曰：“将军武勇，廉颇还赵”。赵悼襄王四年，庞煖统率赵、楚、魏、燕之锐师五十万攻秦。赵悼襄王六年秦长安君及大将军蒙骜率军十万攻赵，庞煖领军十万御之，杀秦军三万，射杀蒙骜。赵国顿时国威大震。&lt;/p&gt;

&lt;p&gt;公元前 247 年魏信陵君率五国联军大破秦国于河外，赵也有参与。其后，燕国派遣当年与乐毅攻齐的剧辛为帅，率军攻赵，赵将李牧、庞煖抵抗，大破燕军，剧辛自杀而死。庞煖击败燕后，组织联军攻秦，举春申君为帅。五国联军与秦军于潼关附近与吕不韦决战，秦将王翦建议先袭最远来的楚军，楚军闻知而逃，四国联军也退。其后一直没有再发生大规模的战斗。&lt;/p&gt;

&lt;p&gt;前 229 年，秦攻赵国，赵幽缪王派李牧、司马尚率军抵抗。秦将使用反间计使幽缪王杀李牧、司马尚。秦将王翦于是率大军攻赵，突破井陉口，前 228 年，攻陷邯郸，俘虏了赵幽缪王。赵嘉逃到代城称代王，前 226 年曾与燕军合兵于易水之西会战秦军，战败后迫使燕王交出太子丹。前 222 年秦军灭代，俘虏赵嘉，赵国亡。&lt;/p&gt;

&lt;h4 id=&quot;魏前-403---前-225&quot;&gt;魏（前 403 - 前 225）&lt;/h4&gt;

&lt;p&gt;魏国也是周朝周王族诸侯国之一，姬姓魏氏，始祖为周文王之子毕公。于公元前 403 年三家分晋后独立，迁都大梁。&lt;/p&gt;

&lt;h5 id=&quot;李悝变法&quot;&gt;李悝变法&lt;/h5&gt;

&lt;p&gt;魏文侯首先执行变法，任用&lt;strong&gt;李悝(kui)&lt;/strong&gt;为相国主持魏国的变法工作和法制建设。经济上，推行“尽地力”和“善平籴”的政策，鼓励农民精耕细作，增强产量。国家在丰年以平价购买余粮，荒年以平价售出，以平粮价；主张同时播种多种粮食作物，以防灾荒；政治上，实行法治，废除维护贵族特权的世卿世禄制，奖励有功国家的人，使魏国成为战国初期强国，其“重农”与“法治”结合的思想对商鞅、韩非影响极大。&lt;/p&gt;

&lt;p&gt;随着魏国的强大，魏文侯派大将乐羊、&lt;strong&gt;吴起&lt;/strong&gt;统帅军队，经过三年苦战，在公元前 407 年北上占领了中山国。并连败秦、齐、楚诸国，开拓大片疆土，使魏国一跃为中原的霸主。魏文侯死后，其子魏武侯即位，魏武侯在位 25 年期间，任用军事家吴起进行改革，国力继续上升，不断东征西讨，夺取楚国在中原的大部分土地，为后来政治中心的东移打下基础。等到魏武侯之子魏惠王在位的时候，魏国已经称霸中原长达百年。&lt;/p&gt;

&lt;h5 id=&quot;围魏救赵&quot;&gt;围魏救赵&lt;/h5&gt;

&lt;p&gt;元前 354 年，赵国进攻卫国。而卫国是魏国保护国，魏国无法坐视不理，于是立即联合宋国出兵助卫反攻，魏卫宋三国联军直逼赵国首都邯郸，赵国被逼闭门防守，并派人向齐国楚国求救。魏卫宋联军于是包围邯郸，希望一举歼灭赵国，以解除被诸国包围之局。&lt;/p&gt;

&lt;p&gt;但是在同一时间，秦国乘魏军主力不在，偷袭魏国少梁，魏国在这场战争里被围攻的危险反而变得更大。齐威王得知赵国被围，本欲立即出兵，但将军段干朋主张延迟出兵，以“承魏之弊”为战略方针。即是先以少量的兵力向南攻击襄陵，以制造假像，可以表示助赵，又可以牵制和疲惫魏国。再待魏军攻陷邯郸，魏、赵双方均已无力再战之时，再给予正面的攻击。齐威王接受了这个提议，在赵魏两军相持一年多，邯郸城快要失陷之时，方才委任&lt;strong&gt;田忌&lt;/strong&gt;为主帅，&lt;strong&gt;孙膑&lt;/strong&gt;为军师，率领齐军主力驰援赵国。&lt;/p&gt;

&lt;p&gt;田忌计划奔赴邯郸，与魏军主力决战，解决邯郸之围。但孙膑认为这不利于齐国，于是提出了更为创新和可行的方法，即“批亢捣虚”与“疾走大梁”。“批亢捣虚”即是避实击虚，攻其必救，使敌人出现后顾之忧，前线之围便会自动解开。“疾走大梁”即是以迅雷不及掩耳之势向魏国重城大梁进逼，以切断魏国的运输要道，并攻其所不备。这样一来，魏军定必回师自救，齐军则可乘其疲惫于路，一举击败魏军，而赵国之围则自动解除。于是田忌采纳了意见，直逼大梁，在此危急存亡之际，虽然邯郸城已攻破，魏军还是不得只以少数兵力留守邯郸，并由主帅&lt;strong&gt;庞涓&lt;/strong&gt;亲率主力回驰大梁。但同时间，齐军已于桂陵设伏，准备截击魏军。魏军由于长期在外作战，已疲态毕露，再加以长途跋涉之急速行军，士兵皆战意大降。于是齐魏一交战，魏军战败。但此役魏国并未受到严重损失，且仍然实现了攻克赵国首都邯郸的战略目标。&lt;/p&gt;

&lt;h5 id=&quot;马陵之战&quot;&gt;马陵之战&lt;/h5&gt;

&lt;p&gt;公元前 343 年，魏国称王，盟友韩国不从。次年，魏国出兵攻打邻近的韩国。韩国遣使向齐国求救。齐威王在征求孙膑的意见后，决定再次坐山观虎斗，待魏韩火拼一番后才出兵救援，这样则“尊名”与“重利”皆得。韩国在拼命抵抗仍五战皆败后，只得再次向齐国求援。齐威王看到魏、韩两国皆元气大伤，认为时机成熟，委任田忌为主帅，田婴为副帅，孙膑任军师，率领齐军直逼魏国首都大梁。再度施展一次围魏救赵，不过这次所要解救的是韩国。魏国为避免重蹈覆彻，于是停止进攻韩国，转而与齐国决战。魏惠王将攻韩的魏军撤回，并任命太子申为上将军，以庞涓为将，统率十万魏军攻向齐军，要与齐军一决雌雄。&lt;/p&gt;

&lt;p&gt;这时齐军已深入魏境，欲退不能，只得与魏军决战。孙膑针对魏军强悍善战，因而轻视齐军的弱点，大打心理战，先向魏军示弱，引诱魏军深入，再施以出其不意的攻击，一举歼灭魏军，并获得主帅田忌采纳。于是孙膑定下了减灶诱敌，设伏聚歼的谋略。即在第一天挖十万人煮食用的灶，第二天减少至只足五万人用，第三天又减少至仅足三万人用，造成齐军士卒四散逃走，兵力不足的假象。庞涓一如孙膑所料，果然中计，接连追击齐军三天，并因看到齐军天天减灶的情况，认定齐军败绩已呈。于是只身带着部分精锐骑兵，日夜兼程追击齐军。孙膑则于魏军必经之处马陵设伏。&lt;/p&gt;

&lt;p&gt;庞涓的骑兵如孙膑所料般于晚上赶至马陵，庞涓看见有一颗树的树皮被剥掉，上面还刻着字，因此停下来，并命人点火照明，以阅读树上所刻的文字。但他还未读完，齐军已万箭齐发，魏军因没有准备，即时溃乱，庞涓中箭，结果被齐军大败。庞涓眼见无法改变局势，只得大叹“遂叫竖子成名”后自杀。齐军再乘胜追击，歼灭魏军十余万人，并俘虏了魏军的主帅太子申，马陵之战以魏军大败而告结束。魏国实力受到严重削弱，从头号强国顿时沦为二流强国。魏国称霸中原的局面一去不复返，此后战国开始了齐国和秦国争霸的局面。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;相传庞涓与孙膑同拜于隐士鬼谷子门下，因嫉妒孙膑的才能，恐其贤于己，因而设计把他的膝盖骨刮去&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;窃符救赵&quot;&gt;窃符救赵&lt;/h5&gt;

&lt;p&gt;公元前 260 年，赵孝成王在和秦国的长平之战中，中了秦国的反间计，用“纸上谈兵”的&lt;strong&gt;赵括&lt;/strong&gt;取代老将&lt;strong&gt;廉颇&lt;/strong&gt;，结果赵国大败，40 多万兵士被秦国坑杀。公元前 257 年，秦国的军队包围了赵国的都城邯郸，赵国的形势非常危急。赵国丞相平原君的妻子是信陵君魏无忌姐姐，平原君赵胜多次向魏安釐王和魏无忌送信，请求魏国救援，魏安釐王派将军晋鄙领兵十万前去救赵。秦昭王得到消息后，派使者威胁魏安釐王，魏安釐王惧怕，就派人通知晋鄙停止进军，留在邺扎营驻防，名义上为救赵，实际在观望形势的发展。&lt;/p&gt;

&lt;p&gt;信陵君屡次请求无效，于是凑齐战车一百多辆，打算带着门客前去赵国和秦军死拼。信陵君到了邺，拿出兵符假传魏安釐王的命令要代替晋鄙担任将领。晋鄙合了兵符，验证无误，但还是表示怀疑，不想交出兵权。此时的信陵君在不得已的情况下，只好杀死晋鄙，强行夺权。楚国也派出春申君黄歇救援赵国，在楚、魏、赵三国的联合下，一举击溃秦国，解除邯郸之围，并于公元前 247 年与其他五国联军，对秦国的侵攻军迎头痛击，攻秦至函谷关，秦国大败。&lt;/p&gt;

&lt;p&gt;信陵君通过窃符救赵，合纵攻秦获得了巨大的威望，魏王担心他会危及自己的地位，所以将其罢免。信陵君知道自己不能再获得魏王的信任，便交出兵权，回到自己的府邸，整日喝酒于夫人为乐。不久，在沉闷苦恼之中，信陵君因酒色过度死去。秦国知道信陵君死后，便加大对魏国的攻伐力度，魏国毫无还手之力。秦王政即位后，对魏国的压力不断加大。最后魏国于公元前 225 年被秦国将军王贲以水淹之计攻破大梁，魏王假降，魏亡。&lt;/p&gt;

&lt;h4 id=&quot;楚前-10421021---前-223&quot;&gt;楚（前 1042/1021 - 前 223）&lt;/h4&gt;

&lt;p&gt;楚国是先秦时期位于长江流域的诸侯国，国君为芈姓熊氏。周成王时期（一说即前1042年-1021年），封楚人首领熊绎为子爵，建立楚国。&lt;/p&gt;

&lt;h5 id=&quot;城濮之战---退避三舍&quot;&gt;城濮之战 - 退避三舍&lt;/h5&gt;

&lt;p&gt;起初，晋国内乱，公子重耳出逃。他到了楚国时，楚成王热情招待他。闲谈中，成王问他：“你将来如回到晋国做国君时，如何来酬谢我？”重耳说：“像财宝这些东西，你们楚国均有的，如果我真能得返晋国，做了晋君，若我们两国不幸要打仗的话，那我就退避你三舍。”&lt;/p&gt;

&lt;p&gt;后来，重耳果真在秦穆公的帮助下做了晋文公。之后，楚国发兵进攻宋国，宋国派人向晋国求救。楚成王见晋欲去救宋，便叫其大将子玉不要去逼近晋师，可是子玉不听，晋文公便叫晋师向后退却，为此，一些将领很不满，说我们是国君率领队伍，他们是臣子作帅，现在君避臣，不是太丢脸了吗？而狐偃说： “出兵要理直，气才会杜盛的。理亏气就会衰。我们国君曾受过楚君的恩惠，也曾说过要退三舍以避之。若我们忘恩失信，那就是理亏，他们就理直，士气就会高。如果我们退了以后，他们仍不撤兵，那就是他们理亏。”于是退避三舍。没想到，子玉竟然追了上去，公元前 632 年，两军对峙于城濮。&lt;/p&gt;

&lt;p&gt;晋文公退避三舍，既是报答以前楚成王给予的礼遇，也是运用”卑而骄之”、”怒而挠之”的诱敌之计，子玉上钩了。结果晋国大胜，晋文公建立了霸权，楚国北进锋芒受到挫折，被迫退回桐柏山、大别山以南地区。中原诸侯无不朝宗晋国。而楚国大将子玉羞愤自杀。&lt;/p&gt;

&lt;h5 id=&quot;伍子胥出逃---鞭尸平王&quot;&gt;伍子胥出逃 - 鞭尸平王&lt;/h5&gt;

&lt;p&gt;楚灵王元年（前 540 年），王子围篡位自立，是为楚灵王。楚灵王是一位立志兴霸、夺取天下的雄心勃勃的君主。为了改变被动局面，几度大规模地对吴国用兵，结果还是无功而罢。楚灵王连年穷兵黩武、对外扩张不止，这次又远离都城对吴用兵，时值寒冬，雨雪连绵，军民不稳。原来被楚灵王打击或剥夺的大姓贵族及其他反对力量，乘机叛乱，夺取政权。楚平王即位后，一反楚灵王之所为，采取休养生息的政策。楚平王“息民五年”后，政局日趋稳定，国势亦渐恢复，即可向外图谋进取时，却因贪恋女色，重用佞臣，从而把楚国引向歧途。迫使足智多谋、颇有才干的&lt;strong&gt;伍子胥&lt;/strong&gt;出逃吴国。&lt;/p&gt;

&lt;p&gt;楚平王十年（前 519 年）秋，吴王僚见形势对吴有利，遂出兵伐楚，大败楚军。楚昭王十年（前 506 年），吴王&lt;strong&gt;阖闾&lt;/strong&gt;派伍子胥、孙武率军攻打楚国，在柏举之战中楚军大败，吴军攻占了楚国的都城郢，楚几乎覆亡。这时越王勾践趁机攻打吴国，秦国也出兵帮助楚国，在这样形势下，楚将子西率领楚军回击吴军，接连取得胜利，光复了楚国。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;吴兵攻进郢都时，伍子胥没找到昭王，于是就掘开楚平王的坟墓，挖出尸体，抽打了三百鞭才罢休&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;楚惠王即位后，各国形势继续出现新的变化。吴王夫差击败越王勾践后，轻视越、楚，全力北上争霸，为伐齐、晋。于楚惠王三年（前 486 年），吴王夫差组织民力，筑城于邗，凿邗江，南引江水，北过高邮西，折东北入射阳湖，淮安北入淮，以通漕运，然后挥师北上，在两次打败齐国、并听信伯嚭谗言迫使伍子胥自杀后，楚惠王七年（前 482 年）大会诸侯于黄池，与晋定公争先歃血。不料越王勾践经整顿休息后，国力已渐恢复，趁夫差北上、国内空虚之机，出兵袭吴，攻破吴都姑苏。夫差闻讯，仓皇回军，但已无能为力，只得以厚礼请和，越王勾践自度一时不能灭吴，就允其和。从此，吴让位于越，已无力再与楚争战，楚国长期受累于东吴的局面，即告结束。&lt;/p&gt;

&lt;h5 id=&quot;吴起变法&quot;&gt;吴起变法&lt;/h5&gt;

&lt;p&gt;吴起本是魏国人，曾于前 389 年阴晋之战中以少胜多，大败秦军。后投奔楚国，楚悼王任命吴起为宛城太守，一年后升任令尹。担任令尹后的吴起在楚国国内进行了大刀阔斧的改革，经过吴起变法后的楚国国力强大，向南攻打百越，将楚国疆域扩展到洞庭湖、苍梧郡一带。公元前 381 年，楚国出兵援助赵国，大败魏军，诸侯都畏惧楚国的强大。但吴起的变法招致了楚国贵族的怨恨，也为自己埋下了杀身之祸。&lt;/p&gt;

&lt;p&gt;前 381 年，楚悼王去世，楚国贵族趁机发动兵变攻打吴起。贵族们用箭射伤吴起，吴起拔出箭逃到楚悼王停尸的地方，将箭插在楚悼王的尸体上，大喊：“群臣叛乱，谋害我王。”贵族们在射杀吴起的同时也射中了楚悼王的尸体。楚国的法律规定伤害国王的尸体属于重罪，将被诛灭三族。楚肃王继位后，命令尹把射杀吴起同时射中楚悼王尸体的人全部处死，受牵连被灭族的有七十多家。吴起的尸身也被处以车裂肢解之刑。吴起死后，他在楚国的变法宣告失败。楚国一时空虚，政局显然也动荡不安。&lt;/p&gt;

&lt;h5 id=&quot;屈原沉江&quot;&gt;屈原沉江&lt;/h5&gt;

&lt;p&gt;楚怀王十七年（前 312 年），楚、秦间的大战全面展开，秦大胜，斩首八万。又攻楚之汉中，取地六百里，仿楚制，亦设置汉中郡。楚怀王十八年（前 311 年），秦又攻楚，攻取了召陵，楚国无力还击。楚怀王三十年（前 299 年），楚怀王被秦昭襄王骗去秦国，客死咸阳，楚国国势迅速衰弱。楚顷襄王时代，秦国多次伐楚，拔西陵、巫、黔中等地，于公元前 278 年攻入楚都郢城，烧毁了楚王族的夷陵，楚顷襄王只好跟那些执政的贵族们一起，狼狈不堪地逃难，&lt;strong&gt;屈原&lt;/strong&gt;自沉于汨罗江，以身殉国。楚顷襄王迁都于陈，聚集了东境的十多万兵力，成功收复之前被攻陷的十五座城池，以此来抵御秦国。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;屈原是中国历史上一位伟大的爱国诗人，中国浪漫主义文学的奠基人，“楚辞”的创立者和代表作家，开辟了“香草美人”的传统，被誉为“楚辞之祖”。其主要作品有《离骚》《九歌》《九章》《天问》等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;鸟飞反故乡兮，狐死必首丘 - 《哀郢》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;路漫漫其修远兮，吾将上下而求索 - 《离骚》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;举世混浊我独清，众人皆醉我独醒 - 《渔父》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前 263 年，楚考烈王继位，任用&lt;strong&gt;春申君&lt;/strong&gt;为令尹，春申君派兵助赵国解邯郸之围，又领兵灭鲁国，楚国一度复兴。但前 241 年，春申君组织东方国家最后一次合纵，但被秦军所败，楚考烈王怕秦国报复，再次迁都至更东面的寿春。前 238 年，楚考烈王死后，春申君门客李园发动政变杀害春申君，楚国国力更加一蹶不振。秦王政亲政后，知楚将项燕擅战，先遣李信为将，领二十万兵马，欲灭楚，败，被入两壁，杀七都尉。再遣老将王翦，统秦师六十万，相持一年，前 223 年，大败楚军，俘虏楚君负。项燕扶持的熊启也很快被俘杀，楚国灭亡。&lt;/p&gt;

&lt;h4 id=&quot;燕前-1044---前-222&quot;&gt;燕（前 1044 - 前 222）&lt;/h4&gt;

&lt;p&gt;燕国是周朝时期的周王族诸侯国之一，始祖是周王族宗室召公，公元前 1044 年，周武王灭商后，封其弟姬奭于燕地，是为燕召公。&lt;/p&gt;

&lt;h5 id=&quot;子之之乱---乐毅改革&quot;&gt;子之之乱 - 乐毅改革&lt;/h5&gt;

&lt;p&gt;前 335 年（燕后文公二十七年），燕、赵、韩、魏、齐、楚六国合纵抗秦。苏秦担任纵约长，并佩带六国相印。前 333 年（燕后文公二十九年），燕文公死，太子继位，即燕易王。易王刚刚即位，齐宣王就趁着给文公办丧事的机会攻打燕国，夺取了十座城池；苏秦到齐国游说，说服齐王把十座城池又归还了燕国。&lt;/p&gt;

&lt;p&gt;前 323 年（燕易王十年），燕国参加了公孙衍发起的韩、魏、赵、燕、中山“五国相王”活动，燕国在此年称王。此年苏秦和燕后文公的夫人通奸，害怕被杀掉，于是就游说易王派他出使齐国去搞反间计，借以扰乱齐国，后被齐人暗杀，其子&lt;strong&gt;苏代&lt;/strong&gt;代之。前 321 年（燕易王十二年），燕易王去世，子哙继位。前 318 年（燕王哙二年），燕王哙将燕王的君位“禅让”给相国子之，并把三百石以上高官的玺印全部收回，交由子之任命，燕国一切政务都由子之裁决。&lt;/p&gt;

&lt;p&gt;前 314 年（子之三年），太子平与将军市被起兵攻击子之并失败，市被死于乱军之中。齐宣王趁机伐燕，将军匡章率军在出兵 50 天内攻破燕国，燕王哙和子之被杀。同时中山国也趁机出兵攻占了燕国部分领土。在燕国军民的奋力抵抗和赵、韩、秦、楚等国的压力下，齐国不得不退兵，&lt;strong&gt;赵武灵王&lt;/strong&gt;拥立在韩为人质的公子职，并以兵护送至燕国，燕国相国子之死后两年，燕国人共同拥立公子职，是为燕昭王。&lt;/p&gt;

&lt;p&gt;燕昭王在易水筑武阳城，励精图治，决心兴复燕国，报仇雪耻，于是招揽了&lt;strong&gt;乐毅&lt;/strong&gt;等一批人才。燕昭王吊祭死者，慰问孤儿，和臣下们同甘共苦，后期又以乐毅改革国政，励精图治，原本弱小的燕国成为一时之强，燕国殷实富足了，士兵都乐于出击，不惧怕战事。&lt;/p&gt;

&lt;h5 id=&quot;伐齐破胡---燕赵之争&quot;&gt;伐齐破胡 - 燕赵之争&lt;/h5&gt;

&lt;p&gt;前 288 年（燕昭王二十八年），燕昭王任命乐毅为上将军，和秦、楚以及赵、魏、韩等国共同谋划，贮备发兵征讨齐国。随后燕昭王派苏秦出使齐国，首先要求齐宣王归还前人趁燕国内乱攻下的十座城池，然后鼓动齐国攻打宋国，离间齐赵两国的关系，并在赵武灵王、魏襄王、楚怀王、韩襄王这些大国王侯之间进行外交游说。&lt;/p&gt;

&lt;p&gt;前 286 年（燕昭王三十年），齐国灭宋国，引起各国震动，各国频繁会盟，推动了反齐联盟的建立。前 284 年（燕昭王三十二年），燕昭王拜乐毅为上将军，率倾国之兵联合秦、韩、赵、魏五国伐齐，获得大胜，五年内连下齐国 70 余城，报了当年齐国入侵燕国之仇。此役后，齐国疆土只剰莒、即墨二都。&lt;/p&gt;

&lt;p&gt;燕昭王时，有燕将秦开，在东胡作为燕国的人质，东胡人很信任他。秦开归国后，起兵袭击大破东胡，“东胡却千余里”，结果燕国边境向东推进了一千多里，大大开拓了燕国的疆域，而燕国亦随即开始修筑北长城。北长城西端起自造阳，向东到达汉城，燕国的疆域到了历史上最大范围。&lt;/p&gt;

&lt;p&gt;前 279 年（燕昭王三十三年），燕昭王死，燕惠王即位。燕惠王为太子时，就与乐毅不合。齐国即墨守将田单知道燕国君臣相疑，利用这点，施反间计，燕惠王中计以骑劫代替乐毅，乐毅担心被杀，便逃亡赵国。骑劫平庸无能，并无军事才能，他代替乐毅为将，造成了燕国军心动摇。田单则故意诱使骑劫犯错误，以激励齐军的士气。田单以火牛阵一战大败燕军，骑劫为齐军所杀，燕军望风而逃，齐军很快就收复了失陷的 70 余城，趁势复国。前 272 年（燕惠王七年），燕国统治集团内部斗争，燕惠王为燕相公孙操所杀，并立惠王子燕武成王为傀儡。&lt;/p&gt;

&lt;p&gt;在燕武成王、孝王、王喜三代，秦国采用远交近攻的策略，为迎合秦国之意或乘赵国危难之机，燕国不断挑起与赵国的争端。前 265 年（燕武成王七年），秦国乘赵国国君新旧交替，政局不稳之际，连取三城，燕与秦南北夹攻，齐国派田单率军救赵，田单西拒秦军之后，又率赵、齐联军对燕国进行报复，占领了燕地中阳。&lt;/p&gt;

&lt;p&gt;前 259 年（燕武成王十三年），燕国趁赵国在长平之战大败之际，诱使赵北部的武垣令傅豹、王容、苏射率众投入燕国。前 251 年（燕王喜四年），秦昭王去世，燕王派国相栗腹和赵国订立友好盟约，送上五百镒黄金给赵王置酒祝寿。栗腹回国报告燕王说赵王国内年轻力壮的人都战死在长平了，他们的孩子还没有长大，可以进攻赵国。燕国派栗腹带军攻赵，赵国派廉颇率兵抵御，栗腹遭斩，廉颇趁势包围了燕国的都城。燕国派任命将渠议和，赵国听了将渠的调处，解除了对燕国的包围。&lt;/p&gt;

&lt;p&gt;前 243 年（燕王喜十二年），赵国派李牧进攻燕国，夺取了武遂和方城。赵国屡困于秦国，又逼走廉颇，以&lt;strong&gt;庞煖&lt;/strong&gt;代将。燕王喜以为有机可乘，问剧辛能不能攻打赵国。剧辛凭借着自己当年与庞煖作朋友时的印象，对庞煖做出了评价，他认为庞煖是很容易打发的人。于是燕国即以老剧辛为帅，伺机进袭赵国。结果剧辛轻敌，率军冒进，被赵军统帅庞煖击败，剧辛被俘杀，燕军损兵二万。前 236 年（燕王喜十九年），赵再次率军伐燕，攻取狸、阳城。燕国屡屡战败，秦国则以救燕为名，不断出兵攻占赵地。&lt;/p&gt;

&lt;h5 id=&quot;荆轲刺秦王&quot;&gt;荆轲刺秦王&lt;/h5&gt;

&lt;p&gt;前 232 年（燕王喜二十三年），在秦国做人质的燕太子丹逃回燕国。前 228 年（燕王喜二十七年），秦破邯郸，赵公子嘉逃到代地，秦军兵临易水，燕国统治集团一片惊惶。太傅鞠武主张与代、齐、楚、匈奴联合共同抗秦，太子丹认识到诸侯均服秦，不可能再组织合纵，而采取刺杀手段。&lt;/p&gt;

&lt;p&gt;前 227 年（燕王喜二十八年），太子丹派&lt;strong&gt;荆轲&lt;/strong&gt;携带燕督亢图和秦叛将樊於期首级，与秦舞阳前往秦国诈降企图刺杀秦王嬴政。荆轲刺秦失败，秦国依此为借口派王翦与辛胜率军大举攻燕，燕、代联军于易水之西组织抵抗，秦军大败燕、代联军。前 226 年（燕王喜二十九年）秦将王翦率军攻破燕都蓟城，燕王喜及太子丹率公室卫军逃辽东。秦将李信带兵乘胜追击至衍水，再败太子丹军，消灭了燕国卫军主力。燕王杀太子丹向秦求和，秦国未允。鉴于燕赵残余势力，已成囊中之物，为集中兵力对付魏楚，暂停进攻。前 222 年（燕王喜三十三年），秦王政派王贲率军进攻辽东，俘虏了燕王喜，燕国灭亡。秦在燕地设渔阳郡、右北平郡、辽西郡及辽东郡等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;风萧萧兮易水寒，壮士一去兮不复还 - 《易水歌》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;齐前-1044---前-221&quot;&gt;齐（前 1044 - 前 221）&lt;/h4&gt;

&lt;p&gt;齐国是周代诸侯国，分为姜姓吕氏齐国和田齐两个时代。疆域为位于今天山东。始封君为周武王国师、军师太公望，即&lt;strong&gt;姜子牙&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&quot;桓公称霸---管仲改革&quot;&gt;桓公称霸 - 管仲改革&lt;/h5&gt;

&lt;p&gt;前 686 年齐大夫连称、管至父弑杀齐襄公，立其堂弟公孙无知即位。齐大夫&lt;strong&gt;鲍叔牙&lt;/strong&gt;早有预感齐国将发生大乱，在襄公在位期间就保护公子&lt;strong&gt;小白&lt;/strong&gt;逃到莒国，另一大夫&lt;strong&gt;管仲&lt;/strong&gt;则协助公子纠逃奔鲁国。前 685 年，齐大臣雍廪杀国君无知与太夫连称，国内无君，公子纠与公子小白争相回国，鲁国派管仲带兵堵截住莒国到齐国的路，管仲一箭射中小白带钩。小白咬舌吐血假装倒地而死，管仲派人回鲁国报捷。这时小白已兼程赶回齐国，高傒迎公子小白回到临淄即位，是为桓公。&lt;/p&gt;

&lt;p&gt;齐桓公即位后，发兵迎击鲁国，鲁人害怕，杀公子纠，管仲被囚禁，桓公要杀管仲，鲍叔牙劝说:“臣幸运地跟从了君上，君上现成为了国君。如果君上只想让齐国成为强国，那么有叔牙和高傒就够了。如果君上想成就天下霸业，那么非管仲不可。管仲到哪个国家，哪个国家就能强盛，不可以失去他。”桓公听从他的建议，假装要杀仇人，把管仲接到齐国。桓公和管仲谈论霸王之术，大喜过望，以其为大夫，委以政事。桓公任管仲为相，推行改革，实行军政合一、兵民合一的制度，齐国逐渐强盛。&lt;/p&gt;

&lt;p&gt;齐桓公于前 681 年在北杏召集宋、陈、蔡、邾四国诸侯会盟，目的是为了平宋国的叛乱，此为诸侯主持天下会盟之始，齐桓公成为历史上第一个充当盟主的诸侯，史称&lt;strong&gt;北杏之会&lt;/strong&gt;。后宋国违背盟约，齐桓公以周天子的名义，率几国诸侯伐宋，迫使宋国求和，此即为“九合诸侯”的第一次。另外，齐桓公还灭了谭、遂、鄣等小国。当时中原华夏各诸侯苦于戎狄等部落的攻击，于是齐桓公打出“尊王攘夷”的旗号，北击山戎，南伐楚国，桓公成为中原霸主，受到周天子赏赐，将齐国的霸业推至高峰。&lt;/p&gt;

&lt;p&gt;桓公晚年昏庸，重用佞臣公子开方、易牙、竖刁等人，当贤臣管仲、鲍叔牙等相继去逝，齐国开始走下坡路。桓公四十三年(前 643 年)，齐桓公重病，五公子互相攻打，齐国一片混乱，齐桓公“身死不葬，虫流出户”。前 642 年春，宋襄公联合曹国、卫国、邾国领兵攻齐，以助公子昭归国争位。三月，迫于诸侯军队的压力，齐众大夫在国氏、高氏两家的率领下诱杀竖刁、无亏，迎立太子昭。但其余四公子的追随者兴兵攻打已入齐境的太子昭，迫使其逃回宋国。同年五月，宋襄公再度发兵，击败齐众公子，太子昭遂得以入齐都临淄即位。此次动乱之后，齐国国力衰落，齐桓公霸业告终。&lt;/p&gt;

&lt;h5 id=&quot;晏婴为相---田氏代齐&quot;&gt;晏婴为相 - 田氏代齐&lt;/h5&gt;

&lt;p&gt;齐国一向由天子二守的国氏、高氏两公族辅政，其后有鲍氏(鲍叔牙之后)、崔氏(齐丁公嫡子季子之后)、庆氏(公子无亏之子庆克之后)、晏氏(晏弱之后)、高氏(惠公子公子祁之后)、栾氏(惠公子公子坚之后)等卿大夫掌政，卿大夫势力日大，互相兼并，更开始废立齐国国君。崔杼迎立庄公光即位，杀太傅高厚，独掌朝政。后来因庄公与崔杼妻棠姜有染，崔杼大怒，联合棠无咎弑君，另立庄公弟公子杵臼为君，即齐景公。前 546 年，左相庆封(庆克之子)攻灭崔氏，崔杼自杀。前 545 年，鲍氏、高氏、栾氏攻灭庆氏，庆封逃到吴国。此后，齐国由上大夫&lt;strong&gt;晏婴&lt;/strong&gt;主持国政。晏婴生活节俭，谦恭下士。对内匡辅国政，屡次劝谏景公，拔擢贤才司马穰苴、越石父等;对外出使别国，机敏善辩，不辱使命，使齐国名扬诸侯。有我们所熟知的&lt;strong&gt;晏子使楚&lt;/strong&gt;的故事。&lt;/p&gt;

&lt;p&gt;前 500 年，晏婴去世，由高、国两家把持朝政。前 489 年，景公病重，遗命国夏、高张扶立少子公子荼为太子，驱逐群公子，迁他们至东莱。不久，田家发动宫廷政变，灭高、国两家，之后独揽齐国大权，尽诛鲍、晏诸族。田氏家族专权于齐平公、宣公、康公三代。&lt;/p&gt;

&lt;p&gt;前 391 年，齐康公被田和放逐于临海的海岛上，“食一城，以奉其先祀”，田和自立为国君，是为齐太公。前 386 年，田和被周安王列为诸侯，姜姓齐国为田氏取代，田和正式称侯，仍沿用齐国名号、世称“田齐”以显示别于姜姓齐国，史称“田氏代齐”，成为“战国七雄”之一。前 379 年，齐康公死，田氏并其食邑，姜太公至此绝祀。&lt;/p&gt;

&lt;p&gt;太公三传至其孙威王时，威王任用邹忌为相改革政治，任用田忌、孙膑为将，齐国遂变得强大。前 353 年，齐国大败魏国于桂陵。前 341 年，齐又大败魏军于马陵，促使庞涓自杀。前 334 年，威王与魏惠王“会徐州相王”，正式称王。威王晚年，国相邹忌与将军田忌争政。前 322 年，田忌中了反间计攻打临淄、谋取邹忌，战败后逃亡至楚国。直至宣王即位后，才召他回国恢复旧职。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;田忌赛马故事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;田单复国&quot;&gt;田单复国&lt;/h5&gt;

&lt;p&gt;前 314 年，燕国发生“子之之乱”。在孟轲劝说下，齐宣王命匡章率 “五都之兵”“北地之众”三十天灭亡燕国，秦赵重兵攻齐，齐国被迫撤兵。前 301 年，齐联合韩、魏国攻楚，大败楚国。前 298 年-前 296 年，齐联合韩、魏连年攻秦，攻入函谷关，迫秦求和。前 288 年十月，秦王称西帝，遣使立齐湣王为东帝，欲约与共伐赵。苏代劝说湣王后，湣王称帝二日后而复归王号。同年十二月，吕礼自齐入秦，秦王亦去帝复称为王。前 286 年，湣王灭宋国，南侵楚国，西侵三晋，齐国势到达巅峰。湣王意欲吞并二周，成为天子。&lt;/p&gt;

&lt;p&gt;前 284 年，燕昭王以乐毅为上将军，合燕、秦、韩、赵、魏攻齐，攻入临淄，连下七十三城，齐城不下者只有莒和即墨。湣王逃入莒，被淖齿杀死。王孙贾与莒人杀淖齿，立湣王子法章为齐襄王。&lt;/p&gt;

&lt;p&gt;燕军引兵东围即墨，城中推举田单为将。双方相持达五年。前 279 年，燕昭王逝世，燕惠王继位，田单使用反间计，使得乐毅被废除职务，燕惠王改派骑劫代替乐毅为将领，乐毅被迫出奔赵国。田单组织反攻，以“火牛阵”大败燕军，收复失地。齐虽复国，但元气大伤，无力再与秦抗衡。&lt;/p&gt;

&lt;p&gt;前 265 年，齐襄王死后由其子田建即位，由母亲君王后辅政。前 249 年，君王后逝世后，王后的族弟后胜执政。后胜为人贪婪，在秦国不断贿赂之下，齐王建听信了后胜的主张，对其余五国袖手旁观，也不加强战备。终于到五国灭亡后，齐王才顿感到秦国的威胁，慌忙将军队集结到西部边境，准备抵御秦军的进攻。前 221 年，秦王在灭亡韩、赵、魏、楚、燕之后，以齐拒绝秦使者访齐为由，命王贲率领秦军伐齐，齐王建令齐军主力 40 万慌忙集结于西部，秦军避开了齐军西部主力，由原来的燕国南部南下直奔齐都临淄。齐军面对秦军突然从北面来攻，措手不及，土崩瓦解。齐王建出城投降，齐国灭亡。秦国统一天下，在齐地设置齐郡和琅邪郡。&lt;/p&gt;

&lt;h3 id=&quot;车同轨---书同文&quot;&gt;车同轨 - 书同文&lt;/h3&gt;

&lt;p&gt;始皇帝二十六年（前 221 年），秦始皇灭六国后，以王号不足以显其业，乃称皇帝。并继续执行孝公变法以来商鞅的法家政策，加强君主专制，削弱旧贵族势力，提拔由军功而上升起来的贵族。秦帝国的土地所有制基本上仍维持西周的“王有”土地制，而变“王有”为“国有”。秦始皇于前216年命令全国农民自报占有田地的实际数额，以便征收赋税。又实行即使是平民，只要有军功也可授予土地及爵位。虽然秦国在商鞅变法时施行了“授田制”，农民的土地名义上是国家所有、私人耕种，但此举让全国百姓实际占有了原来“王有”的土地，不久之后便演变成了农民和官员们都可以自由地买卖田地，所以秦国的商鞅变法最终便利了私有土地的发展。&lt;/p&gt;

&lt;p&gt;秦始皇废除分封制以后，建立了一套自中央到地方的郡县制和官僚制。初分全国为 36 郡，以后随着土地的扩大增至 46 郡，定都咸阳。中央政府最高的官僚是丞相、御史大夫和太尉，亦称“三公”。地方郡的长官为守，县的长官为令。郡县制初步打破了血缘关系的宗法制，封建制、官僚制则代替了贵族的世袭制。为了巩固政权，秦始皇还实行了一系列的政策，主要是：统一货币和度量衡；统一文字；修筑长城、驰道和直道；强迫迁徙六国富民和平民。秦统一六国以后，为了防止六国贵族依持宗族“死灰复燃”，强迫他们迁徒到咸阳，要他们看护皇陵，或者迁徙于西南边远地区，一些平民也同时被迫迁徙，叫做“迁虏”，做开矿、开盐井等苦役。前 215 年，秦将&lt;strong&gt;蒙恬&lt;/strong&gt;夺九原河南，设置 34 县，建立九原郡。&lt;/p&gt;

&lt;p&gt;前 215 年，秦始皇又使燕人卢生求羡门、高誓等仙人踪迹，后来又使韩佟、侯公、石生求仙人不死之药。对于秦始皇这种行为，也有儒生表示劝谏的，博士齐人淳于越建议始皇仍实行分封宗室子弟为诸侯的政策，始皇交给臣下讨论。丞相李斯反对，李斯的奏议促成了秦始皇帝下令焚书禁书，规定史书非秦纪皆烧之；非博士官所职，天下敢有藏《诗》、《书》、百家《论》者，悉诣守、尉杂烧之；有敢偶语《诗》、《书》者，弃市；以古非今者，族。吏见知不举者与同罪。令下三十日不烧，黥为城旦。准保存者，医药卜筮种树之书。若愿学法令，则以吏为师。始皇心里已感到受骗，于是命令御史案问诸生，互相揭发牵连四百六十余人，始皇下令把他们都在咸阳活埋，即为&lt;strong&gt;焚书坑儒&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;沙丘之变---指鹿为马&quot;&gt;沙丘之变 - 指鹿为马&lt;/h3&gt;

&lt;p&gt;前 210 年，秦始皇死于他第五次东巡途中的沙丘宫。秦始皇死后，&lt;strong&gt;赵高&lt;/strong&gt;采取了说服&lt;strong&gt;胡亥&lt;/strong&gt;威胁李斯的手法，二人在沙丘宫经过一番密谋，假造秦始皇发布诏书，由胡亥继承皇位，还以秦始皇的名义指责&lt;strong&gt;扶苏&lt;/strong&gt;为子不孝、蒙恬和蒙毅兄弟为臣不忠，让他们自杀，不得违抗。在得到扶苏自杀的确切消息后，胡亥、赵高、李斯这才命令车队日夜兼程，迅速返回咸阳。&lt;/p&gt;

&lt;p&gt;为了继续欺骗臣民，车队不敢捷径回咸阳，而是摆出继续出巡的架势，绕道回咸阳。由于暑天高温，秦始皇的尸体已经腐烂发臭。为遮人耳目，胡亥一行命人买了许多鲍鱼装在车上，鲍鱼的味道掩盖了尸体的腐臭味，迷惑了大家。回到咸阳后，胡亥继位，是为秦二世，赵高任郎中令，李斯依旧做丞相，但是朝廷的大权实际上落到了赵高手中。赵高阴谋得逞以后，开始对身边的人下毒手，秦二世胡亥在赵高的蛊惑下，对大臣以及始皇帝的皇子、公主展开血腥大屠杀。他又布下陷阱，把李斯逐步逼上死路，李斯发觉赵高阴谋后，就上书告发赵高。秦二世胡亥不仅偏袒赵高，并且将李斯治罪，最后将李斯腰斩于咸阳。赵高升任丞相，由于他可以出入宫禁，特称“中丞相”。&lt;/p&gt;

&lt;p&gt;赵高从一名宦官起家，依仗着秦二世胡亥对他的宠信，把秦朝的暴虐色政推向了顶峰，结党营私，征役更加繁重，行政更加苛暴，从而加速了它的灭亡。事无大小，都完全由他决断，几乎成了太上皇，渐渐不把胡亥放在眼中了。一天，赵高趁群臣朝贺之时，命人牵来一头鹿献给胡亥，说：“臣进献一马供陛下赏玩。”胡亥虽然糊涂，但是鹿是马还是分得清。他失声笑道：“丞相错了，这明明是头鹿，怎么说是马呢？”赵高板起脸地问左右大臣；“你们说这是鹿还是马？”围观的人，有的慑于赵高的淫威，缄默不语；有的惯于奉承，忙说是马；有的弄不清赵高的意图，说了真话。胡亥见众口不一，以为自己是冲撞了神灵，才会认马为鹿，遂召太卜算卦，太卜道：“陛下祭祀时没有斋戒沐浴，故至于此。”胡亥信以为真，便在赵高的安排下，打着斋戒的幌子，躲进上林苑游猎去了。二世一走，赵高便将那些敢于说“鹿”的人纷纷正法。&lt;/p&gt;

&lt;h3 id=&quot;赵高之死---秦三世而亡&quot;&gt;赵高之死 - 秦三世而亡&lt;/h3&gt;

&lt;p&gt;然而，此刻的咸阳城外，已到处卷起了亡秦风暴。陈胜、吴广起义失败后，&lt;strong&gt;项羽&lt;/strong&gt;、&lt;strong&gt;刘邦&lt;/strong&gt;领导的反秦义军以更加迅猛的势头继续战斗。秦二世三年巨鹿一役中，秦军主力被项羽打败，精锐尽失，大将王离被擒。&lt;strong&gt;章邯&lt;/strong&gt;求助不成，恐朝廷降罪，率 20 万大军投降。六国旧贵族见机纷纷自立为王，并力西进。刘邦带着数万兵马迂回进入武关，为了早日攻克咸阳，他派人暗中与赵高联系，希望赵高能作内应。赵高担心胡亥知道后祸及自己，便称病不上朝，私下里暗算着乘乱夺位之事。章邯的倒戈，给了摇摇欲坠的秦王朝一个沉重的打击，胡亥寝食难安，他派使者质问赵高：“丞相不是总说关东盗贼不能成气候吗，令天怎么会到了这种地步？”赵高听了知道二世对自己产生了怀疑与不满，于是秘密与弟弟赵成和女婿阎乐商议对策，制定了弑君政变的计划：由咸阳令阎乐率领手下士兵装扮成山东农民军攻打望夷宫，以郎中令赵成为内应，赵高则负责指挥全局。胡亥无奈之下被逼自杀。&lt;/p&gt;

&lt;p&gt;赵高匆匆赶到现场，摘下了胡亥身上的玉玺佩上，大步走上殿去，仰仗着自己也有着嬴姓赵氏的血统，准备宣布登基。但是文武百官皆低头不从，以无声的反抗粉碎了他的皇帝梦。他这才感到自己的罪恶达到了“天弗与，群臣弗与”的程度，只得临时改变主意，将玉玺传给了王室成员&lt;strong&gt;子婴&lt;/strong&gt;。由于秦的力量已大为削弱，子婴只得取消帝号，复称秦王。子婴早在当公子期间，就已耳闻目睹了赵高的种种罪行。被赵高推上王位，知道自己不过乃是一个傀儡而已。子婴不愿再重蹈胡亥的覆辙，便与自己的贴身宦官韩谈商定了斩除赵高的计划。赵高要子婴斋戒五日后正式即王位。等到期限到了，赵高便派人来请子婴接受王印，正式登基。可子婴推说有病，不肯前往。赵高无奈，只得亲自去请。等赵高一到，宦官韩谈眼疾手快，一刀就将他砍死了。子婴随即召群臣进宫，历数了赵高的罪孽，并夷其三族。同年秦二世三年（前 207 年）十月，刘邦率兵入关，在位仅四十六天的子婴投降刘邦，秦朝灭亡。一个多月后，项羽率军进入咸阳，屠城纵火，杀害子婴。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当年举世欲诛秦，哪记为名与杀身。先去扶苏后胡亥，赵高功盖汉诸臣 - 《咏赵高》。从另一个角度来讲，有人调侃赵高是汉朝刘邦第一大功臣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;然秦以区区之地，致万乘之势，序八州而朝同列，百有余年矣；然后以六合为家，崤函为宫；一夫作难而七庙隳，身死人手，为天下笑者，何也？仁义不施而攻守之势异也。 - 贾谊《过秦论》&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="历史" /><category term="history" /><summary type="html">帝王篇 - 秦</summary></entry></feed>