
<!DOCTYPE>
<html lang="zh-cn" data-scribe-reduced-action-queue="true">

<head>
    <meta content='TypeScript 简介 - Tate & Snow' name='title' />
    <meta content='TypeScript 简介 - Tate & Snow' name='og:title' />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <title>TypeScript 简介 - Tate & Snow</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>TypeScript 简介 - Tate & Snow</title>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript 简介 - Tate & Snow">
<meta name="twitter:keywords" content="TypeScript 简介 - Tate & Snow" property='og:description' />
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript 简介 - Tate & Snow">
<meta name="og:keywords" content="TypeScript 简介 - Tate & Snow|TypeScript 简介什么是 TypeScriptTypeScript 是由微软开发的开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。类型注解特殊类型1、 基础类型Type..."
  property='og:description' />
<link rel="icon" type="image/png" href="http://localhost:2333/style/favicons/favicon.ico" />
<link href="http://localhost:2333/style/favicons/favicon.ico" rel="shortcut icon" type="image/png">
<link rel="canonical" href="http://localhost:2333/">
<link rel="alternate" type="application/rss+xml" title="Liberxue" href="http://localhost:2333/feed.xml">
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="http://localhost:2333/style/favicons/favicon.ico" type="image/x-icon">
<meta name="keywords" content="TypeScript 简介什么是 TypeScriptTypeScript 是由微软开发的开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。类型注解特殊类型1、 基础类型Type..." property='og:description'
/>
<meta name="description" content="Tate & Snow's Github blog" />
<link href="https://cdn.bootcss.com/highlight.js/9.10.0/styles/xcode.min.css" rel="stylesheet">
<link href="http://localhost:2333/style/theme.css" rel="stylesheet"> 
<meta content='http://localhost:2333/2019/02/26/ts-profile.html' property='og:url' />
<meta content="http://localhost:2333/2019/02/26/ts-profile.html|TypeScript 简介什么是 TypeScriptTypeScript 是由微软开发的开源的编程语言。它是 JavaScript 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。类型注解特殊类型1、 基础类型Type..." property='og:description'
/>
<meta content="article" property="og:type" /> 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136311746-1"></script>
<!-- <script async src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script>
  window.dataLayer = window.dataLayer || [];
  window.GA_TRACKING_ID = 'UA-136311746-1'
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('set', {
    'country': 'US',
    'currency': 'USD',
    'description': 'fuck',
  });
  gtag('config', GA_TRACKING_ID, {
    'custom_map': {
      'dimension1': 'post_title',
    },
    'post_title': 'test',
  });
</script>
<meta content="" property="fb:app_id" />
<script>
  (function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s);
    js.id = id;
    js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

</head>

<body class="dark-theme" gtools_scp_screen_capture_injected="true">
    <header id="header" class="header bg-white">
        <div class="navbar-container">
            <a href="Javascript:;" onclick="onClickLogo()" title="访问 Tate & Snow" class="navbar-logo menu-logo">
                <img src="https://i.loli.net/2018/03/13/5aa74f5b4c2c7.png" alt="Tate & Snow"> </a>
            <!-- <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">Tate & Snow</a>   -->
            <div class="navbar-menu">
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('首页', '/')" title="访问 首页" data-hover="首页">首页</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('前端', '/front')" title="访问 前端" data-hover="前端">前端</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('框架', '/tool')" title="访问 框架" data-hover="框架">框架</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('后端', '/back')" title="访问 后端" data-hover="后端">后端</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('标签', '/tags')" title="访问 标签" data-hover="标签">标签</a>
                
                  <a class=" menu-item-about " href="Javascript:;" onclick="onClickMenu('关于', '/README')" title="访问 关于" data-hover="关于">关于</a>
                
            </div>
            <!-- <div class="navbar-menu">
                
                <a href="http://localhost:2333/">首页</a>
                
                <a href="http://localhost:2333/front">前端</a>
                
                <a href="http://localhost:2333/tool">框架</a>
                
                <a href="http://localhost:2333/back">后端</a>
                
                <a href="http://localhost:2333/tags">标签</a>
                
                <a href="http://localhost:2333/README">关于</a>
                
            </div> -->
            <div class="navbar-search menu-item-search" onclick="onClickSearch()">
                <span class="icon-search"></span>
                <form id="cb-search-btn" role="search">
                    <span class="search-box">
                        <input type="text" class="input" id="cb-search-content" required="true" placeholder="标题 标签..." maxlength="30" autocomplete="off">
                    </span>
                </form>
            </div>
            <div class="navbar-mobile-menu" onclick="">
                <span class="icon-menu cross">
                    <span class="middle"></span>
                </span>
                <ul>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('首页', 'http://localhost:2333/')">首页</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('前端', 'http://localhost:2333/front')">前端</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('框架', 'http://localhost:2333/tool')">框架</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('后端', 'http://localhost:2333/back')">后端</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('标签', 'http://localhost:2333/tags')">标签</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('关于', 'http://localhost:2333/README')">关于</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </header>
    <a href="#header" class="back-to-top" onclick="onClickTop('TypeScript 简介')">⤴Top⤴</a>
    <div class="post-header-thumb bg-white}">
        <div class="post-header-thumb-op"></div>
        <div class="post-header-thumb">
            <div class="post-header-thumb-container">
                <h1 class="post-title" itemprop="name headline">
                    TypeScript 简介</h1>
                <div class="post-data">
                    <time datetime="2019-02-26 17:54:00" itemprop="datePublished">
                      发布时间：2019-02-26 17:54:00
                      &nbsp;&nbsp;&nbsp;
                      
                        修改时间：2019-05-20 16:34:00
                      
                    </time>
                    <a onclick="onClickCategory('前端')" href="Javascript:;" title="访问 前端" data-hover="博客分类: 前端">博客分类: 前端</a>
                    <!-- <a href="#read"> 阅读次数: comments</a>  -->
                </div>
                <div class="post-tags">
                       
                    <a class="menu-item-tags" href="Javascript:;" onclick="onClickTag('TS')" title="访问TS" data-hover="TS">
                        TS
                        <span>(2)</span>
                        
                    </a>
                       
                </div>
            </div>
        </div>
    </div>
    <article class="main-content post-page" itemscope itemtype="http://schema.org/Article">
        <div class="post-header">
            <h1 class="post-title" itemprop="name headline">
                TypeScript 简介</h1>
            <div class="post-data">
                <time datetime="2019-02-26 17:54:00" itemprop="datePublished">2019-02-26 17:54:00</time>
            </div>
        </div>
        <div id="post-content" class="post-content" itemprop="articleBody">
            <p class="post-tags">
                   
                <a href="Javascript:;" onclick="onClickTag('TS')" title="访问TS" data-hover="TS">
                    TS
                    <span>(2)</span>
                    </a>
                   
            </p>
            <h1 id="typescript-简介">TypeScript 简介</h1>

<h2 id="什么是-typescript">什么是 TypeScript</h2>

<p><strong>TypeScript</strong> 是由微软开发的开源的编程语言。它是 <strong>JavaScript</strong> 的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。</p>

<h2 id="类型注解">类型注解</h2>

<h3 id="特殊类型">特殊类型</h3>

<p>1、 基础类型</p>

<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，<strong>类型注解</strong>使用 <code class="highlighter-rouge">:TypeAnnotation</code> 语法:</p>

<pre><code class="language-JS">// 布尔值
const isDone: boolean = false
// 数字
const decLiteral: number = 6
// 字符串
const name: string = 'tate'
// 数组
const list: number[] = [1, 2, 3]
const list: Array&lt;number&gt; = [1, 2, 3] // 第二种方式是使用数组泛型，Array&lt;元素类型&gt;
</code></pre>

<p>2、 元组</p>

<p><strong>元组</strong>类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同:</p>

<pre><code class="language-JS">// Declare a tuple type
let x: [string, number]
// Initialize it
x = ['hello', 10] // OK
// Initialize it incorrectly
x = [10, 'hello'] // Error
</code></pre>

<p>3、 枚举</p>

<p><strong>enum</strong> 类型是对 JavaScript 标准数据类型的一个补充:</p>

<pre><code class="language-JS">enum Color {Red, Green, Blue}
const c: Color = Color.Green
</code></pre>

<p>默认情况下，从 0 开始为元素编号。 当然也可以手动的指定成员的数值:</p>

<pre><code class="language-JS">enum Color {Red = 1, Green, Blue}
const colorName: string = Color[2] // 'Green'
</code></pre>

<blockquote>
  <p>枚举类型的值，不仅可以是数字类型，也可以是字符串类型。</p>
</blockquote>

<p>可以使用 enum + namespace 的声明的方式向枚举类型添加静态方法:</p>

<pre><code class="language-JS">enum Weekday {
  Monday,
  Tuseday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}

namespace Weekday {
  export function isBusinessDay(day: Weekday) {
    switch (day) {
      case Weekday.Saturday:
      case Weekday.Sunday:
        return false;
      default:
        return true;
    }
  }
}

const mon = Weekday.Monday;
const sun = Weekday.Sunday;

console.log(Weekday.isBusinessDay(mon)); // true
console.log(Weekday.isBusinessDay(sun));
</code></pre>

<p>4、 Any</p>

<p><strong>Any</strong> 类型是指定那些在编程阶段还不清楚类型的变量，这些值可能来自于动态的内容:</p>

<pre><code class="language-JS">let notSure: any = 4
notSure = 'maybe a string instead'
notSure = false // okay, definitely a boolean
const list: any[] = [1, true, 'free']
</code></pre>

<p>5、 Void</p>

<p>当一个函数没有返回值时，其类型可以用 <strong>void</strong>:</p>

<pre><code class="language-JS">function warnUser(): void {
  console.log('This is my warning message')
}

// 声明一个void类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null
const unusable: void = undefined
</code></pre>

<p>6、 Never</p>

<p><strong>never</strong> 类型表示的是那些永不存在的值的类型。 比如那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型:</p>

<pre><code class="language-JS">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message)
}
</code></pre>

<blockquote>
  <p>void 指可以被赋值的类型(在 strictNullChecking 为 false 时)，但是 never 不能赋值给其他任何类型，除了 never。</p>
</blockquote>

<h3 id="联合类型-">联合类型 |</h3>

<p><strong>联合类型</strong>用于限制传入的值的类型只能是分隔的每个类型，如：<code class="highlighter-rouge">number | string | boolean</code> 表示一个值的类型只能是 number、string、boolean 中的一种:</p>

<pre><code class="language-JS">interface Bird {
  fly()
  layEggs()
}
interface Fish {
  swim()
  layEggs()
}
let pet = getPet() // getPet() 的返回值类型是`Bird | Fish` 
pet.layEggs() // 允许
pet.swim() // 报错
</code></pre>

<h3 id="类型保护-is">类型保护 is</h3>

<p>联合类型可以让一个值可以为不同的类型，但随之带来的问题就是访问非共同方法时会报错。那么该如何区分值的具体类型，以及如何访问共有成员呢？我们可以使用后面要介绍的类型断言:</p>

<pre><code class="language-JS">let pet = getPet()
if ((&lt;Fish&gt;pet).swim) {
  (&lt;Fish&gt;pet).swim()
} else {
  (&lt;Bird&gt;pet).fly()
}
</code></pre>

<p>我们可以看到这种书写方式很麻烦。那么有没有更好的方式可以判断类型呢？答案是：使用类型保护，如写一个类型判断函数，形式为 <code class="highlighter-rouge">param is SomeType</code>:</p>

<pre><code class="language-JS">function isFish(pet: Bird | Fish): pet is Fish {
  return (&lt;Fish&gt;pet).swim !== undefined
}
</code></pre>

<p>这样之后，我们改写上面的判断:</p>

<pre><code class="language-JS">if (isFish(pet)) {
  pet.swim()
} else {
  pet.fly()
}
</code></pre>

<h3 id="类型别名-type">类型别名 type</h3>

<p><strong>类型别名</strong>可以通过 <strong>type</strong> 关键字给一个类型起个新名字，常用于联合类型:</p>

<pre><code class="language-JS">type Name = string
type NameResolver = () =&gt; string
type NameOrResolver = Name | NameResolver
function getName(n: NameOrResolver): Name {
  if (typeof n === 'string') {
    return n
  }
  return n()
}
</code></pre>

<pre><code class="language-JS">export type QRCodeErrorCorrectionLevel = "low" | "medium" | "quartile" | "high" | "L" | "M" | "Q" | "H"
</code></pre>

<h3 id="类型断言-as">类型断言 as</h3>

<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。类型断言有两种形式:</p>

<ul>
  <li><strong>尖括号语法</strong></li>
  <li><strong>as 语法</strong></li>
</ul>

<pre><code class="language-JS">// 尖括号语法
const someValue: any = 'this is a string'
const strLength: number = (&lt;string&gt;someValue).length
// as 语法(推荐)
const strLength: number = (someValue as string).length
</code></pre>

<p>类型断言的一个常见用例是当你从 JavaScript 迁移到 TypeScript 时:</p>

<pre><code class="language-JS">const foo = {};
foo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’
foo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'
</code></pre>

<p>这里的代码发出了错误警告，因为 foo 的类型推断为 {}，即是具有零属性的对象。因此，你不能在它的属性上添加 bar 或 bas，你可以通过类型断言来避免此问题:</p>

<pre><code class="language-JS">interface Foo {
  bar: number;
  bas: string;
}

const foo = {} as Foo;
foo.bar = 123;
foo.bas = 'hello';
</code></pre>

<p>让我们再看看<strong>双重类型断言</strong>的栗子:</p>

<pre><code class="language-JS">function handler(event: Event) {
  // const mouseEvent = event as MouseEvent;
  const element = event as HTMLElement; // Error: 'Event' 和 'HTMLElement' 中的任何一个都不能赋值给另外一个
}
</code></pre>

<p>此时如果你仍然想使用那个类型，你可以使用双重断言。首先断言成兼容所有类型的 any，编译器将不会报错:</p>

<pre><code class="language-JS">function handler(event: Event) {
  const element = (event as any) as HTMLElement; // ok
}
</code></pre>

<h2 id="接口-interface">接口 Interface</h2>

<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做’鸭式辨型法’或’结构性子类型化’。 在 TypeScript 里，<strong>接口</strong>的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>

<pre><code class="language-JS">// 不使用接口
// printLabel 有一个参数，并要求这个对象参数有一个名为 label 类型为 string 的属性
function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label)
}

let myObj = { size: 10, label: 'Size 10 Object' }
printLabel(myObj)
</code></pre>

<pre><code class="language-JS">// 使用接口
// 代表了有一个 label 属性且类型为 string 的对象
interface LabelledValue {
  label: string
  size?: number // 可选属性
  gender?: 'man' | 'woman'
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label)
}

let myObj = {size: 10, label: 'Size 10 Object'}
printLabel(myObj)
</code></pre>

<h3 id="readonly">readonly</h3>

<p>一些对象属性只能在对象刚刚创建的时候修改其值。可以在属性名前用 <strong>readonly</strong> 来指定只读属性:</p>

<pre><code class="language-JS">interface Point {
  readonly x: number
  readonly y: number
}
let p1: Point = { x: 10, y: 20 }
p1.x = 5 // error!
</code></pre>

<p>TypeScript 具有 <strong>ReadonlyArray&lt;T&gt;</strong> 类型，它与 <strong>Array&lt;T&gt;</strong> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改:</p>

<pre><code class="language-JS">let a: number[] = [1, 2, 3, 4]
let ro: ReadonlyArray&lt;number&gt; = a
ro[0] = 12 // error!
ro.push(5) // error!
ro.length = 100 // error!
a = ro // error!
</code></pre>

<h3 id="索引签名">索引签名</h3>

<p>如果能够确定某个对象可能具有某些做为特殊用途使用的额外属性，还能够添加一个字符串<strong>索引签名</strong>:</p>

<pre><code class="language-JS">interface SquareConfig {
  color?: string
  width?: number
  [propName: string]: any
}
</code></pre>

<p>接口除了描述带有属性的普通对象外，也可以描述函数类型:</p>

<pre><code class="language-JS">interface SearchFunc {
  (source: string, subString: string): boolean
}

let mySearch: SearchFunc
// 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量
mySearch = function(source: string, subString: string) {
  const result = source.search(subString)
  return result &gt; -1
}
</code></pre>

<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[‘daniel’]。可索引类型具有一个<strong>索引签名</strong>，它描述了对象索引的类型，还有相应的索引返回值类型:</p>

<pre><code class="language-JS">interface StringArray {
  [index: number]: string
}

let myArray: StringArray
myArray = ['Bob', 'Fred']

const myStr: string = myArray[0]
</code></pre>

<h3 id="类类型">类类型</h3>

<p>TypeScript 能够用它来明确的强制一个类去符合某种契约:</p>

<pre><code class="language-JS">// 接口描述了类的公共部分
interface ClockInterface {
  currentTime: Date
  setTime(d: Date) // 可以在接口中描述一个方法，在类里实现它
}

class Clock implements ClockInterface {
  currentTime: Date
  setTime(d: Date) {
    this.currentTime = d
  }
  constructor(h: number, m: number) { }
}
</code></pre>

<p>类是具有两个类型的：静态部分的类型和实例的类型。我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，<code class="highlighter-rouge">ClockConstructor</code> 为构造函数所用和 <code class="highlighter-rouge">ClockInterface</code> 为实例方法所用:</p>

<pre><code class="language-JS">interface ClockConstructor {
  new (hour: number, minute: number): ClockInterface
}
interface ClockInterface {
  tick()
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
  return new ctor(hour, minute)
}

class DigitalClock implements ClockInterface {
  constructor(h: number, m: number) { }
  tick() {
    console.log('beep beep')
  }
}
class AnalogClock implements ClockInterface {
  constructor(h: number, m: number) { }
  tick() {
    console.log('tick tock')
  }
}

let digital = createClock(DigitalClock, 12, 17)
let analog = createClock(AnalogClock, 7, 32)
</code></pre>

<h3 id="接口继承">接口继承</h3>

<p>和类一样，接口也可以相互继承:</p>

<pre><code class="language-JS">interface Shape {
  color: string
}

interface PenStroke {
  penWidth: number
}

// 一个接口可以继承多个接口，创建出多个接口的合成接口
interface Square extends Shape, PenStroke {
  sideLength: number
}

let square = &lt;Square&gt;{}
square.color = 'blue'
square.sideLength = 10
square.penWidth = 5.0
</code></pre>

<p>接口也可以继承类，它会继承类的成员但不包括其实现。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现:</p>

<pre><code class="language-JS">class Control {
  private state: any
}

// SelectableControl 包含了 Control 的所有成员，包括私有成员 state
// 因为 state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口
interface SelectableControl extends Control {
  select(): void
}

class Button extends Control implements SelectableControl {
  select() { }
}

class TextBox extends Control {
  select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
  select() { }
}
</code></pre>

<h2 id="泛型-generics">泛型 Generics</h2>

<h3 id="类型变量">类型变量</h3>

<p><strong>泛型</strong>支持多种类型的数据，增强了组件的可复用性。我们需要一种方法使返回值的类型与传入参数的类型是相同的:</p>

<pre><code class="language-JS">// 类型变量 T 帮助我们捕获用户传入的类型，之后我们再次使用了 T 当做返回值类型
// 此时函数 identity 即叫做泛型，类型变量 T 代表的是任意类型
function identity&lt;T&gt;(arg: T): T {
  console.log(arg.length)  // Error: T doesn't have .length
  return arg
}
</code></pre>

<pre><code class="language-JS">// 如果我们传入数字数组，将返回一个数字数组
function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
  console.log(arg.length) // Array has a .length, so no more error
  return arg
}
// or
function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
  console.log(arg.length)  // Array has a .length, so no more error
  return arg
}
</code></pre>

<p>当然我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以:</p>

<pre><code class="language-JS">let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity

// 还可以使用带有调用签名的对象字面量来定义泛型函数
let myIdentity: {&lt;T&gt;(arg: T): T} = identity
</code></pre>

<p>我们定义了泛型函数后，可以通过两种方法来使用，推荐使用第二种，因为类型推论可帮助我们保持代码精简和高可读性:</p>

<pre><code class="language-JS">// 第一种是，传入所有的参数，包含类型参数
let output = identity&lt;string&gt;('myString')  // type of output will be 'string'

// 第二种方法更普遍。利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定 T 的类型
let output = identity('myString')  // type of output will be 'string'
</code></pre>

<h3 id="泛型接口">泛型接口</h3>

<p>通过泛型还可以创建<strong>泛型接口</strong>:</p>

<pre><code class="language-JS">interface GenericIdentityFn {
  &lt;T&gt;(arg: T): T
}

function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: GenericIdentityFn = identity
</code></pre>

<p>同样我们也可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型(比如 <code class="highlighter-rouge">Dictionary&lt;string&gt;</code> 而不只是 <code class="highlighter-rouge">Dictionary</code>)。 这样接口里的其它成员也能知道这个参数的类型了:</p>

<pre><code class="language-JS">interface GenericIdentityFn&lt;T&gt; {
  (arg: T): T
}

function identity&lt;T&gt;(arg: T): T {
  return arg
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity
</code></pre>

<h3 id="泛型类">泛型类</h3>

<p>泛型类指的是实例部分的类型，类的静态属性不能使用这个泛型类型:</p>

<pre><code class="language-JS">class GenericNumber&lt;T&gt; {
  zeroValue: T
  add: (x: T, y: T) =&gt; T
}

let myGenericNumber = new GenericNumber&lt;number&gt;()
myGenericNumber.zeroValue = 0
myGenericNumber.add = function(x, y) { return x + y }
</code></pre>

<p>没有什么去限制它只能使用 number 类型。 也可以使用字符串或其它更复杂的类型:</p>

<pre><code class="language-JS">let stringNumeric = new GenericNumber&lt;string&gt;()
stringNumeric.zeroValue = ''
stringNumeric.add = function(x, y) { return x + y }

console.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))
</code></pre>

<h3 id="泛型约束">泛型约束</h3>

<p>回到第一个栗子，由于参数可以是任意类型，所以 length 属性不一定存在，为了约束，我们通过 <strong>extends</strong> 关键字可以这样写:</p>

<pre><code class="language-JS">// 创建一个包含 .length 属性的接口
interface Lengthwise {
  length: number
}

// 它不再是适用于任意类型
function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
  console.log(arg.length)  // Now we know it has a .length property, so no more error
  return arg
}

loggingIdentity(3)  // Error, number doesn't have a .length property
</code></pre>

<p>在泛型里使用类类型，使用原型属性推断并约束构造函数与类实例的关系:</p>

<pre><code class="language-JS">class BeeKeeper {
  hasMask: boolean
}

class ZooKeeper {
  nametag: string
}

class Animal {
  numLegs: number
}

class Bee extends Animal {
  keeper: BeeKeeper
}

class Lion extends Animal {
  keeper: ZooKeeper
}

function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {
  return new c()
}

createInstance(Lion).keeper.nametag  // typechecks!
createInstance(Bee).keeper.hasMask   // typechecks!
</code></pre>

<h2 id="命名空间">命名空间</h2>

<p>“内部模块”现在称做”<strong>命名空间(namespace)</strong>“，”外部模块”则简称为”<strong>模块(module)</strong>“，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突:</p>

<pre><code class="language-JS">// Validation.ts
namespace Validation {
  export interface StringValidator {
    isAcceptable(s: string): boolean
  }
}
</code></pre>

<pre><code class="language-JS">// 三斜线指令，用于声明文件间的依赖
/// &lt;reference path='Validation.ts' /&gt;
// 尽管是不同的文件，它们仍是同一个命名空间
namespace Validation {
  const lettersRegexp = /^[A-Za-z]+$/
  export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
      return lettersRegexp.test(s)
    }
  }
}
</code></pre>

<pre><code class="language-JS">/// &lt;reference path='Validation.ts' /&gt;
/// &lt;reference path='LettersOnlyValidator.ts' /&gt;

let strings = ['Hello', '98052', '101']

// Validators to use
let validators: { [s: string]: Validation.StringValidator } = {}
validators['Letters only'] = new Validation.LettersOnlyValidator()

// Show whether each string passed each validator
for (let s of strings) {
  for (let name in validators) {
    console.log(`'${ s }' - ${ validators[name].isAcceptable(s) ? 'matches' : 'does not match' } ${ name }`)
  }
}
</code></pre>

<p>还可以为命名空间取别名，格式为 <code class="highlighter-rouge">import q = x.y.z</code>:</p>

<pre><code class="language-JS">namespace Shapes {
  export namespace Polygons {
    export class Triangle { }
    export class Square { }
  }
}

import polygons = Shapes.Polygons // 取别名
let sq = new polygons.Square() // Same as 'new Shapes.Polygons.Square()'
</code></pre>

<h2 id="声明文件-dts">声明文件 d.ts</h2>

<p>TypeScript 相比 JavaScript 增加了类型声明，并要求开发者做到先声明后使用。这就导致在调用很多原生接口或者使用第三方模块的时候，因为变量未声明而导致编译器的类型检查失败:</p>

<pre><code class="language-JS">// 比如在浏览器中以 script 标签引入 jQuery 并使用全局变量 $
// index.ts
$('selector') // ts error: can not find name '$'
</code></pre>

<p>故需要为 $ 提供全局的类申明:</p>

<pre><code class="language-JS">// index.d.ts
declare const $: any
</code></pre>

<p>社区为普遍使用的模块提供了类型定义，通过 <code class="highlighter-rouge">npm install @types/[module-name]</code> 即可安装，而不需要自己手动声明。上面栗子的写法是针对变量的，对于其他写法如下，更多示例可以<a href="https://www.tslang.cn/docs/handbook/declaration-files/by-example.html">参考官网</a>:</p>

<pre><code class="language-JS">// ---- 函数 ----
greet('hello, world')

declare function greet(greeting: string): void
</code></pre>

<pre><code class="language-JS">// ---- 带属性的对象 使用 declare namespace 描述用点表示法访问的类型或值 ----
const result = myLib.makeGreeting('hello, world')
const count = myLib.numberOfGreetings

declare namespace myLib {
  function makeGreeting(s: string): string
  const numberOfGreetings: number
}
</code></pre>

<pre><code class="language-JS">// ---- 可重用类型(类型别名) ----
// 可以提供一个 string，一个返回 string 的函数或一个 Greeter 实例
function getGreeting() {
  return 'howdy'
}
class MyGreeter extends Greeter { }

greet('hello')
greet(getGreeting)
greet(new MyGreeter())

// 可以使用类型别名来定义类型的短名
type GreetingLike = string | (() =&gt; string) | MyGreeter
declare function greet(g: GreetingLike): void
</code></pre>

<pre><code class="language-JS">// ---- 类 ----
const myGreeter = new Greeter('hello, world')
myGreeter.greeting = 'howdy'
myGreeter.showGreeting()

class SpecialGreeter extends Greeter {
  constructor() {
    super('Very special greetings')
  }
}

declare class Greeter {
  constructor(greeting: string)

  greeting: string
  showGreeting(): void
}
</code></pre>

<h2 id="参考链接">参考链接</h2>

<ol>
  <li><a href="https://www.tslang.cn/docs/home.html">TypeScript 中文文档</a></li>
  <li><a href="https://jkchao.github.io/typescript-book-chinese/#why">深入理解 TypeScript(译)</a> By Basarat</li>
  <li><a href="https://www.zhihu.com/question/52068257">TypeScript 中的 .d.ts 文件有什么作用，这种文件的内如如何编写？ - 知乎</a></li>
  <li><a href="https://www.ruphi.cn/archives/266/">Typescript学习记录：高级类型</a> By RuphiLau</li>
  <li><a href="https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/">Say Goodbye to ‘../../../..’ in your TypeScript Imports</a></li>
</ol>
 
<div id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
      enable: true,
      clientID: '020f142489f80c92b097',
      clientSecret: '1fa083372b44031cf1b8249251515c4e3d54c69d',
      repo: 'tate-young.github.io',
      owner: 'Tate-Young',
      admin: ['Tate-Young'],
      id: location.pathname,      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
<!-- disqus -->
<!-- <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        this.page.url = 'https://tate-young.github.io/2019/02/26/ts-profile.html';
        this.page.identifier = '/2019/02/26/ts-profile';
        this.page.title = 'TypeScript 简介';
    };

    (function () { // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document,
            s = d.createElement('script');

        s.src = '//tate.disqus.com/embed.js'; // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> -->


            <!-- <p class="post-info">
			本文由 <a href="/">liberxue</a> 创作，采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>本站文章除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间为:2019-02-26 17:54:00</p> -->
        </div>
    </article>

    <!-- <div class="related-post-lists">
	<div class="post-lists">
		<div class="post-lists-body">
					<div class="post-list-item">
				<div class="post-list-item-container">
					<div class="item-label">
						<div class="item-title"><a href="induction.html">归纳的随想</a></div>
						<div class="item-meta clearfix">
														<div class="item-meta-ico bg-ico-image" style="background: url('../usr/themes/pinghsu/images/bg-ico.png') no-repeat;background-size: 40px auto;"></div>
	                        							<div class="item-meta-cat"><a href="../category/thoughts/index.html">Thoughts</a></div>
						</div>
					</div>
				</div>
			</div>
				</div>
	</div>
</div> -->

    <!-- <footer class="footer bg-white">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
	 <a class="social segmentfault" target="blank" href="https://segmentfault.com/u/liberxue" title="访问 LiberXue_Twitter" data-hover="Segmentfault">Segmentfault</a>
    <a class="social github" target="blank" href="https://github.com/liberxue" title="访问 LiberXue_Twitter" data-hover="GitHub">GitHub</a>
    <a class="social twitter" target="blank" href="http://twitter.com/liberxue" title="访问 LiberXue_Twitter" data-hover="Twitter">Twitter</a>
     <a class="social stackoverflow" target="blank" href="https://stackoverflow.com/users/6902190/liberxue" title="访问 LiberXue_stackoverflow" data-hover="StackOverflow">StackOverflow</a>
          <a class="social oschina" target="blank" href="https://my.oschina.net/bolanzw" title="访问 LiberXue_Oschina" data-hover="Oschina">Oschina</a>
     <a class="social rss" target="blank" href="/feed.xml"title="访问 LiberXue_RSS" data-hover="RSS">RSS</a>
	</div>
		</div>
	</div>
	<div class="footer-meta">
        <div class="footer-container">
            <div class="meta-item meta-copyright">
                <div class="meta-copyright-info">
                    <a href="/" class="info-logo">
                         <img src="http://localhost:2333/style/images/logo-liberxue.png"   title="访问 LiberXue_blog" data-hover="LiberXue_blog" alt="LiberXue_blog" /> </a>
                    <div class="info-text">
                        <p>Theme is <a href="http://www.liberxue.com/2017/08/03/Jekyllthemes.html" title="访问 Jekyll liberxue主题"  data-hover="Jekyll liberxue"target="_blank">Jekyll liberxue</a> by <a href="http://www.liberxue.com/about" target="_blank">liberxue</a></p>
                        <p>Powered by <a href="http://localhost:2333/tags/#Jekyll" title="Jekyll" data-hover="Jekyll" target="_blank" rel="nofollow">Jekyll</a></p>
                        <p>&copy; 2017 <a href="/feed.xml"  title="访问 liberxue blog RSS" data-hover="liberxue blog RSS">liberxue blog RSS</a></p>
                        <p>总计文章：篇</p>
                      <p>本blog已开源点击Fork</p><iframe src="http://ghbtns.com/github-btn.html?user=liberxue&repo=liberxue.github.io&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="95" height="20"></iframe>
                    </div>
                </div>
            </div>
            <div class="meta-item meta-posts">
                <h3 class="meta-title">置顶文章</h3>
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
            </div>
            <div class="meta-item meta-comments">
                <h3 class="meta-title">最新文章</h3>
  
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
</div>
		</div>
    </div>
</footer> -->
<script src="//cdn.bootcss.com/jquery/2.2.2/jquery.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap-3-typeahead/4.0.2/bootstrap3-typeahead.js"></script>
<script async src="/search/js/520.js"></script>
<script async src="/search/js/gtag.js"></script>
<script async src="/search/live2d/autoload.js"></script>
<!-- <script src="/search/js/canvas.js"></script> -->

<script>
    $(function () {
        setTimeout(function () {
            $('code').removeClass('hljs');
            $('code').removeClass('language');
        }, 90);
    });
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <!--liberxueconnnet-menu-->
    <div id="directory-content" class="directory-content">
        <div id="directory"></div>
    </div>
    <!--liberxueconnnet-menu-->
    <script>
      const directoryContainer = document.getElementById('directory')
      const postTitle = document.getElementsByClassName('post-title')[0]
      var postDirectoryBuild = function () {
        var postChildren = function children(childNodes, reg) {
          var result = [],
              isReg = typeof reg === 'object',
              isStr = typeof reg === 'string',
              node, i, len;
          for (i = 0, len = childNodes.length; i < len; i++) {
            node = childNodes[i];
            if ((node.nodeType === 1 || node.nodeType === 9) &&
              (!reg ||
                  isReg && reg.test(node.tagName.toLowerCase()) ||
                  isStr && node.tagName.toLowerCase() === reg)) {
                result.push(node);
              }
            }
            return result;
          },
          createPostDirectory = function (article, directory, isDirNum) {
            var contentArr = [],
                titleId = [],
                levelArr, root, level,
                currentList, list, li, link, i, len;
            levelArr = (function (article, contentArr, titleId) {
                  var titleElem = postChildren(article.childNodes, /^h\d$/),
                      levelArr = [],
                      lastNum = 1,
                      lastRevNum = 1,
                      count = 0,
                      guid = 1,
                      id = 'directory' + (Math.random() + '').replace(/\D/, ''),
                      lastRevNum, num, elem;
                  while (titleElem.length) {
                      elem = titleElem.shift();
                      contentArr.push(elem.innerHTML);
                      num = +elem.tagName.match(/\d/)[0];
                      if (num > lastNum) {
                          levelArr.push(1);
                          lastRevNum += 1;
                      } else if (num === lastRevNum ||
                          num > lastRevNum && num <= lastNum) {
                          levelArr.push(0);
                          lastRevNum = lastRevNum;
                      } else if (num < lastRevNum) {
                          levelArr.push(num - lastRevNum);
                          lastRevNum = num;
                      }
                      count += levelArr[levelArr.length - 1];
                      lastNum = num;
                      elem.id = elem.id || (id + guid++);
                      titleId.push(elem.id);
                  }
                  if (count !== 0 && levelArr[0] === 1) levelArr[0] = 0;

                  return levelArr;
              })(article, contentArr, titleId);
              currentList = root = document.createElement('ul');
              dirNum = [0];
              for (i = 0, len = levelArr.length; i < len; i++) {
                  level = levelArr[i];
                  if (level === 1) {
                      list = document.createElement('ul');
                      if (!currentList.lastElementChild) {
                          currentList.appendChild(document.createElement('li'));
                      }
                      currentList.lastElementChild.appendChild(list);
                      currentList = list;
                      dirNum.push(0);
                  } else if (level < 0) {
                      level *= 2;
                      while (level++) {
                          if (level % 2) dirNum.pop();
                          currentList = currentList.parentNode;
                      }
                  }
                  dirNum[dirNum.length - 1]++;
                  li = document.createElement('li');
                  link = document.createElement('a');
                  link.name = '#' + titleId[i];
                  link.href = 'Javascript:;'
                  link.className = "post-aside-anchor"
                  link.title = '访问' + titleId[i];
                  link.innerHTML = !isDirNum ? contentArr[i] :
                      dirNum.join('.') + ' ' + contentArr[i];
                  li.appendChild(link);
                  currentList.appendChild(li);
              }
            directory.appendChild(root);
          };
        createPostDirectory(document.getElementById('post-content'), directoryContainer, true);
      };
      postDirectoryBuild();
    </script>
    <script>
      // gtag('config', GA_TRACKING_ID, {
      //   'page_title' : 'Blog',
      //   'page_path': window.location.pathname,
      //   'post_title': 'watttsdfasdf',
      // });

    </script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        lang = hljs.initHighlightingOnLoad();
    </script>
</body>

</html>
