
<!DOCTYPE>
<html lang="zh-cn" data-scribe-reduced-action-queue="true">
<head>
    <meta content='Vuex 简介 - Tate & Snow' name='title' />
    <meta content='Vuex 简介 - Tate & Snow' name='og:title' />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <title>Vuex 简介 - Tate & Snow</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Vuex 简介 - Tate & Snow</title>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vuex 简介 - Tate & Snow">
<meta name="twitter:keywords" content="Vuex 简介 - Tate & Snow" property='og:description' />
<meta property="og:type" content="article">
<meta property="og:title" content="Vuex 简介 - Tate & Snow">
<meta name="og:keywords" content="Vuex 简介 - Tate & Snow|Vuex 简介Vuex对于状态管理容器，前面讲了很多，类似 Mobx 和 Redux。这次看看 Vue 应用中如何运用 Vuex 来实现状态管理。Vuex 的核心思想是提供一个全局的单例统一进行管理状态，并且定义和隔离状态管理中的各种..."
  property='og:description' />
<link rel="icon" type="image/png" href="http://localhost:2333/style/favicons/favicon.ico" />
<link href="http://localhost:2333/style/favicons/favicon.ico" rel="shortcut icon" type="image/png">
<link rel="canonical" href="http://localhost:2333/">
<link rel="alternate" type="application/rss+xml" title="Liberxue" href="http://localhost:2333/feed.xml">
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="http://localhost:2333/style/favicons/favicon.ico" type="image/x-icon">
<meta name="keywords" content="Vuex 简介Vuex对于状态管理容器，前面讲了很多，类似 Mobx 和 Redux。这次看看 Vue 应用中如何运用 Vuex 来实现状态管理。Vuex 的核心思想是提供一个全局的单例统一进行管理状态，并且定义和隔离状态管理中的各种..." property='og:description'
/>
<meta name="description" content="Tate & Snow's Github blog" />
<link href="https://cdn.bootcss.com/highlight.js/9.10.0/styles/xcode.min.css" rel="stylesheet">
<link href="http://localhost:2333/style/theme.css" rel="stylesheet"> 
<meta content='http://localhost:2333/2019/08/06/vuex-profile.html' property='og:url' />
<meta content="http://localhost:2333/2019/08/06/vuex-profile.html|Vuex 简介Vuex对于状态管理容器，前面讲了很多，类似 Mobx 和 Redux。这次看看 Vue 应用中如何运用 Vuex 来实现状态管理。Vuex 的核心思想是提供一个全局的单例统一进行管理状态，并且定义和隔离状态管理中的各种..." property='og:description'
/>
<meta content="article" property="og:type" /> 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136311746-1"></script>
<!-- <script async src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script>
  window.dataLayer = window.dataLayer || [];
  window.GA_TRACKING_ID = 'UA-136311746-1'
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('set', {
    'country': 'US',
    'currency': 'USD',
    'description': 'fuck',
  });
  gtag('config', GA_TRACKING_ID, {
    'custom_map': {
      'dimension1': 'post_title',
    },
    'post_title': 'test',
  });
</script>
<meta content="" property="fb:app_id" />
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Vuex 简介 | Tate &amp; Snow</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Vuex 简介" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Vuex 简介" />
<meta property="og:description" content="Vuex 简介" />
<link rel="canonical" href="http://localhost:2333/2019/08/06/vuex-profile.html" />
<meta property="og:url" content="http://localhost:2333/2019/08/06/vuex-profile.html" />
<meta property="og:site_name" content="Tate &amp; Snow" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-06T16:08:00+08:00" />
<script type="application/ld+json">
{"description":"Vuex 简介","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:2333/2019/08/06/vuex-profile.html"},"@type":"BlogPosting","url":"http://localhost:2333/2019/08/06/vuex-profile.html","headline":"Vuex 简介","dateModified":"2019-08-06T16:08:00+08:00","datePublished":"2019-08-06T16:08:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<script>
  (function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s);
    js.id = id;
    js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

</head>

<body class="dark-theme" gtools_scp_screen_capture_injected="true">
    <header id="header" class="header bg-white">
        <div class="navbar-container">
            <a href="Javascript:;" onclick="onClickLogo()" title="访问 Tate & Snow" class="navbar-logo menu-logo">
                <img src="http://localhost:2333/style/images/tate.png" alt="Tate & Snow"> </a>
            <!-- <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">Tate & Snow</a>   -->
            <div class="navbar-menu">
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('首页', '/')" title="访问 首页" data-hover="首页">首页</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('前端', '/front')" title="访问 前端" data-hover="前端">前端</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('历史', '/history')" title="访问 历史" data-hover="历史">历史</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('其他', '/other')" title="访问 其他" data-hover="其他">其他</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('标签', '/tags')" title="访问 标签" data-hover="标签">标签</a>
                
                  <a class=" menu-item-about " href="Javascript:;" onclick="onClickMenu('关于', '/README')" title="访问 关于" data-hover="关于">关于</a>
                
            </div>
            <!-- <div class="navbar-menu">
                
                <a href="http://localhost:2333/">首页</a>
                
                <a href="http://localhost:2333/front">前端</a>
                
                <a href="http://localhost:2333/history">历史</a>
                
                <a href="http://localhost:2333/other">其他</a>
                
                <a href="http://localhost:2333/tags">标签</a>
                
                <a href="http://localhost:2333/README">关于</a>
                
            </div> -->
            <div class="navbar-search menu-item-search" onclick="onClickSearch()">
                <span class="icon-search"></span>
                <form id="cb-search-btn" role="search">
                    <span class="search-box">
                        <input type="text" class="input" id="cb-search-content" required="true" placeholder="标题 标签..." maxlength="30" autocomplete="off">
                    </span>
                </form>
            </div>
            <div class="navbar-mobile-menu" onclick="">
                <span class="icon-menu cross">
                    <span class="middle"></span>
                </span>
                <ul>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('首页', 'http://localhost:2333/')">首页</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('前端', 'http://localhost:2333/front')">前端</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('历史', 'http://localhost:2333/history')">历史</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('其他', 'http://localhost:2333/other')">其他</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('标签', 'http://localhost:2333/tags')">标签</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('关于', 'http://localhost:2333/README')">关于</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </header>
    <a href="#header" class="back-to-top" onclick="onClickTop('Vuex 简介')">⤴Top⤴</a>
    <div class="post-header-thumb bg-white}">
        <div class="post-header-thumb-op"></div>
        <div class="post-header-thumb">
            <div class="post-header-thumb-container">
                <h1 class="post-title" itemprop="name headline">
                    Vuex 简介</h1>
                <div class="post-data">
                    <time datetime="2019-08-06 16:08:00" itemprop="datePublished">
                      发布时间：2019-08-06 16:08:00
                      &nbsp;&nbsp;&nbsp;
                      
                        修改时间：2019-08-06 17:19:00
                      
                    </time>
                    <a onclick="onClickCategory('前端')" href="Javascript:;" title="访问 前端" data-hover="博客分类: 前端">博客分类: 前端</a>
                    <!-- <a href="#read"> 阅读次数: comments</a>  -->
                </div>
                <div class="post-tags">
                       
                    <a class="menu-item-tags" href="Javascript:;" onclick="onClickTag('Vue')" title="访问Vue" data-hover="Vue">
                        Vue
                        <span>(5)</span>
                        
                    </a>
                       
                </div>
            </div>
        </div>
    </div>
    <article class="main-content post-page" itemscope itemtype="http://schema.org/Article">
        <div class="post-header">
            <h1 class="post-title" itemprop="name headline">
                Vuex 简介</h1>
            <div class="post-data">
                <time datetime="2019-08-06 16:08:00" itemprop="datePublished">2019-08-06 16:08:00</time>
            </div>
        </div>
        <div id="post-content" class="post-content" itemprop="articleBody">
            <p class="post-tags">
                   
                <a href="Javascript:;" onclick="onClickTag('Vue')" title="访问Vue" data-hover="Vue">
                    Vue
                    <span>(5)</span>
                    </a>
                   
            </p>
            <h1 id="vuex-简介">Vuex 简介</h1>

<h2 id="vuex">Vuex</h2>

<p>对于状态管理容器，前面讲了很多，类似 Mobx 和 Redux。这次看看 Vue 应用中如何运用 <strong>Vuex</strong> 来实现状态管理。Vuex 的核心思想是提供一个全局的单例统一进行管理状态，并且定义和隔离状态管理中的各种状态，强制要求遵循约定来编写代码，而这带来的好处便是代码会更加的结构化和容易维护。</p>

<p><img src="https://vuex.vuejs.org/vuex.png" alt="Vuex" /></p>

<h2 id="仓库-store">仓库 store</h2>

<p>每一个 Vuex 应用的核心就是 <strong>store（仓库）</strong>。store 基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和全局对象的区别在于:</p>

<ol>
  <li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新</li>
  <li>不能够直接改变 store 里的状态，而是应该显示地提交(commit) mutations。方便追踪变更</li>
</ol>

<p>创建一个 store 的方法如下:</p>

<pre><code class="language-JS">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
</code></pre>

<p>现在，你可以通过 <code class="highlighter-rouge">store.state</code> 来获取状态对象，以及通过 <code class="highlighter-rouge">store.commit</code> 方法触发状态变更:</p>

<pre><code class="language-JS">store.commit('increment')

console.log(store.state.count) // -&gt; 1
</code></pre>

<blockquote>
  <p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性(computed)中返回即可</p>
</blockquote>

<h2 id="状态-state">状态 state</h2>

<p>每个应用将仅仅包含一个 store 实例。<strong>单一状态树</strong>让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态:</p>

<pre><code class="language-JS">// 创建一个 Counter 组件
const Counter = {
  template: `&lt;div&gt;8&lt;/div&gt;`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
</code></pre>

<p>然而，这种模式导致组件依赖全局状态单例 store。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。因此 Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中:</p>

<pre><code class="language-JS">const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    &lt;div class="app"&gt;
      &lt;counter&gt;&lt;/counter&gt;
    &lt;/div&gt;
  `
})
</code></pre>

<p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code class="highlighter-rouge">this.$store</code> 访问到。让我们更新下 Counter 的实现:</p>

<pre><code class="language-JS">const Counter = {
  template: `&lt;div&gt;8&lt;/div&gt;`,
  computed: {
    count () {
      return this.$store.state.count // modify this line
    }
  }
}
</code></pre>

<h3 id="mapstate">mapState</h3>

<p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <strong>mapState</strong> 辅助函数帮助我们生成计算属性:</p>

<pre><code class="language-JS">import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state =&gt; state.count,

    // 传字符串参数 'count' 等同于 `state =&gt; state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
</code></pre>

<p>还可以利用对象展开运算符简化写法:</p>

<pre><code class="language-JS">computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
    // 映射 this.count 为 store.state.count
    'count'
  })
}
</code></pre>

<h2 id="getters">Getters</h2>

<p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数:</p>

<pre><code class="language-JS">computed: {
  doneTodosCount () {
    return this.$store.state.todos.filter(todo =&gt; todo.done).length
  }
}
</code></pre>

<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。Vuex 允许我们在 store <strong>中定义getter</strong>（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算:</p>

<pre><code class="language-JS">const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; { // 接受 state 作为其第一个参数
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})
</code></pre>

<p>同时 Getter 会暴露为 <code class="highlighter-rouge">store.getters</code> 对象，你可以以属性的形式访问这些值:</p>

<pre><code class="language-JS">store.getters.doneTodos // -&gt; [{ id: 1, text: '...', done: true }]
</code></pre>

<p>Getter 也可以接受其他 getter 作为第二个参数:</p>

<pre><code class="language-JS">getters: {
  // ...
  doneTodosCount: (state, getters) =&gt; {
    return getters.doneTodos.length
  }
}

store.getters.doneTodosCount // -&gt; 1
</code></pre>

<p>因此我们最后改造为:</p>

<pre><code class="language-JS">computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
}
</code></pre>

<p>另外，你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用:</p>

<pre><code class="language-JS">getters: {
  // ...
  getTodoById: (state) =&gt; (id) =&gt; {
    return state.todos.find(todo =&gt; todo.id === id)
  }
}

store.getters.getTodoById(2) // -&gt; { id: 2, text: '...', done: false }
</code></pre>

<blockquote>
  <p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果</p>
</blockquote>

<h3 id="mapgetters">mapGetters</h3>

<p><strong>mapGetters</strong> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性:</p>

<pre><code class="language-JS">import { mapGetters } from 'vuex'

export default {
  // ...
  computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
  }
}
</code></pre>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式:</p>

<pre><code class="language-JS">mapGetters({
  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`
  doneCount: 'doneTodosCount'
})
</code></pre>

<h2 id="mutations">Mutations</h2>

<p>更改 Vuex 的 store 中的状态的唯一方法是提交 <strong>mutation</strong>。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，你可以向 <code class="highlighter-rouge">store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>:</p>

<pre><code class="language-JS">// ...
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}

store.commit('increment', {
  amount: 10
})

// 也可采用对象风格的提交方式，此时整个对象都作为载荷传给 mutation 函数
store.commit({
  type: 'increment',
  amount: 10
})
</code></pre>

<p>另外需要注意的是 Mutation 必须是同步函数，比如下面这种，使得状态变得无法追踪:</p>

<pre><code class="language-JS">mutations: {
  someMutation (state) {
    api.callAsyncMethod(() =&gt; {
      state.count++
    })
  }
}
</code></pre>

<h3 id="mapmutations">mapMutations</h3>

<p><strong>mapMutations</strong> 辅助函数将组件中的 methods 映射为 <code class="highlighter-rouge">store.commit</code> 调用:</p>

<pre><code class="language-JS">import { mapMutations } from 'vuex'

export default {
  // ...
  methods: {
    ...mapMutations([
      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`

      // `mapMutations` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
    ]),
    ...mapMutations({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
  }
}
</code></pre>

<blockquote>
  <p>mutation 都是同步事务，为了处理异步操作，让我们来看一看 Action</p>
</blockquote>

<h2 id="action">Action</h2>

<p><strong>Action</strong> 类似于 mutation，不同在于:</p>

<ol>
  <li>Action 提交的是 mutation，而不是直接变更状态。</li>
  <li>Action 可以包含任意异步操作。</li>
</ol>

<p>让我们来注册一个简单的 action:</p>

<pre><code class="language-JS">const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
</code></pre>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 <strong>context</strong> 对象(并不是 store 实例本身)，因此你可以调用 <code class="highlighter-rouge">context.commit</code> 提交一个 mutation，或者通过 <code class="highlighter-rouge">context.state</code> 和 <code class="highlighter-rouge">context.getters</code> 来获取 state 和 getters。Action 通过 <code class="highlighter-rouge">store.dispatch</code> 方法触发:</p>

<pre><code class="language-JS">store.dispatch('increment')
</code></pre>

<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作:</p>

<pre><code class="language-JS">actions: {
  incrementAsync ({ commit }) {
    setTimeout(() =&gt; {
      commit('increment')
    }, 1000)
  }
}

// 以载荷形式分发
store.dispatch('incrementAsync', {
  amount: 10
})

// 以对象形式分发
store.dispatch({
  type: 'incrementAsync',
  amount: 10
})
</code></pre>

<p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise:</p>

<pre><code class="language-JS">actions: {
  actionA ({ commit }) {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        commit('someMutation')
        resolve()
      }, 1000)
    })
  }
}

store.dispatch('actionA').then(() =&gt; {
  // ...
})
</code></pre>

<p>利用 async/await 我们再看个组合栗子:</p>

<pre><code class="language-JS">// 假设 getData() 和 getOtherData() 返回的是 Promise

actions: {
  async actionA ({ commit }) {
    commit('gotData', await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch('actionA') // 等待 actionA 完成
    commit('gotOtherData', await getOtherData())
  }
}
</code></pre>

<h3 id="mapactions">mapActions</h3>

<p><strong>mapActions</strong> 辅助函数将组件的 methods 映射为 <code class="highlighter-rouge">store.dispatch</code> 调用:</p>

<pre><code class="language-JS">import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}
</code></pre>

<h2 id="module">Module</h2>

<h3 id="modules-分割">modules 分割</h3>

<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 <code class="highlighter-rouge">state、mutation、action、getter</code>，甚至是嵌套子模块——从上至下进行同样方式的分割:</p>

<pre><code class="language-JS">const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态
</code></pre>

<p>对于模块内部的 action，局部状态通过 <code class="highlighter-rouge">context.state</code> 暴露出来，根节点状态则为 <code class="highlighter-rouge">context.rootState</code>:</p>

<pre><code class="language-JS">const moduleA = {
  // ...
  actions: {
    incrementIfOddOnRootSum ({ state, commit, rootState }) {
      if ((state.count + rootState.count) % 2 === 1) {
        commit('increment')
      }
    }
  }
}
</code></pre>

<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来:</p>

<pre><code class="language-JS">const moduleA = {
  // ...
  getters: {
    sumWithRootCount (state, getters, rootState) {
      return state.count + rootState.count
    }
  }
}
</code></pre>

<h3 id="命名空间-namespace">命名空间 namespace</h3>

<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code class="highlighter-rouge">namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如:</p>

<pre><code class="language-JS">const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -&gt; getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -&gt; dispatch('account/login')
      },
      mutations: {
        login () { ... } // -&gt; commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: { ... },
          getters: {
            profile () { ... } // -&gt; getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: { ... },
          getters: {
            popular () { ... } // -&gt; getters['account/posts/popular']
          }
        }
      }
    }
  }
})
</code></pre>

<h3 id="rootstate--rootgetter">rootState / rootGetter</h3>

<p>如果你希望使用全局 state 和 getter，<strong>rootState</strong> 和 <strong>rootGetter</strong> 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。
若需要在全局命名空间内分发 action 或提交 mutation，将 <code class="highlighter-rouge">{ root: true }</code> 作为第三参数传给 dispatch 或 commit 即可:</p>

<pre><code class="language-JS">modules: {
  foo: {
    namespaced: true,

    getters: {
      // 在这个模块的 getter 中，`getters` 被局部化了
      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
      someGetter (state, getters, rootState, rootGetters) {
        getters.someOtherGetter // -&gt; 'foo/someOtherGetter'
        rootGetters.someOtherGetter // -&gt; 'someOtherGetter'
      },
      someOtherGetter: state =&gt; { ... }
    },

    actions: {
      // 在这个模块中， dispatch 和 commit 也被局部化了
      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
      someAction ({ dispatch, commit, getters, rootGetters }) {
        getters.someGetter // -&gt; 'foo/someGetter'
        rootGetters.someGetter // -&gt; 'someGetter'

        dispatch('someOtherAction') // -&gt; 'foo/someOtherAction'
        dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction'

        commit('someMutation') // -&gt; 'foo/someMutation'
        commit('someMutation', null, { root: true }) // -&gt; 'someMutation'
      },
      someOtherAction (ctx, payload) { ... }
    }
  }
}
</code></pre>

<p>若需要在带命名空间的模块注册全局 action，你可添加 <code class="highlighter-rouge">root: true</code>，并将这个 action 的定义放在函数 <code class="highlighter-rouge">handler</code> 中。例如:</p>

<pre><code class="language-JS">{
  actions: {
    someOtherAction ({dispatch}) {
      dispatch('someAction')
    }
  },
  modules: {
    foo: {
      namespaced: true,

      actions: {
        someAction: {
          root: true,
          handler (namespacedContext, payload) { ... } // -&gt; 'someAction'
        }
      }
    }
  }
}
</code></pre>

<h3 id="createnamespacedhelpers">createNamespacedHelpers</h3>

<p>当使用 <code class="highlighter-rouge">mapState、mapGetters、mapActions、mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐:</p>

<pre><code class="language-JS">computed: {
  ...mapState({
    a: state =&gt; state.some.nested.module.a,
    b: state =&gt; state.some.nested.module.b
  })
},
methods: {
  ...mapActions([
    'some/nested/module/foo', // -&gt; this['some/nested/module/foo']()
    'some/nested/module/bar' // -&gt; this['some/nested/module/bar']()
  ])
}
</code></pre>

<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为:</p>

<pre><code class="language-JS">computed: {
  ...mapState('some/nested/module', {
    a: state =&gt; state.a,
    b: state =&gt; state.b
  })
},
methods: {
  ...mapActions('some/nested/module', [
    'foo', // -&gt; this.foo()
    'bar' // -&gt; this.bar()
  ])
}
</code></pre>

<p>而且，你可以通过使用 <strong>createNamespacedHelpers</strong> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数:</p>

<pre><code class="language-JS">import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state =&gt; state.a,
      b: state =&gt; state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
</code></pre>

<h3 id="动态注册-registermodule">动态注册 registerModule</h3>

<p>在 store 创建之后，你可以使用 <code class="highlighter-rouge">store.registerModule</code> 方法注册模块:</p>

<pre><code class="language-JS">// 注册模块 `myModule`
store.registerModule('myModule', {
  // ...
})
// 注册嵌套模块 `nested/myModule`
store.registerModule(['nested', 'myModule'], {
  // ...
})
// 之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态
</code></pre>

<p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<code class="highlighter-rouge">vuex-router-sync</code> 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>

<p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 <strong>preserveState</strong> 选项将其归档:</p>

<pre><code class="language-JS">store.registerModule('a', module, { preserveState: true })
</code></pre>

<p>当你设置 <code class="highlighter-rouge">preserveState: true</code> 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</p>

<blockquote>
  <p>也可以使用 <code class="highlighter-rouge">store.unregisterModule(moduleName)</code> 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）</p>
</blockquote>

<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例:</p>

<pre><code class="language-TEXT">├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
</code></pre>

<blockquote>
  <p>以上示例可以直接参考官方 <a href="https://github.com/vuejs/vuex/tree/dev/examples">github examples</a> 👈</p>
</blockquote>

<h2 id="插件-plugins">插件 plugins</h2>

<p>Vuex 的 store 接受 <strong>plugins</strong> 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数:</p>

<pre><code class="language-JS">const myPlugin = store =&gt; {
  // 当 store 初始化后调用
  store.subscribe((mutation, state) =&gt; {
    // 每次 mutation 之后调用
    // mutation 的格式为 { type, payload }
  })
}
</code></pre>

<p>比如内置的打印日志插件 <code class="highlighter-rouge">createLogger</code>:</p>

<pre><code class="language-JS">// 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到
// 严格模式会深度监测状态树来检测不合规的状态变更，请确保在发布环境下关闭严格模式，以避免性能损失
import createLogger from 'vuex/dist/logger'

const debug = process.env.NODE_ENV !== 'production'

export default new Vuex.Store({
  modules: {
    cart
  },
  strict: debug,
  plugins: debug ? [createLogger()] : []
})
</code></pre>

<p>createLogger 还支持一些自定义属性:</p>

<pre><code class="language-JS">const logger = createLogger({
  collapsed: false, // 自动展开记录的 mutation
  filter (mutation, stateBefore, stateAfter) {
    // 若 mutation 需要被记录，就让它返回 true 即可
    // 顺便，`mutation` 是个 { type, payload } 对象
    return mutation.type !== "aBlacklistedMutation"
  },
  transformer (state) {
    // 在开始记录之前转换状态
    // 例如，只返回指定的子树
    return state.subTree
  },
  mutationTransformer (mutation) {
    // mutation 按照 { type, payload } 格式记录
    // 我们可以按任意方式格式化
    return mutation.type
  },
  logger: console, // 自定义 console 实现，默认为 `console`
})
</code></pre>

<h2 id="热重载">热重载</h2>

<p>对于 mutation 和模块，你需要使用 <code class="highlighter-rouge">store.hotUpdate()</code> 方法:</p>

<pre><code class="language-JS">// store.js
import Vue from 'vue'
import Vuex from 'vuex'
import mutations from './mutations'
import moduleA from './modules/a'

Vue.use(Vuex)

const state = { ... }

const store = new Vuex.Store({
  state,
  mutations,
  modules: {
    a: moduleA
  }
})

if (module.hot) {
  // 使 action 和 mutation 成为可热重载模块
  module.hot.accept(['./mutations', './modules/a'], () =&gt; {
    // 获取更新后的模块
    // 因为 babel 6 的模块编译格式问题，这里需要加上 `.default`
    const newMutations = require('./mutations').default
    const newModuleA = require('./modules/a').default
    // 加载新模块
    store.hotUpdate({
      mutations: newMutations,
      modules: {
        a: newModuleA
      }
    })
  })
}
</code></pre>

<h2 id="参考链接">参考链接</h2>

<ol>
  <li><a href="https://vuex.vuejs.org/zh/guide/">Vuex 官方文档</a></li>
</ol>
 
<div id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
      enable: true,
      clientID: '020f142489f80c92b097',
      clientSecret: '1fa083372b44031cf1b8249251515c4e3d54c69d',
      repo: 'tate-young.github.io',
      owner: 'Tate-Young',
      admin: ['Tate-Young'],
      id: location.pathname,      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
<!-- disqus -->
<!-- <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        this.page.url = 'https://tate-young.github.io/2019/08/06/vuex-profile.html';
        this.page.identifier = '/2019/08/06/vuex-profile';
        this.page.title = 'Vuex 简介';
    };

    (function () { // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document,
            s = d.createElement('script');

        s.src = '//tate.disqus.com/embed.js'; // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> -->


            <!-- <p class="post-info">
			本文由 <a href="/">liberxue</a> 创作，采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>本站文章除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间为:2019-08-06 16:08:00</p> -->
        </div>
    </article>

    <!-- <div class="related-post-lists">
	<div class="post-lists">
		<div class="post-lists-body">
					<div class="post-list-item">
				<div class="post-list-item-container">
					<div class="item-label">
						<div class="item-title"><a href="induction.html">归纳的随想</a></div>
						<div class="item-meta clearfix">
														<div class="item-meta-ico bg-ico-image" style="background: url('../usr/themes/pinghsu/images/bg-ico.png') no-repeat;background-size: 40px auto;"></div>
	                        							<div class="item-meta-cat"><a href="../category/thoughts/index.html">Thoughts</a></div>
						</div>
					</div>
				</div>
			</div>
				</div>
	</div>
</div> -->

    <!-- <footer class="footer bg-white">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
	 <a class="social segmentfault" target="blank" href="https://segmentfault.com/u/liberxue" title="访问 LiberXue_Twitter" data-hover="Segmentfault">Segmentfault</a>
    <a class="social github" target="blank" href="https://github.com/liberxue" title="访问 LiberXue_Twitter" data-hover="GitHub">GitHub</a>
    <a class="social twitter" target="blank" href="http://twitter.com/liberxue" title="访问 LiberXue_Twitter" data-hover="Twitter">Twitter</a>
     <a class="social stackoverflow" target="blank" href="https://stackoverflow.com/users/6902190/liberxue" title="访问 LiberXue_stackoverflow" data-hover="StackOverflow">StackOverflow</a>
          <a class="social oschina" target="blank" href="https://my.oschina.net/bolanzw" title="访问 LiberXue_Oschina" data-hover="Oschina">Oschina</a>
     <a class="social rss" target="blank" href="/feed.xml"title="访问 LiberXue_RSS" data-hover="RSS">RSS</a>
	</div>
		</div>
	</div>
	<div class="footer-meta">
        <div class="footer-container">
            <div class="meta-item meta-copyright">
                <div class="meta-copyright-info">
                    <a href="/" class="info-logo">
                         <img src="http://localhost:2333/style/images/logo-liberxue.png"   title="访问 LiberXue_blog" data-hover="LiberXue_blog" alt="LiberXue_blog" /> </a>
                    <div class="info-text">
                        <p>Theme is <a href="http://www.liberxue.com/2017/08/03/Jekyllthemes.html" title="访问 Jekyll liberxue主题"  data-hover="Jekyll liberxue"target="_blank">Jekyll liberxue</a> by <a href="http://www.liberxue.com/about" target="_blank">liberxue</a></p>
                        <p>Powered by <a href="http://localhost:2333/tags/#Jekyll" title="Jekyll" data-hover="Jekyll" target="_blank" rel="nofollow">Jekyll</a></p>
                        <p>&copy; 2017 <a href="/feed.xml"  title="访问 liberxue blog RSS" data-hover="liberxue blog RSS">liberxue blog RSS</a></p>
                        <p>总计文章：篇</p>
                      <p>本blog已开源点击Fork</p><iframe src="http://ghbtns.com/github-btn.html?user=liberxue&repo=liberxue.github.io&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="95" height="20"></iframe>
                    </div>
                </div>
            </div>
            <div class="meta-item meta-posts">
                <h3 class="meta-title">置顶文章</h3>
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
            </div>
            <div class="meta-item meta-comments">
                <h3 class="meta-title">最新文章</h3>
  
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
</div>
		</div>
    </div>
</footer> -->
<script src="//cdn.bootcss.com/jquery/2.2.2/jquery.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap-3-typeahead/4.0.2/bootstrap3-typeahead.js"></script>
<script async src="/search/js/520.js"></script>
<script async src="/search/js/gtag.js"></script>
<script async src="/search/live2d/autoload.js"></script>
<!-- <script src="/search/js/canvas.js"></script> -->

<script>
    $(function () {
        setTimeout(function () {
            $('code').removeClass('hljs');
            $('code').removeClass('language');
        }, 90);
    });
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <!--liberxueconnnet-menu-->
    <div id="directory-content" class="directory-content">
        <div id="directory"></div>
    </div>
    <!--liberxueconnnet-menu-->
    <script>
      const directoryContainer = document.getElementById('directory')
      const postTitle = document.getElementsByClassName('post-title')[0]
      var postDirectoryBuild = function () {
        var postChildren = function children(childNodes, reg) {
          var result = [],
              isReg = typeof reg === 'object',
              isStr = typeof reg === 'string',
              node, i, len;
          for (i = 0, len = childNodes.length; i < len; i++) {
            node = childNodes[i];
            if ((node.nodeType === 1 || node.nodeType === 9) &&
              (!reg ||
                  isReg && reg.test(node.tagName.toLowerCase()) ||
                  isStr && node.tagName.toLowerCase() === reg)) {
                result.push(node);
              }
            }
            return result;
          },
          createPostDirectory = function (article, directory, isDirNum) {
            var contentArr = [],
                titleId = [],
                levelArr, root, level,
                currentList, list, li, link, i, len;
            levelArr = (function (article, contentArr, titleId) {
                  var titleElem = postChildren(article.childNodes, /^h\d$/),
                      levelArr = [],
                      lastNum = 1,
                      lastRevNum = 1,
                      count = 0,
                      guid = 1,
                      id = 'directory' + (Math.random() + '').replace(/\D/, ''),
                      lastRevNum, num, elem;
                  while (titleElem.length) {
                      elem = titleElem.shift();
                      contentArr.push(elem.innerHTML);
                      num = +elem.tagName.match(/\d/)[0];
                      if (num > lastNum) {
                          levelArr.push(1);
                          lastRevNum += 1;
                      } else if (num === lastRevNum ||
                          num > lastRevNum && num <= lastNum) {
                          levelArr.push(0);
                          lastRevNum = lastRevNum;
                      } else if (num < lastRevNum) {
                          levelArr.push(num - lastRevNum);
                          lastRevNum = num;
                      }
                      count += levelArr[levelArr.length - 1];
                      lastNum = num;
                      elem.id = elem.id || (id + guid++);
                      titleId.push(elem.id);
                  }
                  if (count !== 0 && levelArr[0] === 1) levelArr[0] = 0;

                  return levelArr;
              })(article, contentArr, titleId);
              currentList = root = document.createElement('ul');
              dirNum = [0];
              for (i = 0, len = levelArr.length; i < len; i++) {
                  level = levelArr[i];
                  if (level === 1) {
                      list = document.createElement('ul');
                      if (!currentList.lastElementChild) {
                          currentList.appendChild(document.createElement('li'));
                      }
                      currentList.lastElementChild.appendChild(list);
                      currentList = list;
                      dirNum.push(0);
                  } else if (level < 0) {
                      level *= 2;
                      while (level++) {
                          if (level % 2) dirNum.pop();
                          currentList = currentList.parentNode;
                      }
                  }
                  dirNum[dirNum.length - 1]++;
                  li = document.createElement('li');
                  link = document.createElement('a');
                  link.name = '#' + titleId[i];
                  link.href = 'Javascript:;'
                  link.className = "post-aside-anchor"
                  link.title = '访问' + titleId[i];
                  link.innerHTML = !isDirNum ? contentArr[i] :
                      dirNum.join('.') + ' ' + contentArr[i];
                  li.appendChild(link);
                  currentList.appendChild(li);
              }
            directory.appendChild(root);
          };
        createPostDirectory(document.getElementById('post-content'), directoryContainer, true);
      };
      postDirectoryBuild();
    </script>
    <script>
      // gtag('config', GA_TRACKING_ID, {
      //   'page_title' : 'Blog',
      //   'page_path': window.location.pathname,
      //   'post_title': 'watttsdfasdf',
      // });

    </script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        lang = hljs.initHighlightingOnLoad();
    </script>
</body>

</html>
