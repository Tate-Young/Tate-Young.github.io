
<!DOCTYPE>
<html lang="zh-cn" data-scribe-reduced-action-queue="true">
<head>
    <meta content='React Virtual DOM - Tate & Snow' name='title' />
    <meta content='React Virtual DOM - Tate & Snow' name='og:title' />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <title>React Virtual DOM - Tate & Snow</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>React Virtual DOM - Tate & Snow</title>
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Virtual DOM - Tate & Snow">
<meta name="twitter:keywords" content="React Virtual DOM - Tate & Snow" property='og:description' />
<meta property="og:type" content="article">
<meta property="og:title" content="React Virtual DOM - Tate & Snow">
<meta name="og:keywords" content="React Virtual DOM - Tate & Snow|React Virtual DOMReal DOM为什么我们需要虚拟 DOM，因为更新真实 DOM 耗时耗力，我们可以先看下页面是怎么渲染构建的。根据 Webkit 渲染引擎工作流可总结以下五个步骤，具体可以参考我的这篇博客:  HT..."
  property='og:description' />
<link rel="icon" type="image/png" href="http://localhost:2333/style/favicons/favicon.ico" />
<link href="http://localhost:2333/style/favicons/favicon.ico" rel="shortcut icon" type="image/png">
<link rel="canonical" href="http://localhost:2333/">
<link rel="alternate" type="application/rss+xml" title="Liberxue" href="http://localhost:2333/feed.xml">
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="http://localhost:2333/style/favicons/favicon.ico" type="image/x-icon">
<meta name="keywords" content="React Virtual DOMReal DOM为什么我们需要虚拟 DOM，因为更新真实 DOM 耗时耗力，我们可以先看下页面是怎么渲染构建的。根据 Webkit 渲染引擎工作流可总结以下五个步骤，具体可以参考我的这篇博客:  HT..." property='og:description'
/>
<meta name="description" content="Tate & Snow's Github blog" />
<link href="https://cdn.bootcss.com/highlight.js/9.10.0/styles/xcode.min.css" rel="stylesheet">
<link href="http://localhost:2333/style/theme.css" rel="stylesheet"> 
<meta content='http://localhost:2333/2019/10/24/react-virtual-dom.html' property='og:url' />
<meta content="http://localhost:2333/2019/10/24/react-virtual-dom.html|React Virtual DOMReal DOM为什么我们需要虚拟 DOM，因为更新真实 DOM 耗时耗力，我们可以先看下页面是怎么渲染构建的。根据 Webkit 渲染引擎工作流可总结以下五个步骤，具体可以参考我的这篇博客:  HT..." property='og:description'
/>
<meta content="article" property="og:type" /> 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136311746-1"></script>
<!-- <script async src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script> -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script>
  window.dataLayer = window.dataLayer || [];
  window.GA_TRACKING_ID = 'UA-136311746-1'
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('set', {
    'country': 'US',
    'currency': 'USD',
    'description': 'fuck',
  });
  gtag('config', GA_TRACKING_ID, {
    'custom_map': {
      'dimension1': 'post_title',
    },
    'post_title': 'test',
  });
</script>
<meta content="" property="fb:app_id" />
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>React Virtual DOM | Tate &amp; Snow</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="React Virtual DOM" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="React Virtual DOM" />
<meta property="og:description" content="React Virtual DOM" />
<link rel="canonical" href="http://localhost:2333/2019/10/24/react-virtual-dom.html" />
<meta property="og:url" content="http://localhost:2333/2019/10/24/react-virtual-dom.html" />
<meta property="og:site_name" content="Tate &amp; Snow" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-24T15:55:00+08:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:2333/2019/10/24/react-virtual-dom.html"},"url":"http://localhost:2333/2019/10/24/react-virtual-dom.html","headline":"React Virtual DOM","dateModified":"2019-10-24T15:55:00+08:00","datePublished":"2019-10-24T15:55:00+08:00","description":"React Virtual DOM","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<script>
  (function (d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s);
    js.id = id;
    js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

</head>

<body class="dark-theme" gtools_scp_screen_capture_injected="true">
    <header id="header" class="header bg-white">
        <div class="navbar-container">
            <a href="Javascript:;" onclick="onClickLogo()" title="访问 Tate & Snow" class="navbar-logo menu-logo">
                <img src="http://localhost:2333/style/images/tate.png" alt="Tate & Snow"> </a>
            <!-- <a href="/?tate" title="访问 Tate & Snow" class="navbar-logo">Tate & Snow</a>   -->
            <div class="navbar-menu">
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('首页', '/')" title="访问 首页" data-hover="首页">首页</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('前端', '/front')" title="访问 前端" data-hover="前端">前端</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('历史', '/history')" title="访问 历史" data-hover="历史">历史</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('其他', '/other')" title="访问 其他" data-hover="其他">其他</a>
                
                  <a class=" menu-item-categories " href="Javascript:;" onclick="onClickMenu('标签', '/tags')" title="访问 标签" data-hover="标签">标签</a>
                
                  <a class=" menu-item-about " href="Javascript:;" onclick="onClickMenu('关于', '/README')" title="访问 关于" data-hover="关于">关于</a>
                
            </div>
            <!-- <div class="navbar-menu">
                
                <a href="http://localhost:2333/">首页</a>
                
                <a href="http://localhost:2333/front">前端</a>
                
                <a href="http://localhost:2333/history">历史</a>
                
                <a href="http://localhost:2333/other">其他</a>
                
                <a href="http://localhost:2333/tags">标签</a>
                
                <a href="http://localhost:2333/README">关于</a>
                
            </div> -->
            <div class="navbar-search menu-item-search" onclick="onClickSearch()">
                <span class="icon-search"></span>
                <form id="cb-search-btn" role="search">
                    <span class="search-box">
                        <input type="text" class="input" id="cb-search-content" required="true" placeholder="标题 标签..." maxlength="30" autocomplete="off">
                    </span>
                </form>
            </div>
            <div class="navbar-mobile-menu" onclick="">
                <span class="icon-menu cross">
                    <span class="middle"></span>
                </span>
                <ul>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('首页', 'http://localhost:2333/')">首页</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('前端', 'http://localhost:2333/front')">前端</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('历史', 'http://localhost:2333/history')">历史</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('其他', 'http://localhost:2333/other')">其他</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('标签', 'http://localhost:2333/tags')">标签</a>
                    </li>
                    
                    <li>
                        <a class="menu-item-categories" href="Javascript:;" onclick="onClickMenu('关于', 'http://localhost:2333/README')">关于</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </header>
    <a href="#header" class="back-to-top" onclick="onClickTop('React Virtual DOM')">⤴Top⤴</a>
    <div class="post-header-thumb bg-white}">
        <div class="post-header-thumb-op"></div>
        <div class="post-header-thumb">
            <div class="post-header-thumb-container">
                <h1 class="post-title" itemprop="name headline">
                    React Virtual DOM</h1>
                <div class="post-data">
                    <time datetime="2019-10-24 15:55:00" itemprop="datePublished">
                      发布时间：2019-10-24 15:55:00
                      &nbsp;&nbsp;&nbsp;
                      
                        修改时间：2019-12-09 14:30:00
                      
                    </time>
                    <a onclick="onClickCategory('前端')" href="Javascript:;" title="访问 前端" data-hover="博客分类: 前端">博客分类: 前端</a>
                    <!-- <a href="#read"> 阅读次数: comments</a>  -->
                </div>
                <div class="post-tags">
                       
                    <a class="menu-item-tags" href="Javascript:;" onclick="onClickTag('React')" title="访问React" data-hover="React">
                        React
                        <span>(10)</span>
                        
                    </a>
                       
                </div>
            </div>
        </div>
    </div>
    <article class="main-content post-page" itemscope itemtype="http://schema.org/Article">
        <div class="post-header">
            <h1 class="post-title" itemprop="name headline">
                React Virtual DOM</h1>
            <div class="post-data">
                <time datetime="2019-10-24 15:55:00" itemprop="datePublished">2019-10-24 15:55:00</time>
            </div>
        </div>
        <div id="post-content" class="post-content" itemprop="articleBody">
            <p class="post-tags">
                   
                <a href="Javascript:;" onclick="onClickTag('React')" title="访问React" data-hover="React">
                    React
                    <span>(10)</span>
                    </a>
                   
            </p>
            <h1 id="react-virtual-dom">React Virtual DOM</h1>

<h2 id="real-dom">Real DOM</h2>

<p>为什么我们需要虚拟 DOM，因为更新真实 DOM 耗时耗力，我们可以先看下页面是怎么渲染构建的。根据 Webkit 渲染引擎工作流可总结以下五个步骤，具体可以<a href="http://localhost:2333/2018/02/10/html-how-browsers-work.html">参考我的这篇博客</a>:</p>

<ul>
  <li>HTML Parser 将 HTML 解析成 DOM;</li>
  <li>CSS Parser 将 CSS 解析成 CSSOM;</li>
  <li>结合 DOM 和 CSSOM，生成一棵渲染树 Render Tree;</li>
  <li>布局(layout)，计算每个节点的几何信息;</li>
  <li>绘制(painting)，将渲染器的内容显示在屏幕上。</li>
</ul>

<p><img src="https://hackernoon.com/hn-images/1*4s99HTDCA0UUyOc39k5dag.png" alt="webkit 渲染引擎" /></p>

<p>而当我们做如下操作，修改 DOM 的值时，它又会按照上述步骤来一遍。修改 n 遍就走 n 遍，性能自然就下来了:</p>

<pre><code class="language-HTML">document.getElementById('elementId').innerHTML = "Tate &amp; Snow"
</code></pre>

<h2 id="virtual-dom">Virtual DOM</h2>

<p><strong>Virtual DOM</strong> 其实是通过 JavaScript 对象的形式来描述真实 DOM，它之所以更快是由于以下几点:</p>

<ul>
  <li>使用高效的 diff 算法来寻找变更</li>
  <li>批量更新操作</li>
  <li>高效地更新子节点</li>
  <li>使用 observable 而不是脏检测</li>
</ul>

<p>我们知道，在 state 或 props 更新的时候，就会触发组件的渲染，而在调用 Render 方法时，就会重新生成一个新的虚拟 DOM，再加上 React 启动时候生成的虚拟 DOM，我们就可以通过 diff 算法来比较两棵树的差异，从而以最小操作数来更新真实 DOM。那么它如何来查找这些差异的呢，主要有以下几个步骤:</p>

<ol>
  <li>父节点更新则子节点全部更新 - 当然我们可以手动通过 hooks 等阻止不必要的渲染</li>
  <li>广度优先遍历 - 当遍历出来父节点被修改时，子节点就不用做多余的遍历了</li>
  <li><a href="https://www.reactjscn.com/docs/reconciliation.html">协调(Reconciliation)</a> - 与真实 DOM 保持同步</li>
</ol>

<p><img src="https://i0.wp.com/programmingwithmosh.com/wp-content/uploads/2018/11/lnrn_0201.png?ssl=1" alt="diff" /></p>

<p>有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为 n，最先进的算法 的时间复杂度为 O(n^3) 。若我们在 React 中使用，展示 1000 个元素则需要进行 10 亿次的比较。这操作太过昂贵，相反，React 基于两点假设，实现了一个启发的 O(n) 算法。那么问题来了，为啥之前的先进算法时间复杂度都为 O(n^3)，而之后只有 O(n) 了呢，要回答这个问题可以依据<a href="https://www.zhihu.com/question/66851503/answer/246766239">知乎这篇回答</a>:</p>

<pre><code class="language-TEXT">Prev                  Last
          A                     A  
         / \                   / \
        /   \                 /   \
       B     D     ====&gt;     D     B
      /                             \
     C                               C
</code></pre>

<p>传统 Diff 算法的话，先要两两比对节点是否相同，时间复杂度为 O(n^2)，即:</p>

<pre><code class="language-TEXT">PA -&gt; LA
PA -&gt; LB
PA -&gt; LC
PA -&gt; LD
PB -&gt; LA
...
</code></pre>

<p>找到差异后还要计算最小转换方式，比如新增或删除，此时间复杂度为 O(n)，因此最终结果为 O(n^3)。React 的处理方式可以简化为以下，只用遍历一遍，因此时间复杂度为 O(n):</p>

<pre><code class="language-TEXT"># 按叶子节点位置比较
PA -&gt; LA   # 相同
PB -&gt; LD   # 不同，删除 PB，添加 LD
PD -&gt; LB   # 不同，更新
PC -&gt; Null # Last 树没有该节点，所以删除 PC 即可
Null -&gt; LC # Prev 树没有该节点，所以添加 C 到该位置
</code></pre>

<p>React 在更新节点上还遵循了以下两条规则，使得效率进一步提高:</p>

<ul>
  <li>两个不同类型的元素将产生不同的树 - 每当根元素有不同类型，React 将卸载旧树并重新构建新树。当比较两个相同类型的 React DOM 元素时，React 则会观察二者的属性，保持相同的底层 DOM 节点，并仅更新变化的属性</li>
  <li>通过渲染器附带 key 属性 - 使用 key 来匹配原本树的子节点和新树的子节点，Keys 应该是稳定的，可预测的，且唯一的</li>
</ul>

<p>第一点我们来举个栗子:</p>

<pre><code class="language-JS">// 之前
&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

// 之后 - 将会销毁旧的 Counter 并重装新的 Counter
&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;
</code></pre>

<pre><code class="language-JS">// 之前
&lt;div className="before" title="stuff" /&gt;

// 之后 - 仅更改底层 DOM 元素的 className
&lt;div className="after" title="stuff" /&gt;
</code></pre>

<p>第二点我们来举个栗子，对比下不用 key 属性的后果:</p>

<pre><code class="language-JS">// 不使用 key
// 之前
&lt;ul&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

// 之后 - 会调整每个子节点，而不会保留未更改的子节点
&lt;ul&gt;
  &lt;li&gt;Connecticut&lt;/li&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<pre><code class="language-JS">// 使用 key
// 之前
&lt;ul&gt;
  &lt;li key="2015"&gt;Duke&lt;/li&gt;
  &lt;li key="2016"&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

// 之后 - 只用新建 key='2014' 的子节点，其他子节点移动即可
&lt;ul&gt;
  &lt;li key="2014"&gt;Connecticut&lt;/li&gt;
  &lt;li key="2015"&gt;Duke&lt;/li&gt;
  &lt;li key="2016"&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<blockquote>
  <p>万不得已，你可以传递他们在数组中的索引作为 key。若元素没有重排，该方法效果不错，但重排会使得其变慢</p>
</blockquote>

<h2 id="react-fiber">React Fiber</h2>

<p>其实上述的协调比较广义，具体应该分为以下两个过程:</p>

<ul>
  <li><strong>协调阶段</strong>(reconciliation) - ：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过 Diff 算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列</li>
  <li><strong>渲染阶段</strong>(commit) - 这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到 DOM 上。commit 完成后，将执行 <code class="highlighter-rouge">componentDidMount</code> 函数</li>
</ul>

<p><a href="https://github.com/acdlite/react-fiber-architecture">React Fiber</a> 是 React v16 发布的协调的新核心算法，即 <code class="highlighter-rouge">Fiber reconciler</code>，用以代替之前的 <code class="highlighter-rouge">Stack reconciler</code>。可以带来更好的性能优化，它是基于 <code class="highlighter-rouge">Scheduling</code>(决定工作什么时候执行)来实现的，总结来讲:</p>

<ul>
  <li>pause work and come back to it later - 暂停工作，稍后回来</li>
  <li>assign priority to different types of work. - 为不同类型工作设置优先级</li>
  <li>reuse previously completed work. - 复用已经完成的工作</li>
  <li>abort work if it’s no longer needed. - 中止不需要的工作</li>
</ul>

<blockquote>
  <p>The <strong>reconciler</strong> is the part of React which contains the algorithm used to diff one tree with another to determine which parts need to be changed</p>
</blockquote>

<p>协调算法（Stack Reconciler）会一次同步处理整个组件树，来比较新旧两颗树，得到需要更新的部分。这个过程基于递归调用，一旦开始则很难去打断，而且涉及大量的计算就会堵塞整个主线程。因此我们可以根据优先级调整工作，使得大量的计算可以被拆解，异步化，浏览器主线程得以释放，保证了渲染的帧率，从而提高响应性。所以更优解是每次只做一个单元任务，然后回到主线程看下有没有什么更高优先级的任务需要处理，如果有则先处理，没有则继续执行:</p>

<p><img src="https://i.loli.net/2019/11/12/sO8M9qKJikV1Pm3.png" alt="react-fiber.png" /></p>

<p>由于递归调用生成的调用栈我们本身无法控制，而 Fiber 实现了 <strong>virtual stack frame</strong>，可以去按需去手动控制。</p>

<blockquote>
  <p>The advantage of reimplementing the stack is that you can keep stack frames in memory and execute them however (and whenever) you want. This is crucial for accomplishing the goals we have for scheduling.</p>
</blockquote>

<p>React 主要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"><strong>requestIdelCallback</strong></a> API 来实现这种特性，对于不支持的会自动加上 pollyfill。通常客户端线程执行任务时会以帧的形式划分，大部分设备控制在 30-60 帧是不会影响用户体验；在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback 可以在这个<strong>空闲期（Idle Period）</strong>调用<strong>空闲期回调（Idle Callback）</strong>从而执行一些任务:</p>

<p><img src="https://i.loli.net/2019/11/12/hkbz9ILCm4qlnaJ.png" alt="react-requestIdelCallback.png" /></p>

<p>通过将协调过程，分解成小的工作单元的方式，可以让页面对于浏览器事件的响应更加及时。但是另外一个问题还是没有解决，就是如果当前在处理的 react 渲染耗时较长，仍然会阻塞后面的渲染。这就是为什么 fiber reconciler 增加了优先级策略:</p>

<pre><code class="language-JSON">module.exports = {
  NoWork: 0, // No work is pending.
  SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects.
  AnimationPriority: 2, // Needs to complete before the next frame.
  HighPriority: 3, // Interaction that needs to complete pretty soon to feel responsive.
  LowPriority: 4, // Data fetching, or result from updating stores.
  OffscreenPriority: 5, // Won't be visible but do the work in case it becomes visible.
}
</code></pre>

<p>另一方面由于协调阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 <code class="highlighter-rouge">componentWillMount</code>、<code class="highlighter-rouge">componentWillReceiveProps</code> 和 <code class="highlighter-rouge">componetWillUpdate</code> 标记为 <code class="highlighter-rouge">unsafe</code>，并使用新的生命周期函数 <code class="highlighter-rouge">getDerivedStateFromProps</code> 和 <code class="highlighter-rouge">getSnapshotBeforeUpdate</code> 进行替换。</p>

<p><img src="https://i.loli.net/2019/11/12/kjEibw9mTK2FLgQ.png" alt="react-fiber-phase.png" /></p>

<blockquote>
  <p>我们可以看下 youtube 发布的 stack 与 fiber 对比视频，<a href="https://www.youtube.com/watch?v=Qu_6ItnlDQg">戳这里</a> 👈。完整<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">视频戳这里</a> 👈</p>
</blockquote>

<h2 id="snabbdom">snabbdom</h2>

<p>Vue 则是基于 <a href="https://github.com/snabbdom/snabbdom"><strong>snabbdom</strong></a> VDOM 库来实现 diff 算法，它专注于使用的简单以及功能和的模型化，并在效率和性能上有着很好的表现。</p>

<p>在 snabbdom 中提供了 <code class="highlighter-rouge">h</code> 函数做为创建 VDOM 的主要函数，h 函数接受的三个参数同时揭示了 diff 算法中关注的三个核心：节点类型，属性数据，子节点对象。而 <code class="highlighter-rouge">patch</code> 方法即是用来创建初始 DOM 节点与更新 VDOM 的 diff 核心函数。一个使用 snabbdom 创建的 demo 是这样的:</p>

<pre><code class="language-JS">import snabbdom from 'snabbdom';
import h from 'snabbdom/h'; // helper function for creating vnodes

const patch = snabbdom.init([
  require('snabbdom/modules/class'),          // makes it easy to toggle classes
  require('snabbdom/modules/props'),          // for setting properties on DOM elements
  require('snabbdom/modules/style'),          // handles styling on elements with support for animations
  require('snabbdom/modules/eventlisteners'), // attaches event listeners
]);

var vnode = h('div', {style: {fontWeight: 'bold'}}, 'Hello world');
patch(document.getElementById('placeholder'), vnode)
</code></pre>

<blockquote>
  <p>Therefore, the mainstream diff algorithm of VirtualDOM tends to be consistent at present. In the main diff idea, snabbdom and react have basically the same reconilation method.</p>
</blockquote>

<h2 id="参考链接">参考链接</h2>

<ol>
  <li><a href="https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130">Virtual DOM in ReactJS</a> By Rupesh Mishra</li>
  <li><a href="https://programmingwithmosh.com/react/react-virtual-dom-explained/">React Virtual DOM Explained in Simple English</a> By Mosh Hamedani</li>
  <li><a href="https://github.com/creeperyang/blog/issues/44">学习与理解 React Fiber</a> By creeperyang</li>
  <li><a href="https://www.zhihu.com/question/49496872">知乎 - 如何理解 React Fiber 架构？</a></li>
  <li><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57">React Fiber</a> - 妖僧风月</li>
  <li><a href="https://zhuanlan.zhihu.com/p/35876032">探索 Virtual DOM 的前世今生</a> - 郭羽峰</li>
</ol>
 
<div id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
      enable: true,
      clientID: '020f142489f80c92b097',
      clientSecret: '1fa083372b44031cf1b8249251515c4e3d54c69d',
      repo: 'tate-young.github.io',
      owner: 'Tate-Young',
      admin: ['Tate-Young'],
      id: location.pathname,      // Ensure uniqueness and length less than 50
      distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')
</script>
<!-- disqus -->
<!-- <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function () {
        this.page.url = 'https://tate-young.github.io/2019/10/24/react-virtual-dom.html';
        this.page.identifier = '/2019/10/24/react-virtual-dom';
        this.page.title = 'React Virtual DOM';
    };

    (function () { // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document,
            s = d.createElement('script');

        s.src = '//tate.disqus.com/embed.js'; // IMPORTANT: Replace EXAMPLE with your forum shortname!

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript> -->


            <!-- <p class="post-info">
			本文由 <a href="/">liberxue</a> 创作，采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external nofollow">知识共享署名4.0</a> 国际许可协议进行许可<br>本站文章除注明转载/出处外，均为本站原创或翻译，转载前请务必署名<br>最后编辑时间为:2019-10-24 15:55:00</p> -->
        </div>
    </article>

    <!-- <div class="related-post-lists">
	<div class="post-lists">
		<div class="post-lists-body">
					<div class="post-list-item">
				<div class="post-list-item-container">
					<div class="item-label">
						<div class="item-title"><a href="induction.html">归纳的随想</a></div>
						<div class="item-meta clearfix">
														<div class="item-meta-ico bg-ico-image" style="background: url('../usr/themes/pinghsu/images/bg-ico.png') no-repeat;background-size: 40px auto;"></div>
	                        							<div class="item-meta-cat"><a href="../category/thoughts/index.html">Thoughts</a></div>
						</div>
					</div>
				</div>
			</div>
				</div>
	</div>
</div> -->

    <!-- <footer class="footer bg-white">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
	 <a class="social segmentfault" target="blank" href="https://segmentfault.com/u/liberxue" title="访问 LiberXue_Twitter" data-hover="Segmentfault">Segmentfault</a>
    <a class="social github" target="blank" href="https://github.com/liberxue" title="访问 LiberXue_Twitter" data-hover="GitHub">GitHub</a>
    <a class="social twitter" target="blank" href="http://twitter.com/liberxue" title="访问 LiberXue_Twitter" data-hover="Twitter">Twitter</a>
     <a class="social stackoverflow" target="blank" href="https://stackoverflow.com/users/6902190/liberxue" title="访问 LiberXue_stackoverflow" data-hover="StackOverflow">StackOverflow</a>
          <a class="social oschina" target="blank" href="https://my.oschina.net/bolanzw" title="访问 LiberXue_Oschina" data-hover="Oschina">Oschina</a>
     <a class="social rss" target="blank" href="/feed.xml"title="访问 LiberXue_RSS" data-hover="RSS">RSS</a>
	</div>
		</div>
	</div>
	<div class="footer-meta">
        <div class="footer-container">
            <div class="meta-item meta-copyright">
                <div class="meta-copyright-info">
                    <a href="/" class="info-logo">
                         <img src="http://localhost:2333/style/images/logo-liberxue.png"   title="访问 LiberXue_blog" data-hover="LiberXue_blog" alt="LiberXue_blog" /> </a>
                    <div class="info-text">
                        <p>Theme is <a href="http://www.liberxue.com/2017/08/03/Jekyllthemes.html" title="访问 Jekyll liberxue主题"  data-hover="Jekyll liberxue"target="_blank">Jekyll liberxue</a> by <a href="http://www.liberxue.com/about" target="_blank">liberxue</a></p>
                        <p>Powered by <a href="http://localhost:2333/tags/#Jekyll" title="Jekyll" data-hover="Jekyll" target="_blank" rel="nofollow">Jekyll</a></p>
                        <p>&copy; 2017 <a href="/feed.xml"  title="访问 liberxue blog RSS" data-hover="liberxue blog RSS">liberxue blog RSS</a></p>
                        <p>总计文章：篇</p>
                      <p>本blog已开源点击Fork</p><iframe src="http://ghbtns.com/github-btn.html?user=liberxue&repo=liberxue.github.io&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="95" height="20"></iframe>
                    </div>
                </div>
            </div>
            <div class="meta-item meta-posts">
                <h3 class="meta-title">置顶文章</h3>
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
            </div>
            <div class="meta-item meta-comments">
                <h3 class="meta-title">最新文章</h3>
  
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
</div>
		</div>
    </div>
</footer> -->
<script src="//cdn.bootcss.com/jquery/2.2.2/jquery.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap-3-typeahead/4.0.2/bootstrap3-typeahead.js"></script>
<script async src="/search/js/520.js"></script>
<script async src="/search/js/gtag.js"></script>
<script async src="/search/live2d/autoload.js"></script>
<!-- <script src="/search/js/canvas.js"></script> -->

<script>
    $(function () {
        setTimeout(function () {
            $('code').removeClass('hljs');
            $('code').removeClass('language');
        }, 90);
    });
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <!--liberxueconnnet-menu-->
    <div id="directory-content" class="directory-content">
        <div id="directory"></div>
    </div>
    <!--liberxueconnnet-menu-->
    <script>
      const directoryContainer = document.getElementById('directory')
      const postTitle = document.getElementsByClassName('post-title')[0]
      var postDirectoryBuild = function () {
        var postChildren = function children(childNodes, reg) {
          var result = [],
              isReg = typeof reg === 'object',
              isStr = typeof reg === 'string',
              node, i, len;
          for (i = 0, len = childNodes.length; i < len; i++) {
            node = childNodes[i];
            if ((node.nodeType === 1 || node.nodeType === 9) &&
              (!reg ||
                  isReg && reg.test(node.tagName.toLowerCase()) ||
                  isStr && node.tagName.toLowerCase() === reg)) {
                result.push(node);
              }
            }
            return result;
          },
          createPostDirectory = function (article, directory, isDirNum) {
            var contentArr = [],
                titleId = [],
                levelArr, root, level,
                currentList, list, li, link, i, len;
            levelArr = (function (article, contentArr, titleId) {
                  var titleElem = postChildren(article.childNodes, /^h\d$/),
                      levelArr = [],
                      lastNum = 1,
                      lastRevNum = 1,
                      count = 0,
                      guid = 1,
                      id = 'directory' + (Math.random() + '').replace(/\D/, ''),
                      lastRevNum, num, elem;
                  while (titleElem.length) {
                      elem = titleElem.shift();
                      contentArr.push(elem.innerHTML);
                      num = +elem.tagName.match(/\d/)[0];
                      if (num > lastNum) {
                          levelArr.push(1);
                          lastRevNum += 1;
                      } else if (num === lastRevNum ||
                          num > lastRevNum && num <= lastNum) {
                          levelArr.push(0);
                          lastRevNum = lastRevNum;
                      } else if (num < lastRevNum) {
                          levelArr.push(num - lastRevNum);
                          lastRevNum = num;
                      }
                      count += levelArr[levelArr.length - 1];
                      lastNum = num;
                      elem.id = elem.id || (id + guid++);
                      titleId.push(elem.id);
                  }
                  if (count !== 0 && levelArr[0] === 1) levelArr[0] = 0;

                  return levelArr;
              })(article, contentArr, titleId);
              currentList = root = document.createElement('ul');
              dirNum = [0];
              for (i = 0, len = levelArr.length; i < len; i++) {
                  level = levelArr[i];
                  if (level === 1) {
                      list = document.createElement('ul');
                      if (!currentList.lastElementChild) {
                          currentList.appendChild(document.createElement('li'));
                      }
                      currentList.lastElementChild.appendChild(list);
                      currentList = list;
                      dirNum.push(0);
                  } else if (level < 0) {
                      level *= 2;
                      while (level++) {
                          if (level % 2) dirNum.pop();
                          currentList = currentList.parentNode;
                      }
                  }
                  dirNum[dirNum.length - 1]++;
                  li = document.createElement('li');
                  link = document.createElement('a');
                  link.name = '#' + titleId[i];
                  link.href = 'Javascript:;'
                  link.className = "post-aside-anchor"
                  link.title = '访问' + titleId[i];
                  link.innerHTML = !isDirNum ? contentArr[i] :
                      dirNum.join('.') + ' ' + contentArr[i];
                  li.appendChild(link);
                  currentList.appendChild(li);
              }
            directory.appendChild(root);
          };
        createPostDirectory(document.getElementById('post-content'), directoryContainer, true);
      };
      postDirectoryBuild();
    </script>
    <script>
      // gtag('config', GA_TRACKING_ID, {
      //   'page_title' : 'Blog',
      //   'page_path': window.location.pathname,
      //   'post_title': 'watttsdfasdf',
      // });

    </script>
    <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
        lang = hljs.initHighlightingOnLoad();
    </script>
</body>

</html>
