---
layout: blog
back: true
comments: True
flag: Server
background: gray
category: 后端
title: Redis 简介
date: 2019-07-08 10:47:00 GMT+0800 (CST)
background-image: https://i.loli.net/2019/02/18/5c6a6d4ec366c.png
tags:
- Server
---
# {{ page.title }}

**Redis(Remote Dictionary Service)** 即远程字典服务，是互联网技术领域使用最为广泛的存储中间件。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。不同于之前文章就介绍的 Oracle 和 Mongodb，它是 key-value 型数据库，默认端口号为 6379。以下介绍基本[摘自掘进小册](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc2e5f51882542714ff291) 👍

> [网页在线体验戳这里](https://try.redis.io) 👈

## 基础类型

Redis 目前一共有五种基础类型:

| 基础类型        |   描述   |
| ------------ | ------- |
| 字符串 string | Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据 |
| 列表 list | 列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理 |
| 字典 hash | 内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构 |
| 集合 set | 相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的 |
| 有序集合 zset | 类似于 Java 的 SortedSet 和 HashMap 的结合体 |

### string / list / hash / set / zset

1、字符串 string

Redis 的字符串是**动态字符串**，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，其最大长度为 512M。

```SHELL
# 键值对
> set name tate
OK
> get name
"tate"
> exists name
(integer) 1
> del name
(integer) 1
> get name
(nil)
```

```SHELL
# 批量键值对，节省网络耗时开销
> set name1 tate
OK
> set name2 holycoder
OK
> mget name1 name2 name3 # 返回一个列表
1) "tate"
2) "holycoder"
3) (nil)
> mset name1 boy name2 girl name3 unknown
> mget name1 name2 name3
1) "boy"
2) "girl"
3) "unknown"
```

还可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间:

```SHELL
> set name tate
> get name
"tate"
> expire name 5  # 5s 后过期
...  # wait for 5s
> get name
(nil)

> setex name 5 tate  # 5s 后过期，等价于 set+expire
> get name
"tate"
... # wait for 5s
> get name
(nil)

> setnx name tate  # 如果 name 不存在就执行 set 创建
(integer) 1
> get name
"tate"
> setnx name holycoder
(integer) 0  # 因为 name 已经存在，所以 set 创建不成功
> get name
"tate"  # 没有改变
```

2、列表 list

Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n):

![redis-list.gif](https://i.loli.net/2019/07/08/5d22fc3fd000195913.gif)

```SHELL
# 栈: 右边进右边出
> rpush books python java golang
(integer) 3
> rpop books
"golang"
> rpop books
"java"
> rpop books
"python"
> rpop books
(nil)
```

3、字典 hash

Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。不同的是，Redis 的字典的值只能是字符串，另外它们 **rehash** 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略:

![redis-hash.gif](https://i.loli.net/2019/07/08/5d22fc3fcdcd761431.gif)

hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。但 hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡:

```SHELL
> hset books java "think in java"  # 命令行的字符串如果包含空格，要用引号括起来
(integer) 1
> hset books golang "concurrency in go"
(integer) 1
> hset books python "python cookbook"
(integer) 1
> hgetall books  # entries()，key 和 value 间隔出现
1) "java"
2) "think in java"
3) "golang"
4) "concurrency in go"
5) "python"
6) "python cookbook"
> hlen books
(integer) 3
> hget books java
"think in java"
> hset books golang "learning go programming"  # 因为是更新操作，所以返回 0
(integer) 0
> hget books golang
"learning go programming"
> hmset books java "effective java" python "learning python" golang "modern golang programming"  # 批量 set
OK
```

4、集合 set

Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL:

![redis-set.gif](https://i.loli.net/2019/07/08/5d22fd3445b4b30491.gif)

set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次:

```SHELL
> sadd books python
(integer) 1
> sadd books python  #  重复
(integer) 0
> sadd books java golang
(integer) 2
> smembers books  # 注意顺序，和插入的并不一致，因为 set 是无序的
1) "java"
2) "python"
3) "golang"
> sismember books java  # 查询某个 value 是否存在，相当于 contains(o)
(integer) 1
> sismember books rust
(integer) 0
> scard books  # 获取长度相当于 count()
(integer) 3
> spop books  # 弹出一个
"java"
```

5、有序集合 zset

zset 类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做[**跳跃列表**](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5ac63d5188256255299d9c)的数据结构:

![redis-zset.gif](https://i.loli.net/2019/07/08/5d22fdec2d9a424961.gif)

例如 zset 可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次:

```SHELL
> zadd books 9.0 "think in java"
(integer) 1
> zadd books 8.9 "java concurrency"
(integer) 1
> zadd books 8.6 "java cookbook"
(integer) 1
> zrange books 0 -1  # 按 score 排序列出，参数区间为排名范围
1) "java cookbook"
2) "java concurrency"
3) "think in java"
> zrevrange books 0 -1  # 按 score 逆序列出，参数区间为排名范围
1) "think in java"
2) "java concurrency"
3) "java cookbook"
> zcard books  # 相当于 count()
(integer) 3
> zscore books "java concurrency"  # 获取指定 value 的 score
"8.9000000000000004"  # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题
> zrank books "java concurrency"  # 排名
(integer) 1
> zrangebyscore books 0 8.91  # 根据分值区间遍历 zset
1) "java cookbook"
2) "java concurrency"
> zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。
1) "java cookbook"
2) "8.5999999999999996"
3) "java concurrency"
4) "8.9000000000000004"
> zrem books "java concurrency"  # 删除 value
(integer) 1
> zrange books 0 -1
1) "java cookbook"
2) "think in java"
```

以上这四种数据结构(除开字符串)是容器型数据结构，它们共享下面两条通用规则：

* **create if not exists**

如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。

* **drop if no elements**

如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。

### 过期时间

Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。

还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失:

```SHELL
> set codehole yoyo
OK
> expire codehole 600
(integer) 1
> ttl codehole
(integer) 597
> set codehole yoyo
OK
> ttl codehole
(integer) -1
```

## 参考链接

1. [Redis 深度历险：核心原理与应用实践 - 掘进小册](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc2e5f51882542714ff291) By 老钱
