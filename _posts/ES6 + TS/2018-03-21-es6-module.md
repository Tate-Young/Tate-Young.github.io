---
layout: blog
front: true
comments: True
flag: ES6
background: blue
category: 前端
title:  Module 模块
# date:   2018-03-21 15:07:00 GMT+0800 (CST)
background-image: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2447683882,2644927629&fm=27&gp=0.jpg
tags:
- ES6
---
# {{ page.title }}

## Module

### 静态加载

在 ES6 推出 **Module**(模块)之前，模块加载方案主要有以下几种:

* **CommonJS** - 同步加载模块，一般用于服务器，如 NodeJS
* **AMD** - 异步加载模块，一般用于浏览器，如 RequireJS
* **CMD** - 异步加载模块，一般用于浏览器，如 SeaJS

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性:

```JS
// CommonJS模块 运行时加载
let { stat, exists, readFile } = require('fs');

// 等价于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。

```JS
// 编译时加载
import { stat, exists, readFile } from 'fs';
```

### export

**export** 命令用于规定模块的对外接口。对于输出变量，可以采用以下三种写法:

```JS
// 写法一
export var foo = 1;

// 写法二
var foo = 1;
export { foo };
// export foo; // 报错

// 写法三 as 取别名
var bar = 1;
export { bar as foo };
```

同样对于函数或者类，也要注意写法:

```JS
// 报错
function f() {}
export f;

// 正确
export function f() {};

// 正确
function f() {}
export { f };
```

export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值，而 CommonJS 模块输出的是值的缓存，不存在动态更新。

```JS
// 输出变量 foo，值为 bar，500 毫秒之后变成 baz
export var foo = 'bar';
setTimeout(() => foo = 'baz', 500);
```

### import

**import** 命令用于输入其他模块提供的功能。import 命令具有提升效果，会提升到整个模块的头部执行。除了指定加载某个输出值，还可以使用整体加载，即用星号 (*) 指定一个对象:

```JS
// circle.js
export function area(radius) {
  return Math.PI * radius * radius;
}

export function circumference(radius) {
  return 2 * Math.PI * radius;
}
```

```JS
// 加载模块
import { area, circumference } from './circle';

console.log('圆面积：' + area(4));
console.log('圆周长：' + circumference(14));

// 等价于
import * as circle from './circle';

console.log('圆面积：' + circle.area(4));
console.log('圆周长：' + circle.circumference(14));
```

import 识别加载文件的三种姿势:

* 引用相对路径，则直接寻找该相对路径文件 export 输出。
* 绝对路径，则会依次寻找 node_modules 目录，直到全局目录。
* 路径为文件夹时，则会首先观察文件夹下是否有 package.json ,如果有 package.json 则会去加载 main 字段指向的文件，如果没有 package.json，则会在这个文件夹下寻找 index.js 文件并加载。

```JS
const api = require('./api'); // api 是文件夹

// 若 api 文件夹下无 package.json 则等价于
const api = require('./api/index.js');
```

> import * 会忽略 circle 模块里输出的 default 方法

### export default

使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载，因此可以用 **export default** 为模块指定默认输出。一个模块只能有一个默认输出，因此 export default 命令只能使用一次。import 命令后面可以不用加大括号。

```JS
function add(x, y) {
  return x + y;
}
export {add as default};
// 等同于
export default add;
```

```JS
// 输入
import { default as foo } from 'modules';
// 等同于
import foo from 'modules';
```

因为 export default 命令只是输出一个叫 default 的变量，所以它后面不能跟变量声明语句:

```JS
// 正确
export var foo = 1;

// 正确
var foo = 1;
export default foo;

// 错误
export default var foo = 1;
```

### 加载实现

* 浏览器

```HTML
<!-- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见，且默认使用严格模式 -->
<script type="module" src="./foo.js"></script>
<!-- 等同于 -->
<script type="module" src="./foo.js" defer></script>

<!-- 或者采用内联 -->
<script type="module">
  // your ES6 code here
</script>
```

* NodeJS

NodeJS 遵循的是 CommonJS 规范，ES6 模块与 CommonJS 的区别主要是以下两点:

* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

NodeJS 要求 ES6 模块采用 .mjs 后缀文件名，目前只是试验版本:

```JS
// lib.mjs
export function add(x, y) {
    return x + y;
}

// main.mjs
import { add } from './lib.mjs';

console.log('Result: ' + add(2, 3));
```

```SHELL
node --experimental-modules main.mjs
# ExperimentalWarning: The ESM module loader is experimental.
# Result 5
```

CommonJS 模块的输出都定义在 module.exports 这个属性上面。NodeJS 上用 import 命令加载 CommonJS 模块时，会自动将 module.exports 属性当作模块的默认输出，即等同于 export default:

```JS
// tate.js
module.exports = 'tate'

// 等同于
export default 'tate'
```

```JS
// main.mjs
import name from './tate.js'
console.log(name) // 'tate'
```

CommonJS 加载是具有缓存的，无论加载多少次，都只会在第一次加载时运行，以后再加载就返回第一次运行的结果，除非手动清除系统缓存。原因是 require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象:

```JS
{
  id: '...', // 模块名
  exports: { ... }, // 模块输出的各个接口
  loaded: true, // 布尔值，表示该模块的脚本是否执行完毕
  ...
}
```

* 转码工具

可以使用转码工具将 ES6 语法转换为 ES5 语法。如 [Babel](https://babeljs.cn/)、[ES6 module transpiler](https://github.com/esnext/es6-module-transpiler)、[SystemJS](https://github.com/systemjs/systemjs) 等。

## Babel

未完待续。

## 参考链接

1. [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/module) By 阮一峰
1. [Using ES modules natively in Node.js](http://2ality.com/2017/09/native-esm-node.html) By Axel Rauschmayer
1. [前端模块化开发](http://luckyabby.com/post/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/) By luckyabby