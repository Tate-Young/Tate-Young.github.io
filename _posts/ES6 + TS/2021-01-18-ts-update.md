---
layout: blog
front: true
comments: True
flag: TS
background: blue
category: å‰ç«¯
title: TypeScript é—®é¢˜æ”¶é›†
date: 2021-01-21 22:47:00 GMT+0800 (CST)
update: 2021-03-22 17:48:00 GMT+0800 (CST)
description: add type definitions isDistributive question
background-image: /style/images/smms/typescript.png
tags:
- TS
---
# {{ page.title }}

## æ›´æ–°ç‚¹

### import type

åœ¨ä»¥å¾€ç‰ˆæœ¬ä¸­ï¼Œå¦‚æœæˆ‘ä»¬è¦å¯¼å…¥ä¸€ä¸ªå€¼æˆ–ç±»å‹ï¼Œç›´æ¥å…¨éƒ¨å¯¼å…¥å³å¯ï¼Œåœ¨ TS è½¬ JS çš„æ—¶å€™ï¼ŒTS ä¼šè¯†åˆ«å‡ºé‚£äº›å¯¼å…¥é¡¹è¢«å½“åšç±»å‹ä½¿ç”¨ï¼Œå¹¶å°†å…¶åˆ é™¤ã€‚ä½†æ˜¯æœ‰æ—¶å€™ TS å¹¶ä¸èƒ½è¯†åˆ«æˆ‘ä»¬å¯¼å…¥çš„åˆ°åº•æ˜¯å€¼è¿˜æ˜¯ç±»å‹ã€‚[**Typescript 3.8**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) é‡Œæ–°å¢äº†ä¸€ä¸ªæ–°çš„è¯­æ³• `import type`ï¼Œå³ä»…å¯¼å…¥ç±»å‹ã€‚åŒæ · `export type` ä»…æä¾›ä¸€ä¸ªç”¨äºç±»å‹çš„å¯¼å‡ºï¼Œæœ€ç»ˆéƒ½ä¼šè¢«åˆ é™¤:

```JS
import type { SomeThing } from "./some-module.js"

export type { SomeThing }
```

> if youâ€™ve hit issues under `--isolatedModules`, TypeScriptâ€™s `transpileModule` API, or `Babel`, this feature might be relevant.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ä½¿ç”¨ä»…ç±»å‹å¯¼å…¥åŠŸèƒ½æ—¶ï¼Œå¯¼å…¥ class çš„è¯ä¸èƒ½å¯¹å…¶è¿›è¡Œæ‰©å±•:

```JS
import type { Component } from "react"

interface ButtonProps {
  // ...
}

class Button extends Component<ButtonProps> {
  //                 ~~~~~~~~~
  // error! 'Component' only refers to a type, but is being used as a value here.
  // ...
}
```

### Top-Level Await

ä¸€èˆ¬æƒ…å†µä¸‹æˆ‘ä»¬åœ¨ä½¿ç”¨ await è¯­æ³•çš„æ—¶å€™ï¼Œå¿…é¡»åŒ…è£¹åœ¨ async å‡½æ•°ä¸­ï¼Œç„¶åç«‹å³è°ƒç”¨è¯¥å‡½æ•°æ¥æ‰§è¡Œå¼‚æ­¥æ“ä½œ:

```JS
async function main() {
  const response = await fetch("...");
  const greeting = await response.text();
  console.log(greeting);
}

main().catch((e) => console.error(e));
```

[**Typescript 3.8**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#top-level-await) æ–°å¢äº† `Top-Level Await` æ¥çœå»è¿™éƒ¨åˆ†åŒ…è£…ä»£ç ã€‚æ­¤å¤–æ³¨æ„ä¸€ç‚¹ï¼Œ`Top-Level await` åªåœ¨é¡¶çº§æ¨¡å—å·¥ä½œï¼Œæ‰€ä»¥ä»£ç ä¸­éœ€è¦å«æœ‰ export æˆ–è€… import æ‰ä¼šè®¤ä¸ºè¯¥æ–‡ä»¶æ˜¯ä¸€ä¸ªæ¨¡å—ã€‚å¯¹äºæ²¡æœ‰ä¾èµ–çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `export {}`:

```JS
// é¡¶çº§æ¨¡å—
const response = await fetch("...");
const greeting = await response.text();
console.log(greeting);

// Make sure we're a module
export {};
```

### bigint

[**Typescript 3.2**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint) é’ˆå¯¹äº [**BigInt**](( {{site.url}}/2020/05/05/js-floating-points.html#bigint )) ç±»å‹åšäº†æ”¯æŒï¼Œè¡¨ç¤ºä¸ºå°å†™çš„ **bigint**ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œbigint å’Œ number æ˜¯ä¸¤ç§ä¸åŒçš„ç±»å‹:

```JS
declare let foo: number;
declare let bar: bigint;

foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.

// æ··åˆè®¡ç®—ä½¿ç”¨çš„æ—¶å€™ï¼Œå¿…é¡»å°†æ•°å­—ç±»å‹è½¬æ¢ä¸º bigint
console.log(3.141592 * 10000n); // error
console.log(3145 * 10n); // error
console.log(BigInt(3145) * 10n); // okay!
```

### @ts-nocheck / @ts-ignore

ä¸ºäº†è®©ç”¨æˆ·èƒ½ä» JS åˆ° TS å¹³æ»‘è¿‡æ¸¡ï¼ŒåŸå…ˆèƒ½é€šè¿‡ `--allowJs` æ¥æ”¯æŒ TS å’Œ JS æ–‡ä»¶çš„æ··åˆåœ¨ä¸€èµ·ç¼–è¯‘ï¼Œä¸ä¼šå¯¹ JS æ–‡ä»¶å»åšç±»å‹æ£€æŸ¥ã€‚[**Typescript 2.3**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#errors-in-js-files-with---checkjs) å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¥å®ç°å¯¹æ··åˆåœ¨ä¸€èµ·çš„ JS æ–‡ä»¶ä¸€èµ·åšç±»å‹æ£€æŸ¥:

1. é€šè¿‡å¼€å¯ `--checkJs` é…ç½®æ¥å¯¹ JS æ–‡ä»¶å»åšæ£€æµ‹ã€‚åœ¨ JS æ–‡ä»¶ä¸­ï¼Œå¯ä»¥é€šè¿‡åœ¨é¡¶éƒ¨æ·»åŠ  `@ts-nocheck` æ³¨é‡Šè·³è¿‡è¯¥æ–‡ä»¶ç±»å‹æ£€æµ‹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ·»åŠ  `@ts-ignore` æ³¨é‡Šè·³è¿‡ä¸‹ä¸€è¡Œçš„æ–‡ä»¶ç±»å‹æ£€æµ‹
2. ç›´æ¥é€šè¿‡ `@ts-check` å¯¹ JS æ–‡ä»¶å»åšæ£€æµ‹

å¹¶ä¸”åšç±»å‹æ£€æµ‹çš„æ—¶å€™ï¼Œè¿˜å¯ä»¥æ ¹æ® jsdoc çš„ç±»å‹æ³¨è§£è‡ªåŠ¨æ¥è¿›è¡Œåˆ¤æ–­:

```JS
// @ts-check

/**
 * @param {string} input
*/
function foo ( input ) {
  input.tolowercase ()
      // ~~~~~~~~~~~ Error!  Should be toLowerCase
} 
```

> åˆ°äº† [**Typescript 3.7**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#-ts-nocheck-in-typescript-files)ï¼Œ`@ts-nocheck` çš„æ³¨é‡Šä¹Ÿå¯ä»¥ä¸ä»…ä»…é’ˆå¯¹ JS æ–‡ä»¶ï¼ŒåŒæ ·å¯ä»¥ä½œç”¨äº TS æ–‡ä»¶ã€‚

> åˆ°äº† [**Typescript 4.1**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checkjs-implies-allowjs)ï¼Œè®¾ç½® `--checkJs` çš„æ—¶å€™ä¼šé»˜è®¤å¼€é€š `--allowJS`

### @ts-expect-error

å½“æˆ‘ä»¬é€šè¿‡ `@ts-expect-error` æ¥è¿›è¡Œæ³¨é‡Šæ—¶ï¼ŒTS æŠ›å‡ºçš„ç±»å‹é”™è¯¯ä¼šè¢«å¿½ç•¥ï¼›å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œåˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ `Unused '@ts-expect-error' directive.`ã€‚é€šå¸¸æˆ‘ä»¬çš„ä½¿ç”¨åœºæ™¯å¯èƒ½æ˜¯å•å…ƒæµ‹è¯•ï¼Œæ¯”å¦‚:

```JS
function doStuff(abc: string, xyz: string) {
  assert(typeof abc === "string");
  assert(typeof xyz === "string");

  // do some stuff
}
```

```JS
// å•å…ƒæµ‹è¯•
expect(() => {
  doStuff(123, 456);
}).toThrow();
```

å¦‚æœå•å…ƒæµ‹è¯•ä¹Ÿæ˜¯ç”¨ TS æ¥ç¼–å†™çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¦‚ä¸‹çš„æŠ¥é”™:

```JS
doStuff(123, 456);
//           ~~~
// error: Type 'number' is not assignable to type 'string'.
```

å› æ­¤é€šè¿‡ä¸Šè¿°çš„æ³¨é‡Šæˆ‘ä»¬å°±èƒ½è·³è¿‡è¿™ä¸ªç±»å‹æ£€æµ‹ã€‚ä½†æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒåœ¨åŠŸèƒ½ä¸Šå’Œ `@ts-ignore` å¾ˆç›¸ä¼¼å‘€ï¼Œä¸ºå•¥è¦å•ç‹¬å¼•å…¥è¿™ä¸ªæŒ‡ä»¤å‘¢ï¼Œä½ ä¼š pick è°ï¼Ÿä¸‹é¢æ˜¯å®˜ç½‘è´´å‡ºæ¥çš„ä¸¤è€…çš„æ¯”è¾ƒ:

* Pick ts-expect-error if:

1. youâ€™re writing test code where you actually want the type system to error on an operation
1. you expect a fix to be coming in fairly quickly and you just need a quick workaround
1. youâ€™re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again

* Pick ts-ignore if:

1. you have a larger project and new errors have appeared in code with no clear owner
1. you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.
1. you honestly donâ€™t have the time to decide which of these options is better.

### Template Literal Types

[**Typescript 4.1**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) é‡Œå¼•å…¥äº†å­—ç¬¦ä¸²æ¨¡æ¿ç±»å‹ï¼Œç®€å•çš„çœ‹ä¸‹:

```JS
type Color = "red" | "blue";
type Quantity = "one" | "two";

type SeussFish = `${Quantity | Color} fish`;
//   ^ = type SeussFish = "one fish" | "two fish" | "red fish" | "blue fish"
```

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸¾ä¸ªå®é™…ä¸€ç‚¹çš„æ —å­ï¼Œæ¯”å¦‚è¦ä¼ å…¥ä¸€äº›ä½ç§»å‚æ•°:

```JS
type VerticalAlignment = "top" | "middle" | "bottom"
type HorizontalAlignment = "left" | "center" | "right"

// Takes
//   | "top-left"    | "top-center"    | "top-right"
//   | "middle-left" | "middle-center" | "middle-right"
//   | "bottom-left" | "bottom-center" | "bottom-right"

declare function setAlignment(value: `${VerticalAlignment}-${HorizontalAlignment}`): void

setAlignment("top-left");   // works!
setAlignment("top-middel"); // error!
// Argument of type '"top-middel"' is not assignable to parameter of type '"top-left" | "top-center" | "top-right" | "middle-left" | "middle-center" | "middle-right" | "bottom-left" | "bottom-center" | "bottom-right"'.
```

å†çœ‹ä¸ªç¨å¾®å¤æ‚ç‚¹çš„æ —å­:

```JS
type PropEventSource<T> = {
  on<K extends string & keyof T>
    (eventName: `${K}Changed`, callback: (newValue: T[K]) => void ): void;
};

declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;

let person = makeWatchedObject({
  firstName: "Homer",
  age: 42,
  location: "Springfield",
});

// works! 'newName' is typed as 'string'
person.on("firstNameChanged", newName => {
  // 'newName' has the type of 'firstName'
  console.log(`new name is ${newName.toUpperCase()}`);
});

// works! 'newAge' is typed as 'number'
person.on("ageChanged", newAge => {
  if (newAge < 0) {
    console.log("warning! negative age");
  }
})
```

### Key Remapping in Mapped Types

æ˜ å°„ç±»å‹å¯ä»¥åŸºäºä»»æ„é”®åˆ›å»ºæ–°çš„å¯¹è±¡ç±»å‹ï¼Œæ‰“ä¸ªæ¯”æ–¹:

```JS
type Options = {
  [K in "noImplicitAny" | "strictNullChecks" | "strictFunctionTypes"]?: boolean
};
// same as
//   type Options = {
//     noImplicitAny?: boolean,
//     strictNullChecks?: boolean,
//     strictFunctionTypes?: boolean
//   };
```

ä½†æ˜¯æˆ‘ä»¬ç›®å‰èƒ½å¤Ÿåšçš„åªæ˜¯åœ¨ç»™å‡ºçš„å€¼é‡Œé¢å»ç”Ÿæˆ keyï¼Œè€Œä¸èƒ½æ˜ å°„åˆ°å…¶ä»– key å€¼ï¼Œ[**Typescript 4.1**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) é€šè¿‡ **as** æä¾›äº†é‡æ–°æ˜ å°„çš„åŠŸèƒ½:

```JS
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
};

interface Person {
  name: string
  age: number
  location: string
}

type LazyPerson = Getters<Person>
//   ^ = type LazyPerson = {
//       getName: () => string;
//       getAge: () => number;
//       getLocation: () => string;
//   }
```

æˆ‘ä»¬è¿˜å¯ä»¥åˆ©ç”¨è¿™ä¸ªå®ç° Omit çš„æ•ˆæœ:

```JS
// Remove the 'kind' property
type RemoveKindField<T> = {
  [K in keyof T as Exclude<K, "kind">]: T[K]
};

interface Circle {
  kind: "circle"
  radius: number
}

type KindlessCircle = RemoveKindField<Circle>;
//   ^ = type KindlessCircle = {
//       radius: number
//   }
```

## é—®é¢˜æ”¶é›†

### union type with filter / map

å¯¹äºä¸€ä¸ªå˜é‡æ˜¯è”åˆæ•°ç»„ç±»å‹(union type)æ—¶ï¼Œæ— æ³•è°ƒç”¨å…¶ filter æˆ–è€… map æ–¹æ³•:

```js
const person: string[] | number[] = []

person.filter((p: string | number) => v !== null)
```

![filter map]( {{site.url}}/style/images/smms/ts-filter-map.png )

å¾ˆæ˜¾ç„¶ person.filter è‚¯å®šæ˜¯å¯è°ƒç”¨æ–¹æ³•ï¼Œä½†æ˜¯ TS å¯¹äºè¿™ç§æƒ…å†µçš„æç¤ºå´æ˜¯ The expression is not callableã€‚è§£å†³åŠæ³•æ˜¯å¯ä»¥æŠŠæ•°ç»„ç±»å‹ç”±è”åˆæ•°ç»„å˜ä¸ºæ•°ç»„å…ƒç´ ä¸ºè”åˆç±»å‹ï¼Œå¦‚ä¸‹ã€‚æ¨èé˜…è¯»ï¼š[**TypeScript 3.3**](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html#key-remapping-in-mapped-types)ã€‚

```js
const person: <string| number>[] = []
```

### Operands for delete must be optional

å½“ä½¿ç”¨ delete æ“ä½œç¬¦ï¼Œè¿ç®—å…ƒå¿…é¡»ä¸º `any, unknown, never`ï¼Œæˆ–è€…ä¸ºå¯é€‰(å› ä¸ºå…¶ç±»å‹ä¸­åŒ…å«äº† undefined)ã€‚å¦åˆ™ä¼šæŠ¥é”™:

```JS
interface Thing {
  prop: string
}

function f(x: Thing) {
  delete x.prop // The operand of a 'delete' operator must be optional.
}
```

ä¿®æ”¹çš„æ–¹å¼ä¹Ÿå¾ˆç®€å•ï¼Œåªè¦æŠŠç›¸å…³å±æ€§æ”¹ä¸º optional å³å¯:

```JS
interface Thing {
  prop?: string
}
```

å¦‚æœç¢°åˆ°æ¯”è¾ƒå¤æ‚çš„æ —å­ï¼Œæ¯”å¦‚æ¥å£å®šä¹‰äº†å¤šä¸ªå±æ€§çš„è¯ï¼Œè¿˜å¯ä»¥ç”¨ä»¥ä¸‹è‡ªå®šä¹‰ç±»å‹å»ä¿®æ”¹:

```JS
export type TPickPartial<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>> & Partial<Pick<T, K>>

// ä¾‹å¦‚
type TTest = TPickPartial<TAnotherTest, 'canSort' | 'scenes'>
```

### Object.keys using numbers

è°ƒç”¨ **Object.keys** è·å–å¯¹è±¡çš„ key å€¼ï¼Œåœ¨ç±»å‹æ£€æµ‹æ—¶é»˜è®¤ä¸º `string[]`ï¼Œè¿™æ ·å°±ä¼šæœ‰ä¸ªé—®é¢˜:

```JS
type Foo = { [key: number]: string }

const foo: Foo = { 100: 'foo', 200: 'bar' }
const sizes: number[] = Object.keys(foo) // Type 'string[]' is not assignable to type 'number[]
```

å› æ­¤æˆ‘ä»¬å¿…é¡»å°†å­—ç¬¦ä¸²ç±»å‹å…ˆè½¬æ¢ä¸ºæ•°å­—ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯é€šè¿‡ map æ¥å®ç°:

```JS
const sizes: number[] = Object.keys(foo).map(Number)
```

æ¥çœ‹ä¸ªå®Œæ•´ä¸€ç‚¹çš„æ —å­:

```JS
const weekMapping = {
  1: 'å‘¨ä¸€',
  2: 'å‘¨äºŒ',
  3: 'å‘¨ä¸‰',
  4: 'å‘¨å››',
  5: 'å‘¨äº”',
  6: 'å‘¨å…­',
  7: 'å‘¨æ—¥',
}

type TWeekKey = keyof typeof weekMapping

const keys = Object.keys(weekMapping).map(Number) as Array<TWeekKey>

function WeekSelector() {
  return (
    keys.map(key => (
      <Button key={key}>{weekMapping[key]}</Button>
    ))
  )
}
```

## åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ isDistributive

è¿™èŠ‚ä¸»è¦[å‚è€ƒè¿™é‡Œ](https://mp.weixin.qq.com/s/zSX7xLKSb86NVGStKQfqfw)ï¼Œå…ˆçœ‹çœ‹ä»¥ä¸‹ res çš„ç±»å‹éƒ½æ˜¯å•¥ï¼š

```js
// åœºæ™¯ä¸€
type TTest<T> = T extends number ? 1 : 2
type res = TTest<1 | 'a'>

// åœºæ™¯äºŒ
type TTest<T> = T extends true ? 1 : 2
type res = TTest<boolean>

// åœºæ™¯ä¸‰
type TTest<T> = T extends true ? 1 : 2
type res = TTest<any>

// åœºæ™¯å››
type TTest<T> = T extends true ? 1 : 2
type res = TTest<never>
```

é—®é¢˜è§£ç­”å¦‚ä¸‹ï¼š

```TEXT
<!-- åœºæ™¯ä¸€ -->
ç­”æ¡ˆï¼š1 | 2
åŸå› ï¼šå¯¹äºåˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ï¼Œè”åˆç±»å‹çš„æ¯ä¸ªç±»å‹ä¼šå•ç‹¬ä¼ å…¥æ±‚å€¼ï¼ŒæŠŠæ¯ä¸ªçš„ç»“æœåˆå¹¶æˆè”åˆç±»å‹

<!-- åœºæ™¯äºŒ -->
ç­”æ¡ˆï¼š1 | 2
åŸå› ï¼šboolean å…¶å®ä¹Ÿæ˜¯è”åˆç±»å‹ï¼Œæ‰€ä»¥ä¼šæŠŠ true å’Œ false åˆ†åˆ«ä¼ å…¥æ±‚å€¼ï¼ŒåŒä¸Š

<!-- åœºæ™¯ä¸‰ -->
ç­”æ¡ˆï¼š1 | 2
åŸå› ï¼šæ¡ä»¶ç±»å‹å¯¹ any åšäº†ç‰¹æ®Šå¤„ç†ï¼Œå¦‚æœå·¦è¾¹æ˜¯ anyï¼Œé‚£ä¹ˆç›´æ¥æŠŠ trueType å’Œ falseType åˆå¹¶æˆè”åˆç±»å‹è¿”å›

<!-- åœºæ™¯å›› -->
ç­”æ¡ˆï¼šnever
åŸå› ï¼šå½“æ¡ä»¶ç±»å‹å·¦è¾¹æ˜¯ never æ—¶ï¼Œç›´æ¥è¿”å› never
```

æˆ‘ä»¬æ ¹æ®æºç æ¥è§£é‡Šä¸‹ï¼ŒTypeScript åœ¨å¤„ç†åˆ°æ¡ä»¶ç±»å‹ Conditional Type çš„æ—¶å€™ï¼Œä¼šè®¾ç½®ä¸€ä¸ª **isDistributive** çš„å±æ€§ï¼Œæ ¹æ®ç±»å‹å‚æ•°æ˜¯ä¸æ˜¯ checkTypeï¼ˆå·¦è¾¹çš„ç±»å‹ï¼‰æ¥è®¾ç½®ï¼š

```js
function getTypeFromConditionalTypeNode(node: ConditionalTypeNode): Type {
  const links = getNodeLinks(node);
  if (!links.resolvedType) {
    const checkType = getTypeFromTypeNode(node.checkType);
    const aliasSymbol = getAliasSymbolForTypeNode(node);
    const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
    const allOuterTypeParameters = getOuterTypeParameters(node, /*includeThisTypes*/ true);
    const outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node));
    const root: ConditionalRoot = {
      node,
      checkType,
      extendsType: getTypeFromTypeNode(node.extendsType),
      isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),
      inferTypeParameters: getInferTypeParameters(node),
      outerTypeParameters,
      instantiations: undefined,
      aliasSymbol,
      aliasTypeArguments
    };
    links.resolvedType = getConditionalType(root, /*mapper*/ undefined);
    if (outerTypeParameters) {
      root.instantiations = new Map<string, Type>();
      root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
    }
  }
  return links.resolvedType;
}
```

å› ä¸º T extends number çš„ checkType æ˜¯ Tï¼Œæ‰€ä»¥è¿™é‡Œçš„ isDistributive å°±æ˜¯ trueï¼Œä¹Ÿå°±æ˜¯å®ƒæ˜¯åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ã€‚è¿™æ—¶ä¼šåœ¨æ±‚å€¼çš„æ—¶å€™æŠŠæ¯ä¸ªç±»å‹å•ç‹¬ä¼ å…¥æ±‚å€¼ï¼Œæœ€åæŠŠç»“æœåˆå¹¶ã€‚è¿™å°±æ˜¯åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹é‡åˆ°è”åˆç±»å‹æ—¶çš„å¤„ç†ï¼š

```js
// Distributive conditional types are distributed over union types. For example, when the
// distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
// result is (A extends U ? X : Y) | (B extends U ? X : Y). ğŸ‘ˆ
result = distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?
  mapTypeWithAlias(getReducedType(distributionType), t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper)), aliasSymbol, aliasTypeArguments) :
  getConditionalType(root, newMapper, aliasSymbol, aliasTypeArguments);
```

åœºæ™¯ä¸€å’ŒäºŒéƒ½ä¼šèµ° mapTypeWithAlias è¿™ä¸ªæ–¹æ³•ã€‚åœºæ™¯ä¸‰çš„ any ä¼šå‘ç°èµ°äº† getConditionalType è¿™ä¸ªæ–¹æ³•ï¼Œä¹Ÿç¡®å®šäº† any ä¸å±äº union è”åˆç±»å‹ï¼Œç»§ç»­å¾€ä¸‹çœ‹ï¼Œæ„æ€å°±æ˜¯è¿”å› trueType å’Œ falseType çš„è”åˆç±»å‹ï¼Œå› ä¸º any åŒ¹é…ä»»ä½•ç±»å‹ï¼Œä¹Ÿå°±å¾—å‡ºæœ€ç»ˆç­”æ¡ˆ 1 \| 2ï¼š

```js
// Return union of trueType and falseType for 'any' since it matches anything
if (checkType.flags & TypeFlags.Any && !isUnwrapped) {
  (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
}
```

è‡³äº never æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¾€ä¸‹èµ°äº†è¿™æ®µä»£ç ï¼Œç›´æ¥è¿”å› never äº†ï¼š

```js
if (type.flags & TypeFlags.Never) {
  return type;
}
```

æ€»ç»“ä¸€ä¸‹ï¼š**æ¡ä»¶ç±»å‹å½“ checkTypeï¼ˆå·¦è¾¹çš„ç±»å‹ï¼‰æ˜¯ç±»å‹å‚æ•°çš„æ—¶å€™ï¼Œä¼šæœ‰ distributive çš„æ€§è´¨ï¼Œä¹Ÿå°±æ˜¯ä¼ å…¥è”åˆç±»å‹æ—¶ä¼šæŠŠæ¯ä¸ªç±»å‹å•ç‹¬ä¼ å…¥åšè®¡ç®—ï¼Œæœ€åæŠŠç»“æœåˆå¹¶è¿”å›ã€‚è¿™å«åšåˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ã€‚**

> å…·ä½“æºç çš„è§£é‡Šè¯·[å‚è€ƒè¿™é‡Œ](https://mp.weixin.qq.com/s/zSX7xLKSb86NVGStKQfqfw) ğŸ‘ˆ
