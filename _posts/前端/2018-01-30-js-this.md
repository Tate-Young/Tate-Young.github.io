---
layout: blog
front: true
comments: True
flag: JS
background: blue
category: 前端
title:  JS中this指针详解
date:   2018-01-30 22:48:00 GMT+0800 (CST)
background-image: http://ot1cc1u9t.bkt.clouddn.com/17-8-1/24280498.jpg
tags:
- JavaScript
---
# {{ page.title }}

## this指针指向

指向当前函数的调用对象

## this指针案例

```js
// 实际执行的是window.getName()，全局作用域上并没有name属性
// 严格模式中指向的是undefined
function getName(){
    var name = "Tate";
    console.log(this.name); // undefined
    console.log(this); // Window
}
getName();
```

```js
// 调用的是person.spouse对象，但spouse无name属性
var person = {
    name: 'Tate',
    spouse:{
        fn: function(){
            console.log(this.name); // undefined
        }
    }
}
person.spouse.fn();
```

```js
// 赋值但并未执行函数，相当于执行的是window.fn()
var person = {
    name: 'Tate',
    spouse:{
        name: 'Snow',
        fn: function(){
            console.log(this.name); // undefined
            console.log(this); // Window
        }
    }
}
var fn = person.spouse.fn;
fn();
```

> 当构造函数遇到return时，可参考[链接2](http://blog.csdn.net/spicyboiledfish/article/details/70858565)

## call/apply/bind改变指针指向的用法

```js
function foo(p1, p2) {
    console.log(this.name); // Tate
    console.log(p1 + p2); // 3
}
var person = {
    name: 'Tate'
};
foo.call(person, 1, 2);
foo.apply(person, [1, 2]); // apply和call类似，只是参数不同，立即执行
var bar = foo.bind(person, 1);
bar(2); // bind绑定指针后并没有立即执行，参数按顺序注入，相当于bind(person,1,2)
```

## 构造函数实例化本质

```js
function Person() {
    this.name = 'Tate';
}
var p = new Person();
// new操作符的操作是
var p = {};
p.__proto__ =  Person.prototype;
Person.call(p);
```

## 参考链接

1. [彻底理解js中this的指向，不必硬背](https://www.cnblogs.com/pssp/p/5216085.html)
2. [JavaScript之构造函数内有return详解](http://blog.csdn.net/spicyboiledfish/article/details/70858565)