---
layout: blog
front: true
comments: True
flag: JS
background: blue
category: 前端
title:  JSBridge
date:   2019-12-19 19:53:00 GMT+0800 (CST)
background-image: /style/images/js.png
tags:
- JavaScript
---
# {{ page.title }}

## 什么是 JSBridge

想当年最开始工作的时候，就是做的移动端 hybrid 混合式开发，里面很重要的一环就是 JS 与原生 Native 的相互通信，而它就是我们今天要介绍的主人翁 - **JSBridge**。顾名思义，它作为一座桥梁，连接了 JS 与 Native，让前端可以方便地调用原生的摄像头、视频等，而原生也可以接收前端发出的信息而作出相应的处理。在介绍 JSBridge 原理之前，我们先看看传统方式是怎么来使用的。以下主要[摘自深度解析 JSBridge 这篇博客](https://medium.com/@Alibaba_Cloud/in-depth-profiling-of-jsbridge-63dc797f8c77):

## 传统方式 - 注入 API

### JS 调用 Native

注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JS 的 Context(window) 中注入对象或者方法，让 JS 调用时，直接执行相应的 Native 代码逻辑，这里也对应三个不同平台进行分析:

#### IOS(UIWebView)

```JS
// Native 中通过引入官方提供的 JavaScriptCore 库(iOS7 以上),然后可以将 api 绑定到 JSContext 上
// import <JavaScriptCore/JavaScriptCore.h>

JSContext *context = [uiWebView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];

// 注册方法为 postBridgeMessage
context[@"postBridgeMessage"] = ^(NSArray<NSArray *> *calls) {
  // Native 逻辑
}
```

我们可以看到上面注册了一个名为 `postBridgeMessage` 的方法，因此我们可以在前端进行调用:

```JS
window.postBridgeMessage(message)
```

> iOS7 才出现这种方式，在这之前，JS 无法直接调用 Native，只能通过 JSBridge 方式间接调用

#### IOS(WKWebView)

首先，**WKWebView** 是 ios8 之后推行的，可以替代之前的 **UIWebView** 控件，解决了很多性能和兼容上的问题，那么它又是怎么使用的呢:

```JS
@interface WKWebVIewVC ()<WKScriptMessageHandler>

@implementation WKWebVIewVC

- (void)viewDidLoad {
  [super viewDidLoad];

  WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
  configuration.userContentController = [[WKUserContentController alloc] init];
  WKUserContentController *userCC = configuration.userContentController;
  // 注入对象 nativeBridge
  [userCC addScriptMessageHandler:self name:@"nativeBridge"];

  WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];
  // ...
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
  if ([message.name isEqualToString:@"nativeBridge"]) {
    NSLog(@"前端传递的数据 %@: ", message.body);
    // Native 逻辑
  }
}
```

我们可以看到上面注册了一个名为 `nativeBridge` 的对象，因此我们可以在前端进行调用:

```JS
window.webkit.messageHandlers.nativeBridge.postMessage(message)
```

#### Android

```JS
public class JavaScriptInterfaceDemoActivity extends Activity {
  private WebView Wv;

  @Override
  publicvoidonCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);

    Wv = (WebView)findViewById(R.id.webView);
    final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);

    // Android 容器允许 JS 脚本
    Wv.getSettings().setJavaScriptEnabled(true);
    // Android 容器设置侨连对象
    Wv.addJavascriptInterface(myJavaScriptInterface, "nativeBridge");
    // ...
  }

  public class JavaScriptInterface {
    Context mContext;

    JavaScriptInterface(Context c) {
      mContext = c;
    }

    // 暴露出的接口
    @JavascriptInterface
    public void postMessage(String webMessage){
      // Native 逻辑
    }
  }
}
```

我们可以看到上面用 `nativeBridge` 设置了侨连对象，并且暴露出了 `postMessage` 接口，因此我们通过下面方式访问即可:

```JS
// 前端调用 nativeBridge
window.nativeBridge.postMessage(message)
```

> 在 Android4.2(API17) 以上版本，暴露的接口要加上注解 `@JavascriptInterface`，否则会找不到该方法

> 在 API17 以前，`addJavascriptInterface` 是有风险的，黑客可以通过反编译获取 Native 注册的 JS 对象，然后在页面通过反射 Java 的内置静态类，获取一些敏感的信息和破坏

### Native 调用 JS

Native 调用 JS 相对较简单一些，只用去执行 JS 暴露出来的全局方法即可。

1、IOS(UIWebView)

```JS
[uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString]
```

2、IOS(WKWebView)

```JS
// completionHandler 会在 JS 方法执行完后执行
[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler]
```

3、Android

```JS
// 使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果
webView.loadUrl("javascript:" + javaScriptString);
```

而 Kitkat 4.4 之后的版本，也可以用 `evaluateJavascript` 方法实现:

```JS
webView.evaluateJavascript(javaScriptString, new ValueCallback<String>() {
  @Override
  public void onReceiveValue(String value){
    // 可以拿到 JS 返回值
  }
});
```

## JSBridge 原理

有了上述的双端通信的基础通道，我们就可以基于此去构建一套易用的方法封装。同时也解决了以下存在的一些问题:

1. Android4.2 以下 `addJavascriptInterface` 方式有安全漏掉
2. iOS7 以下 JS 无法调用 Native
3. url scheme 方案较为成熟

![JSBridge](https://miro.medium.com/max/1400/0*i0r9tA8EGzSBwhAj.png)

### URL scheme

**url scheme** 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的。具体来讲如果是系统的 url scheme，则打开系统应用，否则看是否有 app 注册这种 scheme，有则打开对应 app，注意这种 scheme 必须原生 app 注册后才会生效。

而在我们实际的开发中，app 不会注册对应的 scheme，而是由前端页面通过某种方式触发 scheme(如用 iframe.src)，然后 Native 用某种方法捕获对应的 url 触发事件，然后拿到当前的触发 url，根据定义好的协议，分析当前触发了哪种方法。

### 技术实现

要实现 JSBridge，我们可以按以下步骤分析:

1. 设计出一个 Native 与 JS 交互的全局桥对象
1. JS 如何调用 Native
1. Native 如何得知 api 被调用
1. 分析 url 参数和回调的格式
1. Native 如何调用J S
1. H5 中 api 方法的注册以及格式

我们首先要定义一个全局变量，并定义一些方法:

```JS
const JSBridge = window.JSBridge || (window.JSBridge = {})
```

* registerHandler - 注册本地 JS 方法，注册后 Native 可通过 JSBridge 调用。调用后会将方法注册到本地变量 `messageHandlers` 中
* callHandler - JS 调用原生开放的 api，调用后实际上还是本地通过 url scheme 触发。调用时会将回调 id  存放到本地变量 `responseCallbacks` 中
* _handleMessageFromNative - 原生调用 JS 注册的方法，或者通知前端页面执行回调方法

![registerHandler](https://miro.medium.com/max/1400/0*2fFCZ2sM_3nyELgV.png)

在执行 `callHandler` 时，实际执行了以下步骤:

1. 判断是否有回调函数，若有，则生成一个回调函数 id，并将 id 和对应回调添加进入回调函数集合 responseCallbacks 中
2. 通过特定的参数转换方法，将传入的数据、方法名一起拼接成一个 url scheme

```JS
// 定义 url scheme
const uri = CUSTOM_PROTOCOL_SCHEME: // API_Name:callbackId/handlerName?data

// 创建隐藏 iframe 过程
const messagingIframe = document.createElement('iframe')
messagingIframe.style.display = 'none'
document.documentElement.appendChild(messagingIframe)

// 通过 iframe.src 触发 scheme
messagingIframe.src = uri
```

> 为什么选择 `iframe.src` 不选择 `locaiton.href` ？因为如果通过 `location.href` 连续调用 Native，在 Native 层只能接收到最后一次请求，从而很容易丢失一些调用

上一步，我们已经成功在前端页面中触发 scheme，那么 Native 如何捕获 scheme 被触发呢？安卓和 IOS 捕获方式如下:

```JS
// Android
public boolean shouldOverrideUrlLoading(WebView view, String url){
  // 如果返回 false，则 WebView 处理链接 url，如果返回 true，代表 WebView 根据程序来执行 url
  return true;
}
```

```JS
// ios
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
  NSURL *url = [request URL];

  NSString *requestString = [[request URL] absoluteString];
```

既然 Native 已经接收到了 JS 调用的方法，那么接下来，原生就应该按照定义好的数据格式来解析数据了，Native 接收到 Url 后，可以按照这种格式将回调参数 id、api 名、参数提取出来，然后去执行:

```JS
JSBridge._handleMessageFromNative(messageJSON)
```

在实际的开发中，我们统一出以下方案来针对 IOS 和安卓:

![strategy](https://miro.medium.com/max/1400/0*gNSgNMbYQaeoFxDA.png)

> 更多可以参考 IOS [**WebViewJavascriptBridge**](https://github.com/marcuswestin/WebViewJavascriptBridge) 和安卓 [JsBridge](https://github.com/lzyzsd/JsBridge) 的实现 👈

## 参考链接

1. [In-depth Profiling of JSBridge](https://medium.com/@Alibaba_Cloud/in-depth-profiling-of-jsbridge-63dc797f8c77) By Alibaba Cloud
