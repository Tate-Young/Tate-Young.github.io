---
layout: blog
front: true
comments: True
flag: JS
background: blue
category: 前端
title:  Error 处理机制
date:   2018-02-06 11:28:00 GMT+0800 (CST)
background-image: http://img.zcool.cn/community/01e70755db347c6ac7251df8aed0e0.jpg@900w_1l_2o_100sh.jpg
tags:
- JavaScript
---
# {{ page.title }}

## Error 类型

通过 Error 的构造器可以创建一个错误对象，当运行时错误产生时，Error 的实例对象会被抛出。通常 Error 实例对象有如下属性：

| 属性 | 描述 |
|:-------------|:------------|
| message | 错误信息 |
| name | 错误名称 |
| stack | 错误堆栈(Non-standard) |

```js
var err = new Error('我就是个错误');
err.message; // '我就是个错误'
err.name; // 'Error'
```

除了通用的 Error 构造函数外，JavaScript 还有 6 个其他类型的错误构造函数:

| 派生对象 | 描述 | 举个栗子 |
|:-------------|:------------||:-------------|
| ReferenceError | 无效引用 | x; // ReferenceError: x is not defined |
| SyntaxError | 语法解析错误 | var 1a; // SyntaxError: Invalid or unexpected token |
| RangeError | 数值变量或参数超出其有效范围 | new Array(-1); // RangeError: Invalid array length |
| TypeError | 变量或参数不属于有效类型 | new 'Tate'; // TypeError: "Tate" is not a constructor |
| URIError | 编码或解码时传递的参数无效 | decodeURI('%2'); URIError: URI malformed |
| EvalError | eval()执行错误 | 只为代码兼容，异常不再抛出 |

## 错误处理

### throw

**throw** 语句中断程序执行，并抛出一个异常。

```js
// throw 可以抛出任何类型的值。
throw 'Tate'; // Uncaught Tate
throw 1; // Uncaught 1

var a = -1;
if (a < 0) {
  throw new Error('a 必须为正数'); // Error: a 必须为正数
}
console.log(a); // 未执行
```

### try / catch / finally

**try** 代码块抛出的异常会被 **catch** 捕获，无论是否有异常，都会最后执行 **finally** 代码块。且 try 代码块里抛出的异常不会中断程序执行。

```js
try {
    foo.bar();
} catch (e) {
  if (e instanceof ReferenceError) {
    console.log(e.name + ": " + e.message);
  } else if (e instanceof TypeError) {
    console.log(e.name + ": " + e.message);
}
  throw new Error('Tate') // 此异常在 finally 执行之后抛出
} finally {
  console.log('finally'); // 'finally'
}
```

### 自定义异常类型

```js
// Create a new object, that prototypally inherits from the Error constructor.
function MyError(message) {
  this.name = 'MyError';
  this.message = message || 'Default Message';
  this.stack = (new Error()).stack;
}

MyError.prototype = Object.create(Error.prototype);
MyError.prototype.constructor = MyError;

try {
  throw new MyError('custom message');
} catch (e) {
  console.log(e.message);  // 'custom message'
  console.log(e.name);     // 'MyError'
}
```

## Sentry

[**Sentry**](https://sentry.io/welcome/) 是一个可实时捕捉错误并汇集日志的平台。以下的示例参照 React 项目:

1、首先在 Sentry 官网创建一个 React 项目，此时会获取该项目下的 **DSN**，它由以下几部分组成:

* 协议
* 验证 SDK 的公钥和密钥
* 目标 Sentry 服务器
* 验证用户绑定的项目 id

```TEXT
<!--  格式：'{PROTOCOL}://{PUBLIC_KEY}:{SECRET_KEY}@{HOST}/{PATH}{PROJECT_ID}' -->
https://f0adb1c13dd0407fa806a1a9015daccb@sentry.io/1411582
```

![sentry-dsn.png](https://i.loli.net/2019/03/09/5c83ad3d084fc.png)

2、在客户端安装 **raven-js**(Official Sentry SDKs for JavaScript):

```JS
// yarn add raven-js

import createSagaMiddleware from 'redux-saga'
import Raven from 'raven-js'
import createRavenMiddleware from 'raven-for-redux'

const sagaMiddleware = createSagaMiddleware({
  onError(error) {
    // Capturing Errors / Exceptions
    Raven.captureException(error)
  },
})
const middlewares = [sagaMiddleware]
// 必须配置 Raven.js 使用 Sentry DSN
if (process.env.NODE_ENV === 'production') {
  const RAVEN_DSN = 'https://f0adb1c13dd0407fa806a1a9015daccb@sentry.io/1411582'
  Raven.config(RAVEN_DSN).install()

  middlewares.push(createRavenMiddleware(Raven))
}
```

> config 也支持其他一些参数的自定义，[详细请看这里](https://docs.sentry.io/clients/javascript/config/) 👈

raven-js 是旧的 SDK，目前新的为 `@sentry/browser`(Sentry’s browser JavaScript SDK))，使用方式如下:

```JS
// yarn add @sentry/browser

import { init, captureMessage } from '@sentry/browser'

// init 也支持多种 options
init({
  dsn: '__DSN__',
  beforeSend(event) {
    // Modify the event here
    if (event.user) {
      // Don't send user's email address
      delete event.user.email;
    }
    return event;
  }
  // ...
})
// Capturing Messages
captureMessage('Hello, world!')
```

3、在 React 组件中可以通过 `componentDidCatch` 捕获 error:

```JS
// 这个生命周期被调用是在某个后代组件已经抛出一个错误之后
// error 是被抛出的错误
// info 是一个对象，带有一个 componentStack 键
componentDidCatch(error, errorInfo) {
  Raven.captureException(error, { extra: errorInfo });
}
```

> JS 运行期间，如果发生错误且错误没有被 `try catch` 等捕捉，就会冒泡到 window，触发 `onError` 事件。当然资源加载失败，比如 `img`、`script` 只会执行该元素 `onerror`，而不会冒泡到 `window.onerror`

## 参考链接

1. [MDN - Error](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)
2. [错误处理机制](http://javascript.ruanyifeng.com/grammar/error.html#toc11) By 阮一峰
3. [sentry 使用实践](https://www.jianshu.com/p/66e00077fac3) By max_wwwwww
